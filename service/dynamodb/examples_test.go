// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

package dynamodb_test

import (
	"bytes"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go/aws/awsconv"
	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/aws/awsutil"
	"github.com/aws/aws-sdk-go/service/dynamodb"
)

var _ time.Duration
var _ bytes.Buffer

func ExampleDynamoDB_BatchGetItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.BatchGetItemInput{
		RequestItems: map[string]*dynamodb.KeysAndAttributes{ // Required
			"Key": { // Required
				Keys: []map[string]*dynamodb.AttributeValue{ // Required
					{ // Required
						"Key": { // Required
							B:    []byte("PAYLOAD"),
							BOOL: awsconv.Bool(true),
							BS: [][]byte{
								[]byte("PAYLOAD"), // Required
								// More values...
							},
							L: []*dynamodb.AttributeValue{
								{ // Required
								// Recursive values...
								},
								// More values...
							},
							M: map[string]*dynamodb.AttributeValue{
								"Key": { // Required
								// Recursive values...
								},
								// More values...
							},
							N: awsconv.String("NumberAttributeValue"),
							NS: []*string{
								awsconv.String("NumberAttributeValue"), // Required
								// More values...
							},
							NULL: awsconv.Bool(true),
							S:    awsconv.String("StringAttributeValue"),
							SS: []*string{
								awsconv.String("StringAttributeValue"), // Required
								// More values...
							},
						},
						// More values...
					},
					// More values...
				},
				AttributesToGet: []*string{
					awsconv.String("AttributeName"), // Required
					// More values...
				},
				ConsistentRead: awsconv.Bool(true),
				ExpressionAttributeNames: map[string]*string{
					"Key": awsconv.String("AttributeName"), // Required
					// More values...
				},
				ProjectionExpression: awsconv.String("ProjectionExpression"),
			},
			// More values...
		},
		ReturnConsumedCapacity: awsconv.String("ReturnConsumedCapacity"),
	}
	resp, err := svc.BatchGetItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_BatchWriteItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.BatchWriteItemInput{
		RequestItems: map[string][]*dynamodb.WriteRequest{ // Required
			"Key": { // Required
				{ // Required
					DeleteRequest: &dynamodb.DeleteRequest{
						Key: map[string]*dynamodb.AttributeValue{ // Required
							"Key": { // Required
								B:    []byte("PAYLOAD"),
								BOOL: awsconv.Bool(true),
								BS: [][]byte{
									[]byte("PAYLOAD"), // Required
									// More values...
								},
								L: []*dynamodb.AttributeValue{
									{ // Required
									// Recursive values...
									},
									// More values...
								},
								M: map[string]*dynamodb.AttributeValue{
									"Key": { // Required
									// Recursive values...
									},
									// More values...
								},
								N: awsconv.String("NumberAttributeValue"),
								NS: []*string{
									awsconv.String("NumberAttributeValue"), // Required
									// More values...
								},
								NULL: awsconv.Bool(true),
								S:    awsconv.String("StringAttributeValue"),
								SS: []*string{
									awsconv.String("StringAttributeValue"), // Required
									// More values...
								},
							},
							// More values...
						},
					},
					PutRequest: &dynamodb.PutRequest{
						Item: map[string]*dynamodb.AttributeValue{ // Required
							"Key": { // Required
								B:    []byte("PAYLOAD"),
								BOOL: awsconv.Bool(true),
								BS: [][]byte{
									[]byte("PAYLOAD"), // Required
									// More values...
								},
								L: []*dynamodb.AttributeValue{
									{ // Required
									// Recursive values...
									},
									// More values...
								},
								M: map[string]*dynamodb.AttributeValue{
									"Key": { // Required
									// Recursive values...
									},
									// More values...
								},
								N: awsconv.String("NumberAttributeValue"),
								NS: []*string{
									awsconv.String("NumberAttributeValue"), // Required
									// More values...
								},
								NULL: awsconv.Bool(true),
								S:    awsconv.String("StringAttributeValue"),
								SS: []*string{
									awsconv.String("StringAttributeValue"), // Required
									// More values...
								},
							},
							// More values...
						},
					},
				},
				// More values...
			},
			// More values...
		},
		ReturnConsumedCapacity:      awsconv.String("ReturnConsumedCapacity"),
		ReturnItemCollectionMetrics: awsconv.String("ReturnItemCollectionMetrics"),
	}
	resp, err := svc.BatchWriteItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_CreateTable() {
	svc := dynamodb.New(nil)

	params := &dynamodb.CreateTableInput{
		AttributeDefinitions: []*dynamodb.AttributeDefinition{ // Required
			{ // Required
				AttributeName: awsconv.String("KeySchemaAttributeName"), // Required
				AttributeType: awsconv.String("ScalarAttributeType"),    // Required
			},
			// More values...
		},
		KeySchema: []*dynamodb.KeySchemaElement{ // Required
			{ // Required
				AttributeName: awsconv.String("KeySchemaAttributeName"), // Required
				KeyType:       awsconv.String("KeyType"),                // Required
			},
			// More values...
		},
		ProvisionedThroughput: &dynamodb.ProvisionedThroughput{ // Required
			ReadCapacityUnits:  awsconv.Int64(1), // Required
			WriteCapacityUnits: awsconv.Int64(1), // Required
		},
		TableName: awsconv.String("TableName"), // Required
		GlobalSecondaryIndexes: []*dynamodb.GlobalSecondaryIndex{
			{ // Required
				IndexName: awsconv.String("IndexName"), // Required
				KeySchema: []*dynamodb.KeySchemaElement{ // Required
					{ // Required
						AttributeName: awsconv.String("KeySchemaAttributeName"), // Required
						KeyType:       awsconv.String("KeyType"),                // Required
					},
					// More values...
				},
				Projection: &dynamodb.Projection{ // Required
					NonKeyAttributes: []*string{
						awsconv.String("NonKeyAttributeName"), // Required
						// More values...
					},
					ProjectionType: awsconv.String("ProjectionType"),
				},
				ProvisionedThroughput: &dynamodb.ProvisionedThroughput{ // Required
					ReadCapacityUnits:  awsconv.Int64(1), // Required
					WriteCapacityUnits: awsconv.Int64(1), // Required
				},
			},
			// More values...
		},
		LocalSecondaryIndexes: []*dynamodb.LocalSecondaryIndex{
			{ // Required
				IndexName: awsconv.String("IndexName"), // Required
				KeySchema: []*dynamodb.KeySchemaElement{ // Required
					{ // Required
						AttributeName: awsconv.String("KeySchemaAttributeName"), // Required
						KeyType:       awsconv.String("KeyType"),                // Required
					},
					// More values...
				},
				Projection: &dynamodb.Projection{ // Required
					NonKeyAttributes: []*string{
						awsconv.String("NonKeyAttributeName"), // Required
						// More values...
					},
					ProjectionType: awsconv.String("ProjectionType"),
				},
			},
			// More values...
		},
		StreamSpecification: &dynamodb.StreamSpecification{
			StreamEnabled:  awsconv.Bool(true),
			StreamViewType: awsconv.String("StreamViewType"),
		},
	}
	resp, err := svc.CreateTable(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_DeleteItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.DeleteItemInput{
		Key: map[string]*dynamodb.AttributeValue{ // Required
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: awsconv.Bool(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: awsconv.String("NumberAttributeValue"),
				NS: []*string{
					awsconv.String("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: awsconv.Bool(true),
				S:    awsconv.String("StringAttributeValue"),
				SS: []*string{
					awsconv.String("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		TableName:           awsconv.String("TableName"), // Required
		ConditionExpression: awsconv.String("ConditionExpression"),
		ConditionalOperator: awsconv.String("ConditionalOperator"),
		Expected: map[string]*dynamodb.ExpectedAttributeValue{
			"Key": { // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: awsconv.Bool(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: awsconv.String("NumberAttributeValue"),
						NS: []*string{
							awsconv.String("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: awsconv.Bool(true),
						S:    awsconv.String("StringAttributeValue"),
						SS: []*string{
							awsconv.String("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
				ComparisonOperator: awsconv.String("ComparisonOperator"),
				Exists:             awsconv.Bool(true),
				Value: &dynamodb.AttributeValue{
					B:    []byte("PAYLOAD"),
					BOOL: awsconv.Bool(true),
					BS: [][]byte{
						[]byte("PAYLOAD"), // Required
						// More values...
					},
					L: []*dynamodb.AttributeValue{
						{ // Required
						// Recursive values...
						},
						// More values...
					},
					M: map[string]*dynamodb.AttributeValue{
						"Key": { // Required
						// Recursive values...
						},
						// More values...
					},
					N: awsconv.String("NumberAttributeValue"),
					NS: []*string{
						awsconv.String("NumberAttributeValue"), // Required
						// More values...
					},
					NULL: awsconv.Bool(true),
					S:    awsconv.String("StringAttributeValue"),
					SS: []*string{
						awsconv.String("StringAttributeValue"), // Required
						// More values...
					},
				},
			},
			// More values...
		},
		ExpressionAttributeNames: map[string]*string{
			"Key": awsconv.String("AttributeName"), // Required
			// More values...
		},
		ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: awsconv.Bool(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: awsconv.String("NumberAttributeValue"),
				NS: []*string{
					awsconv.String("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: awsconv.Bool(true),
				S:    awsconv.String("StringAttributeValue"),
				SS: []*string{
					awsconv.String("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		ReturnConsumedCapacity:      awsconv.String("ReturnConsumedCapacity"),
		ReturnItemCollectionMetrics: awsconv.String("ReturnItemCollectionMetrics"),
		ReturnValues:                awsconv.String("ReturnValue"),
	}
	resp, err := svc.DeleteItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_DeleteTable() {
	svc := dynamodb.New(nil)

	params := &dynamodb.DeleteTableInput{
		TableName: awsconv.String("TableName"), // Required
	}
	resp, err := svc.DeleteTable(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_DescribeTable() {
	svc := dynamodb.New(nil)

	params := &dynamodb.DescribeTableInput{
		TableName: awsconv.String("TableName"), // Required
	}
	resp, err := svc.DescribeTable(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_GetItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.GetItemInput{
		Key: map[string]*dynamodb.AttributeValue{ // Required
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: awsconv.Bool(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: awsconv.String("NumberAttributeValue"),
				NS: []*string{
					awsconv.String("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: awsconv.Bool(true),
				S:    awsconv.String("StringAttributeValue"),
				SS: []*string{
					awsconv.String("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		TableName: awsconv.String("TableName"), // Required
		AttributesToGet: []*string{
			awsconv.String("AttributeName"), // Required
			// More values...
		},
		ConsistentRead: awsconv.Bool(true),
		ExpressionAttributeNames: map[string]*string{
			"Key": awsconv.String("AttributeName"), // Required
			// More values...
		},
		ProjectionExpression:   awsconv.String("ProjectionExpression"),
		ReturnConsumedCapacity: awsconv.String("ReturnConsumedCapacity"),
	}
	resp, err := svc.GetItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_ListTables() {
	svc := dynamodb.New(nil)

	params := &dynamodb.ListTablesInput{
		ExclusiveStartTableName: awsconv.String("TableName"),
		Limit: awsconv.Int64(1),
	}
	resp, err := svc.ListTables(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_PutItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.PutItemInput{
		Item: map[string]*dynamodb.AttributeValue{ // Required
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: awsconv.Bool(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: awsconv.String("NumberAttributeValue"),
				NS: []*string{
					awsconv.String("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: awsconv.Bool(true),
				S:    awsconv.String("StringAttributeValue"),
				SS: []*string{
					awsconv.String("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		TableName:           awsconv.String("TableName"), // Required
		ConditionExpression: awsconv.String("ConditionExpression"),
		ConditionalOperator: awsconv.String("ConditionalOperator"),
		Expected: map[string]*dynamodb.ExpectedAttributeValue{
			"Key": { // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: awsconv.Bool(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: awsconv.String("NumberAttributeValue"),
						NS: []*string{
							awsconv.String("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: awsconv.Bool(true),
						S:    awsconv.String("StringAttributeValue"),
						SS: []*string{
							awsconv.String("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
				ComparisonOperator: awsconv.String("ComparisonOperator"),
				Exists:             awsconv.Bool(true),
				Value: &dynamodb.AttributeValue{
					B:    []byte("PAYLOAD"),
					BOOL: awsconv.Bool(true),
					BS: [][]byte{
						[]byte("PAYLOAD"), // Required
						// More values...
					},
					L: []*dynamodb.AttributeValue{
						{ // Required
						// Recursive values...
						},
						// More values...
					},
					M: map[string]*dynamodb.AttributeValue{
						"Key": { // Required
						// Recursive values...
						},
						// More values...
					},
					N: awsconv.String("NumberAttributeValue"),
					NS: []*string{
						awsconv.String("NumberAttributeValue"), // Required
						// More values...
					},
					NULL: awsconv.Bool(true),
					S:    awsconv.String("StringAttributeValue"),
					SS: []*string{
						awsconv.String("StringAttributeValue"), // Required
						// More values...
					},
				},
			},
			// More values...
		},
		ExpressionAttributeNames: map[string]*string{
			"Key": awsconv.String("AttributeName"), // Required
			// More values...
		},
		ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: awsconv.Bool(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: awsconv.String("NumberAttributeValue"),
				NS: []*string{
					awsconv.String("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: awsconv.Bool(true),
				S:    awsconv.String("StringAttributeValue"),
				SS: []*string{
					awsconv.String("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		ReturnConsumedCapacity:      awsconv.String("ReturnConsumedCapacity"),
		ReturnItemCollectionMetrics: awsconv.String("ReturnItemCollectionMetrics"),
		ReturnValues:                awsconv.String("ReturnValue"),
	}
	resp, err := svc.PutItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_Query() {
	svc := dynamodb.New(nil)

	params := &dynamodb.QueryInput{
		TableName: awsconv.String("TableName"), // Required
		AttributesToGet: []*string{
			awsconv.String("AttributeName"), // Required
			// More values...
		},
		ConditionalOperator: awsconv.String("ConditionalOperator"),
		ConsistentRead:      awsconv.Bool(true),
		ExclusiveStartKey: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: awsconv.Bool(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: awsconv.String("NumberAttributeValue"),
				NS: []*string{
					awsconv.String("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: awsconv.Bool(true),
				S:    awsconv.String("StringAttributeValue"),
				SS: []*string{
					awsconv.String("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		ExpressionAttributeNames: map[string]*string{
			"Key": awsconv.String("AttributeName"), // Required
			// More values...
		},
		ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: awsconv.Bool(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: awsconv.String("NumberAttributeValue"),
				NS: []*string{
					awsconv.String("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: awsconv.Bool(true),
				S:    awsconv.String("StringAttributeValue"),
				SS: []*string{
					awsconv.String("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		FilterExpression:       awsconv.String("ConditionExpression"),
		IndexName:              awsconv.String("IndexName"),
		KeyConditionExpression: awsconv.String("KeyExpression"),
		KeyConditions: map[string]*dynamodb.Condition{
			"Key": { // Required
				ComparisonOperator: awsconv.String("ComparisonOperator"), // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: awsconv.Bool(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: awsconv.String("NumberAttributeValue"),
						NS: []*string{
							awsconv.String("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: awsconv.Bool(true),
						S:    awsconv.String("StringAttributeValue"),
						SS: []*string{
							awsconv.String("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
			},
			// More values...
		},
		Limit:                awsconv.Int64(1),
		ProjectionExpression: awsconv.String("ProjectionExpression"),
		QueryFilter: map[string]*dynamodb.Condition{
			"Key": { // Required
				ComparisonOperator: awsconv.String("ComparisonOperator"), // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: awsconv.Bool(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: awsconv.String("NumberAttributeValue"),
						NS: []*string{
							awsconv.String("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: awsconv.Bool(true),
						S:    awsconv.String("StringAttributeValue"),
						SS: []*string{
							awsconv.String("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
			},
			// More values...
		},
		ReturnConsumedCapacity: awsconv.String("ReturnConsumedCapacity"),
		ScanIndexForward:       awsconv.Bool(true),
		Select:                 awsconv.String("Select"),
	}
	resp, err := svc.Query(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_Scan() {
	svc := dynamodb.New(nil)

	params := &dynamodb.ScanInput{
		TableName: awsconv.String("TableName"), // Required
		AttributesToGet: []*string{
			awsconv.String("AttributeName"), // Required
			// More values...
		},
		ConditionalOperator: awsconv.String("ConditionalOperator"),
		ConsistentRead:      awsconv.Bool(true),
		ExclusiveStartKey: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: awsconv.Bool(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: awsconv.String("NumberAttributeValue"),
				NS: []*string{
					awsconv.String("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: awsconv.Bool(true),
				S:    awsconv.String("StringAttributeValue"),
				SS: []*string{
					awsconv.String("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		ExpressionAttributeNames: map[string]*string{
			"Key": awsconv.String("AttributeName"), // Required
			// More values...
		},
		ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: awsconv.Bool(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: awsconv.String("NumberAttributeValue"),
				NS: []*string{
					awsconv.String("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: awsconv.Bool(true),
				S:    awsconv.String("StringAttributeValue"),
				SS: []*string{
					awsconv.String("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		FilterExpression:       awsconv.String("ConditionExpression"),
		IndexName:              awsconv.String("IndexName"),
		Limit:                  awsconv.Int64(1),
		ProjectionExpression:   awsconv.String("ProjectionExpression"),
		ReturnConsumedCapacity: awsconv.String("ReturnConsumedCapacity"),
		ScanFilter: map[string]*dynamodb.Condition{
			"Key": { // Required
				ComparisonOperator: awsconv.String("ComparisonOperator"), // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: awsconv.Bool(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: awsconv.String("NumberAttributeValue"),
						NS: []*string{
							awsconv.String("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: awsconv.Bool(true),
						S:    awsconv.String("StringAttributeValue"),
						SS: []*string{
							awsconv.String("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
			},
			// More values...
		},
		Segment:       awsconv.Int64(1),
		Select:        awsconv.String("Select"),
		TotalSegments: awsconv.Int64(1),
	}
	resp, err := svc.Scan(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_UpdateItem() {
	svc := dynamodb.New(nil)

	params := &dynamodb.UpdateItemInput{
		Key: map[string]*dynamodb.AttributeValue{ // Required
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: awsconv.Bool(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: awsconv.String("NumberAttributeValue"),
				NS: []*string{
					awsconv.String("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: awsconv.Bool(true),
				S:    awsconv.String("StringAttributeValue"),
				SS: []*string{
					awsconv.String("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		TableName: awsconv.String("TableName"), // Required
		AttributeUpdates: map[string]*dynamodb.AttributeValueUpdate{
			"Key": { // Required
				Action: awsconv.String("AttributeAction"),
				Value: &dynamodb.AttributeValue{
					B:    []byte("PAYLOAD"),
					BOOL: awsconv.Bool(true),
					BS: [][]byte{
						[]byte("PAYLOAD"), // Required
						// More values...
					},
					L: []*dynamodb.AttributeValue{
						{ // Required
						// Recursive values...
						},
						// More values...
					},
					M: map[string]*dynamodb.AttributeValue{
						"Key": { // Required
						// Recursive values...
						},
						// More values...
					},
					N: awsconv.String("NumberAttributeValue"),
					NS: []*string{
						awsconv.String("NumberAttributeValue"), // Required
						// More values...
					},
					NULL: awsconv.Bool(true),
					S:    awsconv.String("StringAttributeValue"),
					SS: []*string{
						awsconv.String("StringAttributeValue"), // Required
						// More values...
					},
				},
			},
			// More values...
		},
		ConditionExpression: awsconv.String("ConditionExpression"),
		ConditionalOperator: awsconv.String("ConditionalOperator"),
		Expected: map[string]*dynamodb.ExpectedAttributeValue{
			"Key": { // Required
				AttributeValueList: []*dynamodb.AttributeValue{
					{ // Required
						B:    []byte("PAYLOAD"),
						BOOL: awsconv.Bool(true),
						BS: [][]byte{
							[]byte("PAYLOAD"), // Required
							// More values...
						},
						L: []*dynamodb.AttributeValue{
							{ // Required
							// Recursive values...
							},
							// More values...
						},
						M: map[string]*dynamodb.AttributeValue{
							"Key": { // Required
							// Recursive values...
							},
							// More values...
						},
						N: awsconv.String("NumberAttributeValue"),
						NS: []*string{
							awsconv.String("NumberAttributeValue"), // Required
							// More values...
						},
						NULL: awsconv.Bool(true),
						S:    awsconv.String("StringAttributeValue"),
						SS: []*string{
							awsconv.String("StringAttributeValue"), // Required
							// More values...
						},
					},
					// More values...
				},
				ComparisonOperator: awsconv.String("ComparisonOperator"),
				Exists:             awsconv.Bool(true),
				Value: &dynamodb.AttributeValue{
					B:    []byte("PAYLOAD"),
					BOOL: awsconv.Bool(true),
					BS: [][]byte{
						[]byte("PAYLOAD"), // Required
						// More values...
					},
					L: []*dynamodb.AttributeValue{
						{ // Required
						// Recursive values...
						},
						// More values...
					},
					M: map[string]*dynamodb.AttributeValue{
						"Key": { // Required
						// Recursive values...
						},
						// More values...
					},
					N: awsconv.String("NumberAttributeValue"),
					NS: []*string{
						awsconv.String("NumberAttributeValue"), // Required
						// More values...
					},
					NULL: awsconv.Bool(true),
					S:    awsconv.String("StringAttributeValue"),
					SS: []*string{
						awsconv.String("StringAttributeValue"), // Required
						// More values...
					},
				},
			},
			// More values...
		},
		ExpressionAttributeNames: map[string]*string{
			"Key": awsconv.String("AttributeName"), // Required
			// More values...
		},
		ExpressionAttributeValues: map[string]*dynamodb.AttributeValue{
			"Key": { // Required
				B:    []byte("PAYLOAD"),
				BOOL: awsconv.Bool(true),
				BS: [][]byte{
					[]byte("PAYLOAD"), // Required
					// More values...
				},
				L: []*dynamodb.AttributeValue{
					{ // Required
					// Recursive values...
					},
					// More values...
				},
				M: map[string]*dynamodb.AttributeValue{
					"Key": { // Required
					// Recursive values...
					},
					// More values...
				},
				N: awsconv.String("NumberAttributeValue"),
				NS: []*string{
					awsconv.String("NumberAttributeValue"), // Required
					// More values...
				},
				NULL: awsconv.Bool(true),
				S:    awsconv.String("StringAttributeValue"),
				SS: []*string{
					awsconv.String("StringAttributeValue"), // Required
					// More values...
				},
			},
			// More values...
		},
		ReturnConsumedCapacity:      awsconv.String("ReturnConsumedCapacity"),
		ReturnItemCollectionMetrics: awsconv.String("ReturnItemCollectionMetrics"),
		ReturnValues:                awsconv.String("ReturnValue"),
		UpdateExpression:            awsconv.String("UpdateExpression"),
	}
	resp, err := svc.UpdateItem(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleDynamoDB_UpdateTable() {
	svc := dynamodb.New(nil)

	params := &dynamodb.UpdateTableInput{
		TableName: awsconv.String("TableName"), // Required
		AttributeDefinitions: []*dynamodb.AttributeDefinition{
			{ // Required
				AttributeName: awsconv.String("KeySchemaAttributeName"), // Required
				AttributeType: awsconv.String("ScalarAttributeType"),    // Required
			},
			// More values...
		},
		GlobalSecondaryIndexUpdates: []*dynamodb.GlobalSecondaryIndexUpdate{
			{ // Required
				Create: &dynamodb.CreateGlobalSecondaryIndexAction{
					IndexName: awsconv.String("IndexName"), // Required
					KeySchema: []*dynamodb.KeySchemaElement{ // Required
						{ // Required
							AttributeName: awsconv.String("KeySchemaAttributeName"), // Required
							KeyType:       awsconv.String("KeyType"),                // Required
						},
						// More values...
					},
					Projection: &dynamodb.Projection{ // Required
						NonKeyAttributes: []*string{
							awsconv.String("NonKeyAttributeName"), // Required
							// More values...
						},
						ProjectionType: awsconv.String("ProjectionType"),
					},
					ProvisionedThroughput: &dynamodb.ProvisionedThroughput{ // Required
						ReadCapacityUnits:  awsconv.Int64(1), // Required
						WriteCapacityUnits: awsconv.Int64(1), // Required
					},
				},
				Delete: &dynamodb.DeleteGlobalSecondaryIndexAction{
					IndexName: awsconv.String("IndexName"), // Required
				},
				Update: &dynamodb.UpdateGlobalSecondaryIndexAction{
					IndexName: awsconv.String("IndexName"), // Required
					ProvisionedThroughput: &dynamodb.ProvisionedThroughput{ // Required
						ReadCapacityUnits:  awsconv.Int64(1), // Required
						WriteCapacityUnits: awsconv.Int64(1), // Required
					},
				},
			},
			// More values...
		},
		ProvisionedThroughput: &dynamodb.ProvisionedThroughput{
			ReadCapacityUnits:  awsconv.Int64(1), // Required
			WriteCapacityUnits: awsconv.Int64(1), // Required
		},
		StreamSpecification: &dynamodb.StreamSpecification{
			StreamEnabled:  awsconv.Bool(true),
			StreamViewType: awsconv.String("StreamViewType"),
		},
	}
	resp, err := svc.UpdateTable(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}
