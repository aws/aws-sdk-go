// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package dynamodb provides a client for Amazon DynamoDB.
package dynamodb

import (
	"sync"
	"time"

	"github.com/aws/aws-sdk-go/aws"
)

var oprw sync.Mutex

// BatchGetItemRequest generates a request for the BatchGetItem operation.
func (c *DynamoDB) BatchGetItemRequest(input *BatchGetItemInput) (req *aws.Request, output *BatchGetItemOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opBatchGetItem == nil {
		opBatchGetItem = &aws.Operation{
			Name:       "BatchGetItem",
			HTTPMethod: "POST",
			HTTPPath:   "/",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"RequestItems"},
				OutputTokens:    []string{"UnprocessedKeys"},
				LimitToken:      "",
				TruncationToken: "",
			},
		}
	}

	if input == nil {
		input = &BatchGetItemInput{}
	}

	req = c.newRequest(opBatchGetItem, input, output)
	output = &BatchGetItemOutput{}
	req.Data = output
	return
}

// The BatchGetItem operation returns the attributes of one or more items from
// one or more tables. You identify requested items by primary key.
//
// A single operation can retrieve up to 16 MB of data, which can contain as
// many as 100 items. BatchGetItem will return a partial result if the response
// size limit is exceeded, the table's provisioned throughput is exceeded, or
// an internal processing failure occurs. If a partial result is returned, the
// operation returns a value for UnprocessedKeys. You can use this value to
// retry the operation starting with the next item to get.
//
// For example, if you ask to retrieve 100 items, but each individual item
// is 300 KB in size, the system returns 52 items (so as not to exceed the 16
// MB limit). It also returns an appropriate UnprocessedKeys value so you can
// get the next page of results. If desired, your application can include its
// own logic to assemble the pages of results into one data set.
//
// If none of the items can be processed due to insufficient provisioned throughput
// on all of the tables in the request, then BatchGetItem will return a ProvisionedThroughputExceededException.
// If at least one of the items is successfully processed, then BatchGetItem
// completes successfully, while returning the keys of the unread items in UnprocessedKeys.
//
//  If DynamoDB returns any unprocessed items, you should retry the batch operation
// on those items. However, we strongly recommend that you use an exponential
// backoff algorithm. If you retry the batch operation immediately, the underlying
// read or write requests can still fail due to throttling on the individual
// tables. If you delay the batch operation using exponential backoff, the individual
// requests in the batch are much more likely to succeed.
//
// For more information, see Batch Operations and Error Handling (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#BatchOperations)
// in the Amazon DynamoDB Developer Guide.
//
//  By default, BatchGetItem performs eventually consistent reads on every
// table in the request. If you want strongly consistent reads instead, you
// can set ConsistentRead to true for any or all tables.
//
// In order to minimize response latency, BatchGetItem retrieves items in parallel.
//
// When designing your application, keep in mind that DynamoDB does not return
// attributes in any particular order. To help parse the response by item, include
// the primary key values for the items in your request in the AttributesToGet
// parameter.
//
// If a requested item does not exist, it is not returned in the result. Requests
// for nonexistent items consume the minimum read capacity units according to
// the type of read. For more information, see Capacity Units Calculations (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#CapacityUnitCalculations)
// in the Amazon DynamoDB Developer Guide.
func (c *DynamoDB) BatchGetItem(input *BatchGetItemInput) (*BatchGetItemOutput, error) {
	req, out := c.BatchGetItemRequest(input)
	err := req.Send()
	return out, err
}

func (c *DynamoDB) BatchGetItemPages(input *BatchGetItemInput, fn func(p *BatchGetItemOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.BatchGetItemRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*BatchGetItemOutput), lastPage)
	})
}

var opBatchGetItem *aws.Operation

// BatchWriteItemRequest generates a request for the BatchWriteItem operation.
func (c *DynamoDB) BatchWriteItemRequest(input *BatchWriteItemInput) (req *aws.Request, output *BatchWriteItemOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opBatchWriteItem == nil {
		opBatchWriteItem = &aws.Operation{
			Name:       "BatchWriteItem",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &BatchWriteItemInput{}
	}

	req = c.newRequest(opBatchWriteItem, input, output)
	output = &BatchWriteItemOutput{}
	req.Data = output
	return
}

// The BatchWriteItem operation puts or deletes multiple items in one or more
// tables. A single call to BatchWriteItem can write up to 16 MB of data, which
// can comprise as many as 25 put or delete requests. Individual items to be
// written can be as large as 400 KB.
//
//  BatchWriteItem cannot update items. To update items, use the UpdateItem
// API.
//
//  The individual PutItem and DeleteItem operations specified in BatchWriteItem
// are atomic; however BatchWriteItem as a whole is not. If any requested operations
// fail because the table's provisioned throughput is exceeded or an internal
// processing failure occurs, the failed operations are returned in the UnprocessedItems
// response parameter. You can investigate and optionally resend the requests.
// Typically, you would call BatchWriteItem in a loop. Each iteration would
// check for unprocessed items and submit a new BatchWriteItem request with
// those unprocessed items until all items have been processed.
//
// Note that if none of the items can be processed due to insufficient provisioned
// throughput on all of the tables in the request, then BatchWriteItem will
// return a ProvisionedThroughputExceededException.
//
//  If DynamoDB returns any unprocessed items, you should retry the batch operation
// on those items. However, we strongly recommend that you use an exponential
// backoff algorithm. If you retry the batch operation immediately, the underlying
// read or write requests can still fail due to throttling on the individual
// tables. If you delay the batch operation using exponential backoff, the individual
// requests in the batch are much more likely to succeed.
//
// For more information, see Batch Operations and Error Handling (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ErrorHandling.html#BatchOperations)
// in the Amazon DynamoDB Developer Guide.
//
//  With BatchWriteItem, you can efficiently write or delete large amounts
// of data, such as from Amazon Elastic MapReduce (EMR), or copy data from another
// database into DynamoDB. In order to improve performance with these large-scale
// operations, BatchWriteItem does not behave in the same way as individual
// PutItem and DeleteItem calls would. For example, you cannot specify conditions
// on individual put and delete requests, and BatchWriteItem does not return
// deleted items in the response.
//
// If you use a programming language that supports concurrency, such as Java,
// you can use threads to write items in parallel. Your application must include
// the necessary logic to manage the threads. With languages that don't support
// threading, such as PHP, you must update or delete the specified items one
// at a time. In both situations, BatchWriteItem provides an alternative where
// the API performs the specified put and delete operations in parallel, giving
// you the power of the thread pool approach without having to introduce complexity
// into your application.
//
// Parallel processing reduces latency, but each specified put and delete request
// consumes the same number of write capacity units whether it is processed
// in parallel or not. Delete operations on nonexistent items consume one write
// capacity unit.
//
// If one or more of the following is true, DynamoDB rejects the entire batch
// write operation:
//
//   One or more tables specified in the BatchWriteItem request does not exist.
//
//   Primary key attributes specified on an item in the request do not match
// those in the corresponding table's primary key schema.
//
//   You try to perform multiple operations on the same item in the same BatchWriteItem
// request. For example, you cannot put and delete the same item in the same
// BatchWriteItem request.
//
//   There are more than 25 requests in the batch.
//
//   Any individual item in a batch exceeds 400 KB.
//
//   The total request size exceeds 16 MB.
func (c *DynamoDB) BatchWriteItem(input *BatchWriteItemInput) (*BatchWriteItemOutput, error) {
	req, out := c.BatchWriteItemRequest(input)
	err := req.Send()
	return out, err
}

var opBatchWriteItem *aws.Operation

// CreateTableRequest generates a request for the CreateTable operation.
func (c *DynamoDB) CreateTableRequest(input *CreateTableInput) (req *aws.Request, output *CreateTableOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCreateTable == nil {
		opCreateTable = &aws.Operation{
			Name:       "CreateTable",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &CreateTableInput{}
	}

	req = c.newRequest(opCreateTable, input, output)
	output = &CreateTableOutput{}
	req.Data = output
	return
}

// The CreateTable operation adds a new table to your account. In an AWS account,
// table names must be unique within each region. That is, you can have two
// tables with same name if you create the tables in different regions.
//
// CreateTable is an asynchronous operation. Upon receiving a CreateTable request,
// DynamoDB immediately returns a response with a TableStatus of CREATING. After
// the table is created, DynamoDB sets the TableStatus to ACTIVE. You can perform
// read and write operations only on an ACTIVE table.
//
// You can optionally define secondary indexes on the new table, as part of
// the CreateTable operation. If you want to create multiple tables with secondary
// indexes on them, you must create the tables sequentially. Only one table
// with secondary indexes can be in the CREATING state at any given time.
//
// You can use the DescribeTable API to check the table status.
func (c *DynamoDB) CreateTable(input *CreateTableInput) (*CreateTableOutput, error) {
	req, out := c.CreateTableRequest(input)
	err := req.Send()
	return out, err
}

var opCreateTable *aws.Operation

// DeleteItemRequest generates a request for the DeleteItem operation.
func (c *DynamoDB) DeleteItemRequest(input *DeleteItemInput) (req *aws.Request, output *DeleteItemOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteItem == nil {
		opDeleteItem = &aws.Operation{
			Name:       "DeleteItem",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DeleteItemInput{}
	}

	req = c.newRequest(opDeleteItem, input, output)
	output = &DeleteItemOutput{}
	req.Data = output
	return
}

// Deletes a single item in a table by primary key. You can perform a conditional
// delete operation that deletes the item if it exists, or if it has an expected
// attribute value.
//
// In addition to deleting an item, you can also return the item's attribute
// values in the same operation, using the ReturnValues parameter.
//
// Unless you specify conditions, the DeleteItem is an idempotent operation;
// running it multiple times on the same item or attribute does not result in
// an error response.
//
// Conditional deletes are useful for deleting items only if specific conditions
// are met. If those conditions are met, DynamoDB performs the delete. Otherwise,
// the item is not deleted.
func (c *DynamoDB) DeleteItem(input *DeleteItemInput) (*DeleteItemOutput, error) {
	req, out := c.DeleteItemRequest(input)
	err := req.Send()
	return out, err
}

var opDeleteItem *aws.Operation

// DeleteTableRequest generates a request for the DeleteTable operation.
func (c *DynamoDB) DeleteTableRequest(input *DeleteTableInput) (req *aws.Request, output *DeleteTableOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteTable == nil {
		opDeleteTable = &aws.Operation{
			Name:       "DeleteTable",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DeleteTableInput{}
	}

	req = c.newRequest(opDeleteTable, input, output)
	output = &DeleteTableOutput{}
	req.Data = output
	return
}

// The DeleteTable operation deletes a table and all of its items. After a DeleteTable
// request, the specified table is in the DELETING state until DynamoDB completes
// the deletion. If the table is in the ACTIVE state, you can delete it. If
// a table is in CREATING or UPDATING states, then DynamoDB returns a ResourceInUseException.
// If the specified table does not exist, DynamoDB returns a ResourceNotFoundException.
// If table is already in the DELETING state, no error is returned.
//
//  DynamoDB might continue to accept data read and write operations, such
// as GetItem and PutItem, on a table in the DELETING state until the table
// deletion is complete.
//
//  When you delete a table, any indexes on that table are also deleted.
//
// Use the DescribeTable API to check the status of the table.
func (c *DynamoDB) DeleteTable(input *DeleteTableInput) (*DeleteTableOutput, error) {
	req, out := c.DeleteTableRequest(input)
	err := req.Send()
	return out, err
}

var opDeleteTable *aws.Operation

// DescribeTableRequest generates a request for the DescribeTable operation.
func (c *DynamoDB) DescribeTableRequest(input *DescribeTableInput) (req *aws.Request, output *DescribeTableOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDescribeTable == nil {
		opDescribeTable = &aws.Operation{
			Name:       "DescribeTable",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DescribeTableInput{}
	}

	req = c.newRequest(opDescribeTable, input, output)
	output = &DescribeTableOutput{}
	req.Data = output
	return
}

// Returns information about the table, including the current status of the
// table, when it was created, the primary key schema, and any indexes on the
// table.
//
//  If you issue a DescribeTable request immediately after a CreateTable request,
// DynamoDB might return a ResourceNotFoundException. This is because DescribeTable
// uses an eventually consistent query, and the metadata for your table might
// not be available at that moment. Wait for a few seconds, and then try the
// DescribeTable request again.
func (c *DynamoDB) DescribeTable(input *DescribeTableInput) (*DescribeTableOutput, error) {
	req, out := c.DescribeTableRequest(input)
	err := req.Send()
	return out, err
}

var opDescribeTable *aws.Operation

// GetItemRequest generates a request for the GetItem operation.
func (c *DynamoDB) GetItemRequest(input *GetItemInput) (req *aws.Request, output *GetItemOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetItem == nil {
		opGetItem = &aws.Operation{
			Name:       "GetItem",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &GetItemInput{}
	}

	req = c.newRequest(opGetItem, input, output)
	output = &GetItemOutput{}
	req.Data = output
	return
}

// The GetItem operation returns a set of attributes for the item with the given
// primary key. If there is no matching item, GetItem does not return any data.
//
// GetItem provides an eventually consistent read by default. If your application
// requires a strongly consistent read, set ConsistentRead to true. Although
// a strongly consistent read might take more time than an eventually consistent
// read, it always returns the last updated value.
func (c *DynamoDB) GetItem(input *GetItemInput) (*GetItemOutput, error) {
	req, out := c.GetItemRequest(input)
	err := req.Send()
	return out, err
}

var opGetItem *aws.Operation

// ListTablesRequest generates a request for the ListTables operation.
func (c *DynamoDB) ListTablesRequest(input *ListTablesInput) (req *aws.Request, output *ListTablesOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opListTables == nil {
		opListTables = &aws.Operation{
			Name:       "ListTables",
			HTTPMethod: "POST",
			HTTPPath:   "/",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"ExclusiveStartTableName"},
				OutputTokens:    []string{"LastEvaluatedTableName"},
				LimitToken:      "Limit",
				TruncationToken: "",
			},
		}
	}

	if input == nil {
		input = &ListTablesInput{}
	}

	req = c.newRequest(opListTables, input, output)
	output = &ListTablesOutput{}
	req.Data = output
	return
}

// Returns an array of table names associated with the current account and endpoint.
// The output from ListTables is paginated, with each page returning a maximum
// of 100 table names.
func (c *DynamoDB) ListTables(input *ListTablesInput) (*ListTablesOutput, error) {
	req, out := c.ListTablesRequest(input)
	err := req.Send()
	return out, err
}

func (c *DynamoDB) ListTablesPages(input *ListTablesInput, fn func(p *ListTablesOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.ListTablesRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*ListTablesOutput), lastPage)
	})
}

var opListTables *aws.Operation

// PutItemRequest generates a request for the PutItem operation.
func (c *DynamoDB) PutItemRequest(input *PutItemInput) (req *aws.Request, output *PutItemOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutItem == nil {
		opPutItem = &aws.Operation{
			Name:       "PutItem",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &PutItemInput{}
	}

	req = c.newRequest(opPutItem, input, output)
	output = &PutItemOutput{}
	req.Data = output
	return
}

// Creates a new item, or replaces an old item with a new item. If an item that
// has the same primary key as the new item already exists in the specified
// table, the new item completely replaces the existing item. You can perform
// a conditional put operation (add a new item if one with the specified primary
// key doesn't exist), or replace an existing item if it has certain attribute
// values.
//
// In addition to putting an item, you can also return the item's attribute
// values in the same operation, using the ReturnValues parameter.
//
// When you add an item, the primary key attribute(s) are the only required
// attributes. Attribute values cannot be null. String and Binary type attributes
// must have lengths greater than zero. Set type attributes cannot be empty.
// Requests with empty values will be rejected with a ValidationException exception.
//
// You can request that PutItem return either a copy of the original item (before
// the update) or a copy of the updated item (after the update). For more information,
// see the ReturnValues description below.
//
//  To prevent a new item from replacing an existing item, use a conditional
// put operation with ComparisonOperator set to NULL for the primary key attribute,
// or attributes.
//
//  For more information about using this API, see Working with Items (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithItems.html)
// in the Amazon DynamoDB Developer Guide.
func (c *DynamoDB) PutItem(input *PutItemInput) (*PutItemOutput, error) {
	req, out := c.PutItemRequest(input)
	err := req.Send()
	return out, err
}

var opPutItem *aws.Operation

// QueryRequest generates a request for the Query operation.
func (c *DynamoDB) QueryRequest(input *QueryInput) (req *aws.Request, output *QueryOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opQuery == nil {
		opQuery = &aws.Operation{
			Name:       "Query",
			HTTPMethod: "POST",
			HTTPPath:   "/",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"ExclusiveStartKey"},
				OutputTokens:    []string{"LastEvaluatedKey"},
				LimitToken:      "Limit",
				TruncationToken: "",
			},
		}
	}

	if input == nil {
		input = &QueryInput{}
	}

	req = c.newRequest(opQuery, input, output)
	output = &QueryOutput{}
	req.Data = output
	return
}

// A Query operation uses the primary key of a table or a secondary index to
// directly access items from that table or index.
//
// Use the KeyConditionExpression parameter to provide a specific hash key
// value. The Query operation will return all of the items from the table or
// index with that hash key value. You can optionally narrow the scope of the
// Query by specifying a range key value and a comparison operator in the KeyConditionExpression.
// You can use the ScanIndexForward parameter to get results in forward or reverse
// order, by range key or by index key.
//
// Queries that do not return results consume the minimum number of read capacity
// units for that type of read operation.
//
// If the total number of items meeting the query criteria exceeds the result
// set size limit of 1 MB, the query stops and results are returned to the user
// with LastEvaluatedKey to continue the query in a subsequent operation. Unlike
// a Scan operation, a Query operation never returns both an empty result set
// and a LastEvaluatedKey. The LastEvaluatedKey is only provided if the results
// exceed 1 MB, or if you have used Limit.
//
// You can query a table, a local secondary index, or a global secondary index.
// For a query on a table or on a local secondary index, you can set ConsistentRead
// to true and obtain a strongly consistent result. Global secondary indexes
// support eventually consistent reads only, so do not specify ConsistentRead
// when querying a global secondary index.
func (c *DynamoDB) Query(input *QueryInput) (*QueryOutput, error) {
	req, out := c.QueryRequest(input)
	err := req.Send()
	return out, err
}

func (c *DynamoDB) QueryPages(input *QueryInput, fn func(p *QueryOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.QueryRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*QueryOutput), lastPage)
	})
}

var opQuery *aws.Operation

// ScanRequest generates a request for the Scan operation.
func (c *DynamoDB) ScanRequest(input *ScanInput) (req *aws.Request, output *ScanOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opScan == nil {
		opScan = &aws.Operation{
			Name:       "Scan",
			HTTPMethod: "POST",
			HTTPPath:   "/",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"ExclusiveStartKey"},
				OutputTokens:    []string{"LastEvaluatedKey"},
				LimitToken:      "Limit",
				TruncationToken: "",
			},
		}
	}

	if input == nil {
		input = &ScanInput{}
	}

	req = c.newRequest(opScan, input, output)
	output = &ScanOutput{}
	req.Data = output
	return
}

// The Scan operation returns one or more items and item attributes by accessing
// every item in a table or a secondary index. To have DynamoDB return fewer
// items, you can provide a ScanFilter operation.
//
// If the total number of scanned items exceeds the maximum data set size limit
// of 1 MB, the scan stops and results are returned to the user as a LastEvaluatedKey
// value to continue the scan in a subsequent operation. The results also include
// the number of items exceeding the limit. A scan can result in no table data
// meeting the filter criteria.
//
// The result set is eventually consistent.
//
// By default, Scan operations proceed sequentially; however, for faster performance
// on a large table or secondary index, applications can request a parallel
// Scan operation by providing the Segment and TotalSegments parameters. For
// more information, see Parallel Scan (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#QueryAndScanParallelScan)
// in the Amazon DynamoDB Developer Guide.
func (c *DynamoDB) Scan(input *ScanInput) (*ScanOutput, error) {
	req, out := c.ScanRequest(input)
	err := req.Send()
	return out, err
}

func (c *DynamoDB) ScanPages(input *ScanInput, fn func(p *ScanOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.ScanRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*ScanOutput), lastPage)
	})
}

var opScan *aws.Operation

// UpdateItemRequest generates a request for the UpdateItem operation.
func (c *DynamoDB) UpdateItemRequest(input *UpdateItemInput) (req *aws.Request, output *UpdateItemOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opUpdateItem == nil {
		opUpdateItem = &aws.Operation{
			Name:       "UpdateItem",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &UpdateItemInput{}
	}

	req = c.newRequest(opUpdateItem, input, output)
	output = &UpdateItemOutput{}
	req.Data = output
	return
}

// Edits an existing item's attributes, or adds a new item to the table if it
// does not already exist. You can put, delete, or add attribute values. You
// can also perform a conditional update on an existing item (insert a new attribute
// name-value pair if it doesn't exist, or replace an existing name-value pair
// if it has certain expected attribute values). If conditions are specified
// and the item does not exist, then the operation fails and a new item is not
// created.
//
// You can also return the item's attribute values in the same UpdateItem operation
// using the ReturnValues parameter.
func (c *DynamoDB) UpdateItem(input *UpdateItemInput) (*UpdateItemOutput, error) {
	req, out := c.UpdateItemRequest(input)
	err := req.Send()
	return out, err
}

var opUpdateItem *aws.Operation

// UpdateTableRequest generates a request for the UpdateTable operation.
func (c *DynamoDB) UpdateTableRequest(input *UpdateTableInput) (req *aws.Request, output *UpdateTableOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opUpdateTable == nil {
		opUpdateTable = &aws.Operation{
			Name:       "UpdateTable",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &UpdateTableInput{}
	}

	req = c.newRequest(opUpdateTable, input, output)
	output = &UpdateTableOutput{}
	req.Data = output
	return
}

// Updates the provisioned throughput for the given table, or manages the global
// secondary indexes on the table.
//
// You can increase or decrease the table's provisioned throughput values within
// the maximums and minimums listed in the Limits (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
// section in the Amazon DynamoDB Developer Guide.
//
// In addition, you can use UpdateTable to add, modify or delete global secondary
// indexes on the table. For more information, see Managing Global Secondary
// Indexes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GSI.OnlineOps.html)
// in the Amazon DynamoDB Developer Guide.
//
// The table must be in the ACTIVE state for UpdateTable to succeed. UpdateTable
// is an asynchronous operation; while executing the operation, the table is
// in the UPDATING state. While the table is in the UPDATING state, the table
// still has the provisioned throughput from before the call. The table's new
// provisioned throughput settings go into effect when the table returns to
// the ACTIVE state; at that point, the UpdateTable operation is complete.
func (c *DynamoDB) UpdateTable(input *UpdateTableInput) (*UpdateTableOutput, error) {
	req, out := c.UpdateTableRequest(input)
	err := req.Send()
	return out, err
}

var opUpdateTable *aws.Operation

// Represents an attribute for describing the key schema for the table and indexes.
type AttributeDefinition struct {
	// A name for the attribute.
	AttributeName *string `type:"string" required:"true"`

	// The data type for the attribute.
	AttributeType *string `type:"string" required:"true"`

	metadataAttributeDefinition `json:"-" xml:"-"`
}

type metadataAttributeDefinition struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the data for an attribute. You can set one, and only one, of the
// elements.
//
// Each attribute in an item is a name-value pair. An attribute can be single-valued
// or multi-valued set. For example, a book item can have title and authors
// attributes. Each book has one title but can have many authors. The multi-valued
// attribute is a set; duplicate values are not allowed.
type AttributeValue struct {
	// A Binary data type.
	B []byte `type:"blob"`

	// A Boolean data type.
	BOOL *bool `type:"boolean"`

	// A Binary Set data type.
	BS [][]byte `type:"list"`

	// A List of attribute values.
	L []*AttributeValue `type:"list"`

	// A Map of attribute values.
	M map[string]*AttributeValue `type:"map"`

	// A Number data type.
	N *string `type:"string"`

	// A Number Set data type.
	NS []*string `type:"list"`

	// A Null data type.
	NULL *bool `type:"boolean"`

	// A String data type.
	S *string `type:"string"`

	// A String Set data type.
	SS []*string `type:"list"`

	metadataAttributeValue `json:"-" xml:"-"`
}

type metadataAttributeValue struct {
	SDKShapeTraits bool `type:"structure"`
}

// For the UpdateItem operation, represents the attributes to be modified, the
// action to perform on each, and the new value for each.
//
//  You cannot use UpdateItem to update any primary key attributes. Instead,
// you will need to delete the item, and then use PutItem to create a new item
// with new attributes.
//
//  Attribute values cannot be null; string and binary type attributes must
// have lengths greater than zero; and set type attributes must not be empty.
// Requests with empty values will be rejected with a ValidationException exception.
type AttributeValueUpdate struct {
	// Specifies how to perform the update. Valid values are PUT (default), DELETE,
	// and ADD. The behavior depends on whether the specified primary key already
	// exists in the table.
	//
	//  If an item with the specified Key is found in the table:
	//
	//   PUT - Adds the specified attribute to the item. If the attribute already
	// exists, it is replaced by the new value.
	//
	//   DELETE - If no value is specified, the attribute and its value are removed
	// from the item. The data type of the specified value must match the existing
	// value's data type.
	//
	// If a set of values is specified, then those values are subtracted from the
	// old set. For example, if the attribute value was the set [a,b,c] and the
	// DELETE action specified [a,c], then the final attribute value would be [b].
	// Specifying an empty set is an error.
	//
	//   ADD - If the attribute does not already exist, then the attribute and
	// its values are added to the item. If the attribute does exist, then the behavior
	// of ADD depends on the data type of the attribute:
	//
	//   If the existing attribute is a number, and if Value is also a number,
	// then the Value is mathematically added to the existing attribute. If Value
	// is a negative number, then it is subtracted from the existing attribute.
	//
	//   If you use ADD to increment or decrement a number value for an item that
	// doesn't exist before the update, DynamoDB uses 0 as the initial value.
	//
	// In addition, if you use ADD to update an existing item, and intend to increment
	// or decrement an attribute value which does not yet exist, DynamoDB uses 0
	// as the initial value. For example, suppose that the item you want to update
	// does not yet have an attribute named itemcount, but you decide to ADD the
	// number 3 to this attribute anyway, even though it currently does not exist.
	// DynamoDB will create the itemcount attribute, set its initial value to 0,
	// and finally add 3 to it. The result will be a new itemcount attribute in
	// the item, with a value of 3.
	//
	//    If the existing data type is a set, and if the Value is also a set, then
	// the Value is added to the existing set. (This is a set operation, not mathematical
	// addition.) For example, if the attribute value was the set [1,2], and the
	// ADD action specified [3], then the final attribute value would be [1,2,3].
	// An error occurs if an Add action is specified for a set attribute and the
	// attribute type specified does not match the existing set type.
	//
	// Both sets must have the same primitive data type. For example, if the existing
	// data type is a set of strings, the Value must also be a set of strings. The
	// same holds true for number sets and binary sets.
	//
	//   This action is only valid for an existing attribute whose data type is
	// number or is a set. Do not use ADD for any other data types.
	//
	//    If no item with the specified Key is found:
	//
	//   PUT - DynamoDB creates a new item with the specified primary key, and
	// then adds the attribute.
	//
	//   DELETE - Nothing happens; there is no attribute to delete.
	//
	//   ADD - DynamoDB creates an item with the supplied primary key and number
	// (or set of numbers) for the attribute value. The only data types allowed
	// are number and number set; no other data types can be specified.
	Action *string `type:"string"`

	// Represents the data for an attribute. You can set one, and only one, of the
	// elements.
	//
	// Each attribute in an item is a name-value pair. An attribute can be single-valued
	// or multi-valued set. For example, a book item can have title and authors
	// attributes. Each book has one title but can have many authors. The multi-valued
	// attribute is a set; duplicate values are not allowed.
	Value *AttributeValue `type:"structure"`

	metadataAttributeValueUpdate `json:"-" xml:"-"`
}

type metadataAttributeValueUpdate struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of a BatchGetItem operation.
type BatchGetItemInput struct {
	// A map of one or more table names and, for each table, a map that describes
	// one or more items to retrieve from that table. Each table name can be used
	// only once per BatchGetItem request.
	//
	// Each element in the map of items to retrieve consists of the following:
	//
	//   ConsistentRead - If true, a strongly consistent read is used; if false
	// (the default), an eventually consistent read is used.
	//
	//    ExpressionAttributeNames - One or more substitution tokens for attribute
	// names in the ProjectionExpression parameter. The following are some use cases
	// for using ExpressionAttributeNames:
	//
	//   To access an attribute whose name conflicts with a DynamoDB reserved word.
	//
	//   To create a placeholder for repeating occurrences of an attribute name
	// in an expression.
	//
	//   To prevent special characters in an attribute name from being misinterpreted
	// in an expression.
	//
	//   Use the # character in an expression to dereference an attribute name.
	// For example, consider the following attribute name:
	//
	// Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot
	// be used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	// {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	// #P = :val
	//
	//  Tokens that begin with the : character are expression attribute values,
	// which are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Accessing Item Attributes
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	//   Keys - An array of primary key attribute values that define specific items
	// in the table. For each primary key, you must provide all of the key attributes.
	// For example, with a hash type primary key, you only need to provide the hash
	// attribute. For a hash-and-range type primary key, you must provide both the
	// hash attribute and the range attribute.
	//
	//   ProjectionExpression - A string that identifies one or more attributes
	// to retrieve from the table. These attributes can include scalars, sets, or
	// elements of a JSON document. The attributes in the expression must be separated
	// by commas.
	//
	// If no attribute names are specified, then all attributes will be returned.
	// If any of the requested attributes are not found, they will not appear in
	// the result.
	//
	// For more information, see Accessing Item Attributes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	//    AttributesToGet -
	//
	//  This is a legacy parameter, for backward compatibility. New applications
	// should use ProjectionExpression instead. Do not combine legacy parameters
	// and expression parameters in a single API call; otherwise, DynamoDB will
	// return a ValidationException exception.
	//
	// This parameter allows you to retrieve attributes of type List or Map; however,
	// it cannot retrieve individual elements within a List or a Map.
	//
	//  The names of one or more attributes to retrieve. If no attribute names
	// are provided, then all attributes will be returned. If any of the requested
	// attributes are not found, they will not appear in the result.
	//
	// Note that AttributesToGet has no effect on provisioned throughput consumption.
	// DynamoDB determines capacity units consumed based on item size, not on the
	// amount of data that is returned to an application.
	RequestItems map[string]*KeysAndAttributes `type:"map" required:"true"`

	// A value that if set to TOTAL, the response includes ConsumedCapacity data
	// for tables and indexes. If set to INDEXES, the response includes ConsumedCapacity
	// for indexes. If set to NONE (the default), ConsumedCapacity is not included
	// in the response.
	ReturnConsumedCapacity *string `type:"string"`

	metadataBatchGetItemInput `json:"-" xml:"-"`
}

type metadataBatchGetItemInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of a BatchGetItem operation.
type BatchGetItemOutput struct {
	// The read capacity units consumed by the operation.
	//
	// Each element consists of:
	//
	//   TableName - The table that consumed the provisioned throughput.
	//
	//   CapacityUnits - The total number of capacity units consumed.
	ConsumedCapacity []*ConsumedCapacity `type:"list"`

	// A map of table name to a list of items. Each object in Responses consists
	// of a table name, along with a map of attribute data consisting of the data
	// type and attribute value.
	Responses map[string][]map[string]*AttributeValue `type:"map"`

	// A map of tables and their respective keys that were not processed with the
	// current response. The UnprocessedKeys value is in the same form as RequestItems,
	// so the value can be provided directly to a subsequent BatchGetItem operation.
	// For more information, see RequestItems in the Request Parameters section.
	//
	// Each element consists of:
	//
	//   Keys - An array of primary key attribute values that define specific items
	// in the table.
	//
	//   AttributesToGet - One or more attributes to be retrieved from the table
	// or index. By default, all attributes are returned. If a requested attribute
	// is not found, it does not appear in the result.
	//
	//   ConsistentRead - The consistency of a read operation. If set to true,
	// then a strongly consistent read is used; otherwise, an eventually consistent
	// read is used.
	//
	//   If there are no unprocessed keys remaining, the response contains an empty
	// UnprocessedKeys map.
	UnprocessedKeys map[string]*KeysAndAttributes `type:"map"`

	metadataBatchGetItemOutput `json:"-" xml:"-"`
}

type metadataBatchGetItemOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of a BatchWriteItem operation.
type BatchWriteItemInput struct {
	// A map of one or more table names and, for each table, a list of operations
	// to be performed (DeleteRequest or PutRequest). Each element in the map consists
	// of the following:
	//
	//   DeleteRequest - Perform a DeleteItem operation on the specified item.
	// The item to be deleted is identified by a Key subelement:
	//
	//   Key - A map of primary key attribute values that uniquely identify the
	// ! item. Each entry in this map consists of an attribute name and an attribute
	// value. For each primary key, you must provide all of the key attributes.
	// For example, with a hash type primary key, you only need to provide the hash
	// attribute. For a hash-and-range type primary key, you must provide both the
	// hash attribute and the range attribute.
	//
	//     PutRequest - Perform a PutItem operation on the specified item. The
	// item to be put is identified by an Item subelement:
	//
	//   Item - A map of attributes and their values. Each entry in this map consists
	// of an attribute name and an attribute value. Attribute values must not be
	// null; string and binary type attributes must have lengths greater than zero;
	// and set type attributes must not be empty. Requests that contain empty values
	// will be rejected with a ValidationException exception.
	//
	// If you specify any attributes that are part of an index key, then the data
	// types for those attributes must match those of the schema in the table's
	// attribute definition.
	RequestItems map[string][]*WriteRequest `type:"map" required:"true"`

	// A value that if set to TOTAL, the response includes ConsumedCapacity data
	// for tables and indexes. If set to INDEXES, the response includes ConsumedCapacity
	// for indexes. If set to NONE (the default), ConsumedCapacity is not included
	// in the response.
	ReturnConsumedCapacity *string `type:"string"`

	// A value that if set to SIZE, the response includes statistics about item
	// collections, if any, that were modified during the operation are returned
	// in the response. If set to NONE (the default), no statistics are returned.
	ReturnItemCollectionMetrics *string `type:"string"`

	metadataBatchWriteItemInput `json:"-" xml:"-"`
}

type metadataBatchWriteItemInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of a BatchWriteItem operation.
type BatchWriteItemOutput struct {
	// The capacity units consumed by the operation.
	//
	// Each element consists of:
	//
	//   TableName - The table that consumed the provisioned throughput.
	//
	//   CapacityUnits - The total number of capacity units consumed.
	ConsumedCapacity []*ConsumedCapacity `type:"list"`

	// A list of tables that were processed by BatchWriteItem and, for each table,
	// information about any item collections that were affected by individual DeleteItem
	// or PutItem operations.
	//
	// Each entry consists of the following subelements:
	//
	//   ItemCollectionKey - The hash key value of the item collection. This is
	// the same as the hash key of the item.
	//
	//   SizeEstimateRange - An estimate of item collection size, expressed in
	// GB. This is a two-element array containing a lower bound and an upper bound
	// for the estimate. The estimate includes the size of all the items in the
	// table, plus the size of all attributes projected into all of the local secondary
	// indexes on the table. Use this estimate to measure whether a local secondary
	// index is approaching its size limit.
	//
	// The estimate is subject to change over time; therefore, do not rely on the
	// precision or accuracy of the estimate.
	ItemCollectionMetrics map[string][]*ItemCollectionMetrics `type:"map"`

	// A map of tables and requests against those tables that were not processed.
	// The UnprocessedItems value is in the same form as RequestItems, so you can
	// provide this value directly to a subsequent BatchGetItem operation. For more
	// information, see RequestItems in the Request Parameters section.
	//
	// Each UnprocessedItems entry consists of a table name and, for that table,
	// a list of operations to perform (DeleteRequest or PutRequest).
	//
	//   DeleteRequest - Perform a DeleteItem operation on the specified item.
	// The item to be deleted is identified by a Key subelement:
	//
	//   Key - A map of primary key attribute values that uniquely identify the
	// item. Each entry in this map consists of an attribute name and an attribute
	// value.
	//
	//     PutRequest - Perform a PutItem operation on the specified item. The
	// item to be put is identified by an Item subelement:
	//
	//   Item - A map of attributes and their values. Each entry in this map consists
	// of an attribute name and an attribute value. Attribute values must not be
	// null; string and binary type attributes must have lengths greater than zero;
	// and set type attributes must not be empty. Requests that contain empty values
	// will be rejected with a ValidationException exception.
	//
	// If you specify any attributes that are part of an index key, then the data
	// types for those attributes must match those of the schema in the table's
	// attribute definition.
	//
	//     If there are no unprocessed items remaining, the response contains an
	// empty UnprocessedItems map.
	UnprocessedItems map[string][]*WriteRequest `type:"map"`

	metadataBatchWriteItemOutput `json:"-" xml:"-"`
}

type metadataBatchWriteItemOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the amount of provisioned throughput capacity consumed on a table
// or an index.
type Capacity struct {
	// The total number of capacity units consumed on a table or an index.
	CapacityUnits *float64 `type:"double"`

	metadataCapacity `json:"-" xml:"-"`
}

type metadataCapacity struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the selection criteria for a Query or Scan operation:
//
//   For a Query operation, Condition is used for specifying the KeyConditions
// to use when querying a table or an index. For KeyConditions, only the following
// comparison operators are supported:
//
//  EQ | LE | LT | GE | GT | BEGINS_WITH | BETWEEN
//
// Condition is also used in a QueryFilter, which evaluates the query results
// and returns only the desired values.
//
//   For a Scan operation, Condition is used in a ScanFilter, which evaluates
// the scan results and returns only the desired values.
type Condition struct {
	// One or more values to evaluate against the supplied attribute. The number
	// of values in the list depends on the ComparisonOperator being used.
	//
	// For type Number, value comparisons are numeric.
	//
	// String value comparisons for greater than, equals, or less than are based
	// on ASCII character code values. For example, a is greater than A, and a is
	// greater than B. For a list of code values, see http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
	// (http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters).
	//
	// For Binary, DynamoDB treats each byte of the binary data as unsigned when
	// it compares binary values.
	AttributeValueList []*AttributeValue `type:"list"`

	// A comparator for evaluating attributes. For example, equals, greater than,
	// less than, etc.
	//
	// The following comparison operators are available:
	//
	// EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS
	// | BEGINS_WITH | IN | BETWEEN
	//
	// The following are descriptions of each comparison operator.
	//
	//   EQ : Equal. EQ is supported for all datatypes, including lists and maps.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, Binary, String Set, Number Set, or Binary Set. If an item contains
	// an AttributeValue element of a different type than the one provided in the
	// request, the value does not match. For example, {"S":"6"} does not equal
	// {"N":"6"}. Also, {"N":"6"} does not equal {"NS":["6", "2", "1"]}.
	//
	//    NE : Not equal. NE is supported for all datatypes, including lists and
	// maps.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// Binary, String Set, Number Set, or Binary Set. If an item contains an AttributeValue
	// of a different type than the one provided in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not equal {"NS":["6", "2", "1"]}.
	//
	//    LE : Less than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    LT : Less than.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// or Binary (not a set type). If an item contains an AttributeValue element
	// of a different type than the one provided in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GE : Greater than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GT : Greater than.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    NOT_NULL : The attribute exists. NOT_NULL is supported for all datatypes,
	// including lists and maps.
	//
	// This operator tests for the existence of an attribute, not its data type.
	// If the data type of attribute "a" is null, and you evaluate it using NOT_NULL,
	// the result is a Boolean true. This result is because the attribute "a" exists;
	// its data type is not relevant to the NOT_NULL comparison operator.
	//
	//    NULL : The attribute does not exist. NULL is supported for all datatypes,
	// including lists and maps.
	//
	// This operator tests for the nonexistence of an attribute, not its data type.
	// If the data type of attribute "a" is null, and you evaluate it using NULL,
	// the result is a Boolean false. This is because the attribute "a" exists;
	// its data type is not relevant to the NULL comparison operator.
	//
	//    CONTAINS : Checks for a subsequence, or value in a set.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If the target attribute of the comparison
	// is of type String, then the operator checks for a substring match. If the
	// target attribute of the comparison is of type Binary, then the operator looks
	// for a subsequence of the target that matches the input. If the target attribute
	// of the comparison is a set ("SS", "NS", or "BS"), then the operator evaluates
	// to true if it finds an exact match with any member of the set.
	//
	// CONTAINS is supported for lists: When evaluating "a CONTAINS b", "a" can
	// be a list; however, "b" cannot be a set, a map, or a list.
	//
	//   NOT_CONTAINS : Checks for absence of a subsequence, or absence of a value
	// in a set.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If the target attribute of the comparison
	// is a String, then the operator checks for the absence of a substring match.
	// If the target attribute of the comparison is Binary, then the operator checks
	// for the absence of a subsequence of the target that matches the input. If
	// the target attribute of the comparison is a set ("SS", "NS", or "BS"), then
	// the operator evaluates to true if it does not find an exact match with any
	// member of the set.
	//
	// NOT_CONTAINS is supported for lists: When evaluating "a NOT CONTAINS b",
	// "a" can be a list; however, "b" cannot be a set, a map, or a list.
	//
	//   BEGINS_WITH : Checks for a prefix.
	//
	// AttributeValueList can contain only one AttributeValue of type String or
	// Binary (not a Number or a set type). The target attribute of the comparison
	// must be of type String or Binary (not a Number or a set type).
	//
	//    IN : Checks for matching elements within two sets.
	//
	// AttributeValueList can contain one or more AttributeValue elements of type
	// String, Number, or Binary (not a set type). These attributes are compared
	// against an existing set type attribute of an item. If any elements of the
	// input set are present in the item attribute, the expression evaluates to
	// true.
	//
	//   BETWEEN : Greater than or equal to the first value, and less than or equal
	// to the second value.
	//
	// AttributeValueList must contain two AttributeValue elements of the same
	// type, either String, Number, or Binary (not a set type). A target attribute
	// matches if the target value is greater than, or equal to, the first element
	// and less than, or equal to, the second element. If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not compare to {"N":"6"}. Also,
	// {"N":"6"} does not compare to {"NS":["6", "2", "1"]}
	//
	//   For usage examples of AttributeValueList and ComparisonOperator, see Legacy
	// Conditional Parameters (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html)
	// in the Amazon DynamoDB Developer Guide.
	ComparisonOperator *string `type:"string" required:"true"`

	metadataCondition `json:"-" xml:"-"`
}

type metadataCondition struct {
	SDKShapeTraits bool `type:"structure"`
}

// The capacity units consumed by an operation. The data returned includes the
// total provisioned throughput consumed, along with statistics for the table
// and any indexes involved in the operation. ConsumedCapacity is only returned
// if the request asked for it. For more information, see Provisioned Throughput
// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
// in the Amazon DynamoDB Developer Guide.
type ConsumedCapacity struct {
	// The total number of capacity units consumed by the operation.
	CapacityUnits *float64 `type:"double"`

	// The amount of throughput consumed on each global index affected by the operation.
	GlobalSecondaryIndexes map[string]*Capacity `type:"map"`

	// The amount of throughput consumed on each local index affected by the operation.
	LocalSecondaryIndexes map[string]*Capacity `type:"map"`

	// The amount of throughput consumed on the table affected by the operation.
	Table *Capacity `type:"structure"`

	// The name of the table that was affected by the operation.
	TableName *string `type:"string"`

	metadataConsumedCapacity `json:"-" xml:"-"`
}

type metadataConsumedCapacity struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents a new global secondary index to be added to an existing table.
type CreateGlobalSecondaryIndexAction struct {
	// The name of the global secondary index to be created.
	IndexName *string `type:"string" required:"true"`

	// The key schema for the global secondary index.
	KeySchema []*KeySchemaElement `type:"list" required:"true"`

	// Represents attributes that are copied (projected) from the table into an
	// index. These are in addition to the primary key attributes and index key
	// attributes, which are automatically projected.
	Projection *Projection `type:"structure" required:"true"`

	// Represents the provisioned throughput settings for a specified table or index.
	// The settings can be modified using the UpdateTable operation.
	//
	// For current minimum and maximum provisioned throughput values, see Limits
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	ProvisionedThroughput *ProvisionedThroughput `type:"structure" required:"true"`

	metadataCreateGlobalSecondaryIndexAction `json:"-" xml:"-"`
}

type metadataCreateGlobalSecondaryIndexAction struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of a CreateTable operation.
type CreateTableInput struct {
	// An array of attributes that describe the key schema for the table and indexes.
	AttributeDefinitions []*AttributeDefinition `type:"list" required:"true"`

	// One or more global secondary indexes (the maximum is five) to be created
	// on the table. Each global secondary index in the array includes the following:
	//
	//   IndexName - The name of the global secondary index. Must be unique only
	// for this table.
	//
	//    KeySchema - Specifies the key schema for the global secondary index.
	//
	//   Projection - Specifies attributes that are copied (projected) from the
	// table into the index. These are in addition to the primary key attributes
	// and index key attributes, which are automatically projected. Each attribute
	// specification is composed of:
	//
	//   ProjectionType - One of the following:
	//
	//   KEYS_ONLY - Only the index and primary keys are projected into the index.
	//
	//   INCLUDE - Only the specified table attributes are projected into the index.
	// The list of projected attributes are in NonKeyAttributes.
	//
	//   ALL - All of the table attributes are projected into the index.
	//
	//     NonKeyAttributes - A list of one or more non-key attribute names that
	// are projected into the secondary index. The total count of attributes provided
	// in NonKeyAttributes, summed across all of the secondary indexes, must not
	// exceed 20. If you project the same attribute into two different indexes,
	// this counts as two distinct attributes when determining the total.
	//
	//     ProvisionedThroughput - The provisioned throughput settings for the
	// global secondary index, consisting of read and write capacity units.
	GlobalSecondaryIndexes []*GlobalSecondaryIndex `type:"list"`

	// Specifies the attributes that make up the primary key for a table or an index.
	// The attributes in KeySchema must also be defined in the AttributeDefinitions
	// array. For more information, see Data Model (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// Each KeySchemaElement in the array is composed of:
	//
	//   AttributeName - The name of this key attribute.
	//
	//   KeyType - Determines whether the key attribute is HASH or RANGE.
	//
	//   For a primary key that consists of a hash attribute, you must provide
	// exactly one element with a KeyType of HASH.
	//
	// For a primary key that consists of hash and range attributes, you must provide
	// exactly two elements, in this order: The first element must have a KeyType
	// of HASH, and the second element must have a KeyType of RANGE.
	//
	// For more information, see Specifying the Primary Key (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#WorkingWithTables.primary.key)
	// in the Amazon DynamoDB Developer Guide.
	KeySchema []*KeySchemaElement `type:"list" required:"true"`

	// One or more local secondary indexes (the maximum is five) to be created on
	// the table. Each index is scoped to a given hash key value. There is a 10
	// GB size limit per hash key; otherwise, the size of a local secondary index
	// is unconstrained.
	//
	// Each local secondary index in the array includes the following:
	//
	//   IndexName - The name of the local secondary index. Must be unique only
	// for this table.
	//
	//    KeySchema - Specifies the key schema for the local secondary index. The
	// key schema must begin with the same hash key attribute as the table.
	//
	//   Projection - Specifies attributes that are copied (projected) from the
	// table into the index. These are in addition to the primary key attributes
	// and index key attributes, which are automatically projected. Each attribute
	// specification is composed of:
	//
	//   ProjectionType - One of the following:
	//
	//   KEYS_ONLY - Only the index and primary keys are projected into the index.
	//
	//   INCLUDE - Only the specified table attributes are projected into the index.
	// The list of projected attributes are in NonKeyAttributes.
	//
	//   ALL - All of the table attributes are projected into the index.
	//
	//     NonKeyAttributes - A list of one or more non-key attribute names that
	// are projected into the secondary index. The total count of attributes provided
	// in NonKeyAttributes, summed across all of the secondary indexes, must not
	// exceed 20. If you project the same attribute into two different indexes,
	// this counts as two distinct attributes when determining the total.
	LocalSecondaryIndexes []*LocalSecondaryIndex `type:"list"`

	// Represents the provisioned throughput settings for a specified table or index.
	// The settings can be modified using the UpdateTable operation.
	//
	// For current minimum and maximum provisioned throughput values, see Limits
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	ProvisionedThroughput *ProvisionedThroughput `type:"structure" required:"true"`

	// The name of the table to create.
	TableName *string `type:"string" required:"true"`

	metadataCreateTableInput `json:"-" xml:"-"`
}

type metadataCreateTableInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of a CreateTable operation.
type CreateTableOutput struct {
	// Represents the properties of a table.
	TableDescription *TableDescription `type:"structure"`

	metadataCreateTableOutput `json:"-" xml:"-"`
}

type metadataCreateTableOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents a global secondary index to be deleted from an existing table.
type DeleteGlobalSecondaryIndexAction struct {
	// The name of the global secondary index to be deleted.
	IndexName *string `type:"string" required:"true"`

	metadataDeleteGlobalSecondaryIndexAction `json:"-" xml:"-"`
}

type metadataDeleteGlobalSecondaryIndexAction struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of a DeleteItem operation.
type DeleteItemInput struct {
	// A condition that must be satisfied in order for a conditional DeleteItem
	// to succeed.
	//
	// An expression can contain any of the following:
	//
	//   Boolean functions: attribute_exists | attribute_not_exists | contains
	// | begins_with
	//
	// These function names are case-sensitive.
	//
	//   Comparison operators:  = | <> | < | > | <= | >= | BETWEEN | IN
	//
	//    Logical operators: AND | OR | NOT
	//
	//   For more information on condition expressions, see Specifying Conditions
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// ConditionExpression replaces the legacy ConditionalOperator and Expected
	// parameters.
	ConditionExpression *string `type:"string"`

	// This is a legacy parameter, for backward compatibility. New applications
	// should use ConditionExpression instead. Do not combine legacy parameters
	// and expression parameters in a single API call; otherwise, DynamoDB will
	// return a ValidationException exception.
	//
	//  A logical operator to apply to the conditions in the Expected map:
	//
	//  AND - If all of the conditions evaluate to true, then the entire map evaluates
	// to true.
	//
	// OR - If at least one of the conditions evaluate to true, then the entire
	// map evaluates to true.
	//
	//  If you omit ConditionalOperator, then AND is the default.
	//
	// The operation will succeed only if the entire map evaluates to true.
	//
	// This parameter does not support attributes of type List or Map.
	ConditionalOperator *string `type:"string"`

	// This is a legacy parameter, for backward compatibility. New applications
	// should use ConditionExpression instead. Do not combine legacy parameters
	// and expression parameters in a single API call; otherwise, DynamoDB will
	// return a ValidationException exception.
	//
	//  A map of attribute/condition pairs. Expected provides a conditional block
	// for the DeleteItem operation.
	//
	// Each element of Expected consists of an attribute name, a comparison operator,
	// and one or more values. DynamoDB compares the attribute with the value(s)
	// you supplied, using the comparison operator. For each Expected element, the
	// result of the evaluation is either true or false.
	//
	// If you specify more than one element in the Expected map, then by default
	// all of the conditions must evaluate to true. In other words, the conditions
	// are ANDed together. (You can use the ConditionalOperator parameter to OR
	// the conditions instead. If you do this, then at least one of the conditions
	// must evaluate to true, rather than all of them.)
	//
	// If the Expected map evaluates to true, then the conditional operation succeeds;
	// otherwise, it fails.
	//
	// Expected contains the following:
	//
	//   AttributeValueList - One or more values to evaluate against the supplied
	// attribute. The number of values in the list depends on the ComparisonOperator
	// being used.
	//
	// For type Number, value comparisons are numeric.
	//
	// String value comparisons for greater than, equals, or less than are based
	// on ASCII character code values. For example, a is greater than A, and a is
	// greater than B. For a list of code values, see http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters.
	//
	// For type Binary, DynamoDB treats each byte of the binary data as unsigned
	// when it compares binary values.
	//
	//   ComparisonOperator - A comparator for evaluating attributes in the AttributeValueList.
	// When performing the comparison, DynamoDB uses strongly consistent reads.
	//
	// The following comparison operators are available:
	//
	// EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS
	// | BEGINS_WITH | IN | BETWEEN
	//
	// The following are descriptions of each comparison operator.
	//
	//   EQ : Equal. EQ is supported for all datatypes, including lists and maps.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, Binary, String Set, Number Set, or Binary Set. If an item contains
	// an AttributeValue element of a different type than the one provided in the
	// request, the value does not match. For example, {"S":"6"} does not equal
	// {"N":"6"}. Also, {"N":"6"} does not equal {"NS":["6", "2", "1"]}.
	//
	//    NE : Not equal. NE is supported for all datatypes, including lists and
	// maps.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// Binary, String Set, Number Set, or Binary Set. If an item contains an AttributeValue
	// of a different type than the one provided in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not equal {"NS":["6", "2", "1"]}.
	//
	//    LE : Less than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    LT : Less than.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// or Binary (not a set type). If an item contains an AttributeValue element
	// of a different type than the one provided in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GE : Greater than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GT : Greater than.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    NOT_NULL : The attribute exists. NOT_NULL is supported for all datatypes,
	// including lists and maps.
	//
	// This operator tests for the existence of an attribute, not its data type.
	// If the data type of attribute "a" is null, and you evaluate it using NOT_NULL,
	// the result is a Boolean true. This result is because the attribute "a" exists;
	// its data type is not relevant to the NOT_NULL comparison operator.
	//
	//    NULL : The attribute does not exist. NULL is supported for all datatypes,
	// including lists and maps.
	//
	// This operator tests for the nonexistence of an attribute, not its data type.
	// If the data type of attribute "a" is null, and you evaluate it using NULL,
	// the result is a Boolean false. This is because the attribute "a" exists;
	// its data type is not relevant to the NULL comparison operator.
	//
	//    CONTAINS : Checks for a subsequence, or value in a set.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If the target attribute of the comparison
	// is of type String, then the operator checks for a substring match. If the
	// target attribute of the comparison is of type Binary, then the operator looks
	// for a subsequence of the target that matches the input. If the target attribute
	// of the comparison is a set ("SS", "NS", or "BS"), then the operator evaluates
	// to true if it finds an exact match with any member of the set.
	//
	// CONTAINS is supported for lists: When evaluating "a CONTAINS b", "a" can
	// be a list; however, "b" cannot be a set, a map, or a list.
	//
	//   NOT_CONTAINS : Checks for absence of a subsequence, or absence of a value
	// in a set.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If the target attribute of the comparison
	// is a String, then the operator checks for the absence of a substring match.
	// If the target attribute of the comparison is Binary, then the operator checks
	// for the absence of a subsequence of the target that matches the input. If
	// the target attribute of the comparison is a set ("SS", "NS", or "BS"), then
	// the operator evaluates to true if it does not find an exact match with any
	// member of the set.
	//
	// NOT_CONTAINS is supported for lists: When evaluating "a NOT CONTAINS b",
	// "a" can be a list; however, "b" cannot be a set, a map, or a list.
	//
	//   BEGINS_WITH : Checks for a prefix.
	//
	// AttributeValueList can contain only one AttributeValue of type String or
	// Binary (not a Number or a set type). The target attribute of the comparison
	// must be of type String or Binary (not a Number or a set type).
	//
	//    IN : Checks for matching elements within two sets.
	//
	// AttributeValueList can contain one or more AttributeValue elements of type
	// String, Number, or Binary (not a set type). These attributes are compared
	// against an existing set type attribute of an item. If any elements of the
	// input set are present in the item attribute, the expression evaluates to
	// true.
	//
	//   BETWEEN : Greater than or equal to the first value, and less than or equal
	// to the second value.
	//
	// AttributeValueList must contain two AttributeValue elements of the same
	// type, either String, Number, or Binary (not a set type). A target attribute
	// matches if the target value is greater than, or equal to, the first element
	// and less than, or equal to, the second element. If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not compare to {"N":"6"}. Also,
	// {"N":"6"} does not compare to {"NS":["6", "2", "1"]}
	//
	//     For usage examples of AttributeValueList and ComparisonOperator, see
	// Legacy Conditional Parameters (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// For backward compatibility with previous DynamoDB releases, the following
	// parameters can be used instead of AttributeValueList and ComparisonOperator:
	//
	//   Value - A value for DynamoDB to compare with an attribute.
	//
	//   Exists - A Boolean value that causes DynamoDB to evaluate the value before
	// attempting the conditional operation:
	//
	//   If Exists is true, DynamoDB will check to see if that attribute value
	// already exists in the table. If it is found, then the condition evaluates
	// to true; otherwise the condition evaluate to false.
	//
	//  If Exists is false, DynamoDB assumes that the attribute value does not
	// exist in the table. If in fact the value does not exist, then the assumption
	// is valid and the condition evaluates to true. If the value is found, despite
	// the assumption that it does not exist, the condition evaluates to false.
	//
	//  Note that the default value for Exists is true.
	//
	//   The Value and Exists parameters are incompatible with AttributeValueList
	// and ComparisonOperator. Note that if you use both sets of parameters at once,
	// DynamoDB will return a ValidationException exception.
	//
	// This parameter does not support attributes of type List or Map.
	Expected map[string]*ExpectedAttributeValue `type:"map"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//   To access an attribute whose name conflicts with a DynamoDB reserved word.
	//
	//   To create a placeholder for repeating occurrences of an attribute name
	// in an expression.
	//
	//   To prevent special characters in an attribute name from being misinterpreted
	// in an expression.
	//
	//   Use the # character in an expression to dereference an attribute name.
	// For example, consider the following attribute name:
	//
	// Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot
	// be used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	// {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	// #P = :val
	//
	// Tokens that begin with the : character are expression attribute values,
	// which are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]*string `type:"map"`

	// One or more values that can be substituted in an expression.
	//
	// Use the : (colon) character in an expression to dereference an attribute
	// value. For example, suppose that you wanted to check whether the value of
	// the ProductStatus attribute was one of the following:
	//
	// Available | Backordered | Discontinued
	//
	// You would first need to specify ExpressionAttributeValues as follows:
	//
	// { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"}
	// }
	//
	// You could then use these values in an expression, such as this:
	//
	// ProductStatus IN (:avail, :back, :disc)
	//
	// For more information on expression attribute values, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeValues map[string]*AttributeValue `type:"map"`

	// A map of attribute names to AttributeValue objects, representing the primary
	// key of the item to delete.
	//
	// For the primary key, you must provide all of the attributes. For example,
	// with a hash type primary key, you only need to provide the hash attribute.
	// For a hash-and-range type primary key, you must provide both the hash attribute
	// and the range attribute.
	Key map[string]*AttributeValue `type:"map" required:"true"`

	// A value that if set to TOTAL, the response includes ConsumedCapacity data
	// for tables and indexes. If set to INDEXES, the response includes ConsumedCapacity
	// for indexes. If set to NONE (the default), ConsumedCapacity is not included
	// in the response.
	ReturnConsumedCapacity *string `type:"string"`

	// A value that if set to SIZE, the response includes statistics about item
	// collections, if any, that were modified during the operation are returned
	// in the response. If set to NONE (the default), no statistics are returned.
	ReturnItemCollectionMetrics *string `type:"string"`

	// Use ReturnValues if you want to get the item attributes as they appeared
	// before they were deleted. For DeleteItem, the valid values are:
	//
	//   NONE - If ReturnValues is not specified, or if its value is NONE, then
	// nothing is returned. (This setting is the default for ReturnValues.)
	//
	//   ALL_OLD - The content of the old item is returned.
	ReturnValues *string `type:"string"`

	// The name of the table from which to delete the item.
	TableName *string `type:"string" required:"true"`

	metadataDeleteItemInput `json:"-" xml:"-"`
}

type metadataDeleteItemInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of a DeleteItem operation.
type DeleteItemOutput struct {
	// A map of attribute names to AttributeValue objects, representing the item
	// as it appeared before the DeleteItem operation. This map appears in the response
	// only if ReturnValues was specified as ALL_OLD in the request.
	Attributes map[string]*AttributeValue `type:"map"`

	// The capacity units consumed by an operation. The data returned includes the
	// total provisioned throughput consumed, along with statistics for the table
	// and any indexes involved in the operation. ConsumedCapacity is only returned
	// if the request asked for it. For more information, see Provisioned Throughput
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// Information about item collections, if any, that were affected by the operation.
	// ItemCollectionMetrics is only returned if the request asked for it. If the
	// table does not have any local secondary indexes, this information is not
	// returned in the response.
	//
	// Each ItemCollectionMetrics element consists of:
	//
	//  ItemCollectionKey - The hash key value of the item collection. This is
	// the same as the hash key of the item.
	//
	// SizeEstimateRange - An estimate of item collection size, in gigabytes. This
	// value is a two-element array containing a lower bound and an upper bound
	// for the estimate. The estimate includes the size of all the items in the
	// table, plus the size of all attributes projected into all of the local secondary
	// indexes on that table. Use this estimate to measure whether a local secondary
	// index is approaching its size limit.
	//
	// The estimate is subject to change over time; therefore, do not rely on the
	// precision or accuracy of the estimate.
	ItemCollectionMetrics *ItemCollectionMetrics `type:"structure"`

	metadataDeleteItemOutput `json:"-" xml:"-"`
}

type metadataDeleteItemOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents a request to perform a DeleteItem operation on an item.
type DeleteRequest struct {
	// A map of attribute name to attribute values, representing the primary key
	// of the item to delete. All of the table's primary key attributes must be
	// specified, and their data types must match those of the table's key schema.
	Key map[string]*AttributeValue `type:"map" required:"true"`

	metadataDeleteRequest `json:"-" xml:"-"`
}

type metadataDeleteRequest struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of a DeleteTable operation.
type DeleteTableInput struct {
	// The name of the table to delete.
	TableName *string `type:"string" required:"true"`

	metadataDeleteTableInput `json:"-" xml:"-"`
}

type metadataDeleteTableInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of a DeleteTable operation.
type DeleteTableOutput struct {
	// Represents the properties of a table.
	TableDescription *TableDescription `type:"structure"`

	metadataDeleteTableOutput `json:"-" xml:"-"`
}

type metadataDeleteTableOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of a DescribeTable operation.
type DescribeTableInput struct {
	// The name of the table to describe.
	TableName *string `type:"string" required:"true"`

	metadataDescribeTableInput `json:"-" xml:"-"`
}

type metadataDescribeTableInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of a DescribeTable operation.
type DescribeTableOutput struct {
	// Represents the properties of a table.
	Table *TableDescription `type:"structure"`

	metadataDescribeTableOutput `json:"-" xml:"-"`
}

type metadataDescribeTableOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents a condition to be compared with an attribute value. This condition
// can be used with DeleteItem, PutItem or UpdateItem operations; if the comparison
// evaluates to true, the operation succeeds; if not, the operation fails. You
// can use ExpectedAttributeValue in one of two different ways:
//
//   Use AttributeValueList to specify one or more values to compare against
// an attribute. Use ComparisonOperator to specify how you want to perform the
// comparison. If the comparison evaluates to true, then the conditional operation
// succeeds.
//
//   Use Value to specify a value that DynamoDB will compare against an attribute.
// If the values match, then ExpectedAttributeValue evaluates to true and the
// conditional operation succeeds. Optionally, you can also set Exists to false,
// indicating that you do not expect to find the attribute value in the table.
// In this case, the conditional operation succeeds only if the comparison evaluates
// to false.
//
//   Value and Exists are incompatible with AttributeValueList and ComparisonOperator.
// Note that if you use both sets of parameters at once, DynamoDB will return
// a ValidationException exception.
type ExpectedAttributeValue struct {
	// One or more values to evaluate against the supplied attribute. The number
	// of values in the list depends on the ComparisonOperator being used.
	//
	// For type Number, value comparisons are numeric.
	//
	// String value comparisons for greater than, equals, or less than are based
	// on ASCII character code values. For example, a is greater than A, and a is
	// greater than B. For a list of code values, see http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
	// (http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters).
	//
	// For Binary, DynamoDB treats each byte of the binary data as unsigned when
	// it compares binary values.
	//
	// For information on specifying data types in JSON, see JSON Data Format (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataFormat.html)
	// in the Amazon DynamoDB Developer Guide.
	AttributeValueList []*AttributeValue `type:"list"`

	// A comparator for evaluating attributes in the AttributeValueList. For example,
	// equals, greater than, less than, etc.
	//
	// The following comparison operators are available:
	//
	// EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS
	// | BEGINS_WITH | IN | BETWEEN
	//
	// The following are descriptions of each comparison operator.
	//
	//   EQ : Equal. EQ is supported for all datatypes, including lists and maps.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, Binary, String Set, Number Set, or Binary Set. If an item contains
	// an AttributeValue element of a different type than the one provided in the
	// request, the value does not match. For example, {"S":"6"} does not equal
	// {"N":"6"}. Also, {"N":"6"} does not equal {"NS":["6", "2", "1"]}.
	//
	//    NE : Not equal. NE is supported for all datatypes, including lists and
	// maps.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// Binary, String Set, Number Set, or Binary Set. If an item contains an AttributeValue
	// of a different type than the one provided in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not equal {"NS":["6", "2", "1"]}.
	//
	//    LE : Less than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    LT : Less than.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// or Binary (not a set type). If an item contains an AttributeValue element
	// of a different type than the one provided in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GE : Greater than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GT : Greater than.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    NOT_NULL : The attribute exists. NOT_NULL is supported for all datatypes,
	// including lists and maps.
	//
	// This operator tests for the existence of an attribute, not its data type.
	// If the data type of attribute "a" is null, and you evaluate it using NOT_NULL,
	// the result is a Boolean true. This result is because the attribute "a" exists;
	// its data type is not relevant to the NOT_NULL comparison operator.
	//
	//    NULL : The attribute does not exist. NULL is supported for all datatypes,
	// including lists and maps.
	//
	// This operator tests for the nonexistence of an attribute, not its data type.
	// If the data type of attribute "a" is null, and you evaluate it using NULL,
	// the result is a Boolean false. This is because the attribute "a" exists;
	// its data type is not relevant to the NULL comparison operator.
	//
	//    CONTAINS : Checks for a subsequence, or value in a set.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If the target attribute of the comparison
	// is of type String, then the operator checks for a substring match. If the
	// target attribute of the comparison is of type Binary, then the operator looks
	// for a subsequence of the target that matches the input. If the target attribute
	// of the comparison is a set ("SS", "NS", or "BS"), then the operator evaluates
	// to true if it finds an exact match with any member of the set.
	//
	// CONTAINS is supported for lists: When evaluating "a CONTAINS b", "a" can
	// be a list; however, "b" cannot be a set, a map, or a list.
	//
	//   NOT_CONTAINS : Checks for absence of a subsequence, or absence of a value
	// in a set.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If the target attribute of the comparison
	// is a String, then the operator checks for the absence of a substring match.
	// If the target attribute of the comparison is Binary, then the operator checks
	// for the absence of a subsequence of the target that matches the input. If
	// the target attribute of the comparison is a set ("SS", "NS", or "BS"), then
	// the operator evaluates to true if it does not find an exact match with any
	// member of the set.
	//
	// NOT_CONTAINS is supported for lists: When evaluating "a NOT CONTAINS b",
	// "a" can be a list; however, "b" cannot be a set, a map, or a list.
	//
	//   BEGINS_WITH : Checks for a prefix.
	//
	// AttributeValueList can contain only one AttributeValue of type String or
	// Binary (not a Number or a set type). The target attribute of the comparison
	// must be of type String or Binary (not a Number or a set type).
	//
	//    IN : Checks for matching elements within two sets.
	//
	// AttributeValueList can contain one or more AttributeValue elements of type
	// String, Number, or Binary (not a set type). These attributes are compared
	// against an existing set type attribute of an item. If any elements of the
	// input set are present in the item attribute, the expression evaluates to
	// true.
	//
	//   BETWEEN : Greater than or equal to the first value, and less than or equal
	// to the second value.
	//
	// AttributeValueList must contain two AttributeValue elements of the same
	// type, either String, Number, or Binary (not a set type). A target attribute
	// matches if the target value is greater than, or equal to, the first element
	// and less than, or equal to, the second element. If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not compare to {"N":"6"}. Also,
	// {"N":"6"} does not compare to {"NS":["6", "2", "1"]}
	ComparisonOperator *string `type:"string"`

	// Causes DynamoDB to evaluate the value before attempting a conditional operation:
	//
	//   If Exists is true, DynamoDB will check to see if that attribute value
	// already exists in the table. If it is found, then the operation succeeds.
	// If it is not found, the operation fails with a ConditionalCheckFailedException.
	//
	//   If Exists is false, DynamoDB assumes that the attribute value does not
	// exist in the table. If in fact the value does not exist, then the assumption
	// is valid and the operation succeeds. If the value is found, despite the assumption
	// that it does not exist, the operation fails with a ConditionalCheckFailedException.
	//
	//   The default setting for Exists is true. If you supply a Value all by itself,
	// DynamoDB assumes the attribute exists: You don't have to set Exists to true,
	// because it is implied.
	//
	// DynamoDB returns a ValidationException if:
	//
	//   Exists is true but there is no Value to check. (You expect a value to
	// exist, but don't specify what that value is.)
	//
	//   Exists is false but you also provide a Value. (You cannot expect an attribute
	// to have a value, while also expecting it not to exist.)
	Exists *bool `type:"boolean"`

	// Represents the data for an attribute. You can set one, and only one, of the
	// elements.
	//
	// Each attribute in an item is a name-value pair. An attribute can be single-valued
	// or multi-valued set. For example, a book item can have title and authors
	// attributes. Each book has one title but can have many authors. The multi-valued
	// attribute is a set; duplicate values are not allowed.
	Value *AttributeValue `type:"structure"`

	metadataExpectedAttributeValue `json:"-" xml:"-"`
}

type metadataExpectedAttributeValue struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of a GetItem operation.
type GetItemInput struct {
	// This is a legacy parameter, for backward compatibility. New applications
	// should use ProjectionExpression instead. Do not combine legacy parameters
	// and expression parameters in a single API call; otherwise, DynamoDB will
	// return a ValidationException exception.
	//
	// This parameter allows you to retrieve attributes of type List or Map; however,
	// it cannot retrieve individual elements within a List or a Map.
	//
	// The names of one or more attributes to retrieve. If no attribute names are
	// provided, then all attributes will be returned. If any of the requested attributes
	// are not found, they will not appear in the result.
	//
	// Note that AttributesToGet has no effect on provisioned throughput consumption.
	// DynamoDB determines capacity units consumed based on item size, not on the
	// amount of data that is returned to an application.
	AttributesToGet []*string `type:"list"`

	// A value that if set to true, then the operation uses strongly consistent
	// reads; otherwise, eventually consistent reads are used.
	ConsistentRead *bool `type:"boolean"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//   To access an attribute whose name conflicts with a DynamoDB reserved word.
	//
	//   To create a placeholder for repeating occurrences of an attribute name
	// in an expression.
	//
	//   To prevent special characters in an attribute name from being misinterpreted
	// in an expression.
	//
	//   Use the # character in an expression to dereference an attribute name.
	// For example, consider the following attribute name:
	//
	// Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot
	// be used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	// {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	// #P = :val
	//
	// Tokens that begin with the : character are expression attribute values,
	// which are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]*string `type:"map"`

	// A map of attribute names to AttributeValue objects, representing the primary
	// key of the item to retrieve.
	//
	// For the primary key, you must provide all of the attributes. For example,
	// with a hash type primary key, you only need to provide the hash attribute.
	// For a hash-and-range type primary key, you must provide both the hash attribute
	// and the range attribute.
	Key map[string]*AttributeValue `type:"map" required:"true"`

	// A string that identifies one or more attributes to retrieve from the table.
	// These attributes can include scalars, sets, or elements of a JSON document.
	// The attributes in the expression must be separated by commas.
	//
	// If no attribute names are specified, then all attributes will be returned.
	// If any of the requested attributes are not found, they will not appear in
	// the result.
	//
	// For more information, see Accessing Item Attributes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// ProjectionExpression replaces the legacy AttributesToGet parameter.
	ProjectionExpression *string `type:"string"`

	// A value that if set to TOTAL, the response includes ConsumedCapacity data
	// for tables and indexes. If set to INDEXES, the response includes ConsumedCapacity
	// for indexes. If set to NONE (the default), ConsumedCapacity is not included
	// in the response.
	ReturnConsumedCapacity *string `type:"string"`

	// The name of the table containing the requested item.
	TableName *string `type:"string" required:"true"`

	metadataGetItemInput `json:"-" xml:"-"`
}

type metadataGetItemInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of a GetItem operation.
type GetItemOutput struct {
	// The capacity units consumed by an operation. The data returned includes the
	// total provisioned throughput consumed, along with statistics for the table
	// and any indexes involved in the operation. ConsumedCapacity is only returned
	// if the request asked for it. For more information, see Provisioned Throughput
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// A map of attribute names to AttributeValue objects, as specified by AttributesToGet.
	Item map[string]*AttributeValue `type:"map"`

	metadataGetItemOutput `json:"-" xml:"-"`
}

type metadataGetItemOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the properties of a global secondary index.
type GlobalSecondaryIndex struct {
	// The name of the global secondary index. The name must be unique among all
	// other indexes on this table.
	IndexName *string `type:"string" required:"true"`

	// The complete key schema for a global secondary index, which consists of one
	// or more pairs of attribute names and key types (HASH or RANGE).
	KeySchema []*KeySchemaElement `type:"list" required:"true"`

	// Represents attributes that are copied (projected) from the table into an
	// index. These are in addition to the primary key attributes and index key
	// attributes, which are automatically projected.
	Projection *Projection `type:"structure" required:"true"`

	// Represents the provisioned throughput settings for a specified table or index.
	// The settings can be modified using the UpdateTable operation.
	//
	// For current minimum and maximum provisioned throughput values, see Limits
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	ProvisionedThroughput *ProvisionedThroughput `type:"structure" required:"true"`

	metadataGlobalSecondaryIndex `json:"-" xml:"-"`
}

type metadataGlobalSecondaryIndex struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the properties of a global secondary index.
type GlobalSecondaryIndexDescription struct {
	// Indicates whether the index is currently backfilling. Backfilling is the
	// process of reading items from the table and determining whether they can
	// be added to the index. (Not all items will qualify: For example, a hash key
	// attribute cannot have any duplicates.) If an item can be added to the index,
	// DynamoDB will do so. After all items have been processed, the backfilling
	// operation is complete and Backfilling is false.
	//
	// For indexes that were created during a CreateTable operation, the Backfilling
	// attribute does not appear in the DescribeTable output.
	Backfilling *bool `type:"boolean"`

	// The name of the global secondary index.
	IndexName *string `type:"string"`

	// The total size of the specified index, in bytes. DynamoDB updates this value
	// approximately every six hours. Recent changes might not be reflected in this
	// value.
	IndexSizeBytes *int64 `type:"long"`

	// The current state of the global secondary index:
	//
	//   CREATING - The index is being created.
	//
	//   UPDATING - The index is being updated.
	//
	//   DELETING - The index is being deleted.
	//
	//   ACTIVE - The index is ready for use.
	IndexStatus *string `type:"string"`

	// The number of items in the specified index. DynamoDB updates this value approximately
	// every six hours. Recent changes might not be reflected in this value.
	ItemCount *int64 `type:"long"`

	// The complete key schema for the global secondary index, consisting of one
	// or more pairs of attribute names and key types (HASH or RANGE).
	KeySchema []*KeySchemaElement `type:"list"`

	// Represents attributes that are copied (projected) from the table into an
	// index. These are in addition to the primary key attributes and index key
	// attributes, which are automatically projected.
	Projection *Projection `type:"structure"`

	// Represents the provisioned throughput settings for the table, consisting
	// of read and write capacity units, along with data about increases and decreases.
	ProvisionedThroughput *ProvisionedThroughputDescription `type:"structure"`

	metadataGlobalSecondaryIndexDescription `json:"-" xml:"-"`
}

type metadataGlobalSecondaryIndexDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents one of the following:
//
//  A new global secondary index to be added to an existing table.
//
// New provisioned throughput parameters for an existing global secondary index.
//
// An existing global secondary index to be removed from an existing table.
type GlobalSecondaryIndexUpdate struct {
	// The parameters required for creating a global secondary index on an existing
	// table:
	//
	//  IndexName
	//
	// KeySchema
	//
	// AttributeDefinitions
	//
	// Projection
	//
	// ProvisionedThroughput
	Create *CreateGlobalSecondaryIndexAction `type:"structure"`

	// The name of an existing global secondary index to be removed.
	Delete *DeleteGlobalSecondaryIndexAction `type:"structure"`

	// The name of an existing global secondary index, along with new provisioned
	// throughput settings to be applied to that index.
	Update *UpdateGlobalSecondaryIndexAction `type:"structure"`

	metadataGlobalSecondaryIndexUpdate `json:"-" xml:"-"`
}

type metadataGlobalSecondaryIndexUpdate struct {
	SDKShapeTraits bool `type:"structure"`
}

// Information about item collections, if any, that were affected by the operation.
// ItemCollectionMetrics is only returned if the request asked for it. If the
// table does not have any local secondary indexes, this information is not
// returned in the response.
type ItemCollectionMetrics struct {
	// The hash key value of the item collection. This value is the same as the
	// hash key of the item.
	ItemCollectionKey map[string]*AttributeValue `type:"map"`

	// An estimate of item collection size, in gigabytes. This value is a two-element
	// array containing a lower bound and an upper bound for the estimate. The estimate
	// includes the size of all the items in the table, plus the size of all attributes
	// projected into all of the local secondary indexes on that table. Use this
	// estimate to measure whether a local secondary index is approaching its size
	// limit.
	//
	// The estimate is subject to change over time; therefore, do not rely on the
	// precision or accuracy of the estimate.
	SizeEstimateRangeGB []*float64 `type:"list"`

	metadataItemCollectionMetrics `json:"-" xml:"-"`
}

type metadataItemCollectionMetrics struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents a single element of a key schema. A key schema specifies the attributes
// that make up the primary key of a table, or the key attributes of an index.
//
// A KeySchemaElement represents exactly one attribute of the primary key.
// For example, a hash type primary key would be represented by one KeySchemaElement.
// A hash-and-range type primary key would require one KeySchemaElement for
// the hash attribute, and another KeySchemaElement for the range attribute.
type KeySchemaElement struct {
	// The name of a key attribute.
	AttributeName *string `type:"string" required:"true"`

	// The attribute data, consisting of the data type and the attribute value itself.
	KeyType *string `type:"string" required:"true"`

	metadataKeySchemaElement `json:"-" xml:"-"`
}

type metadataKeySchemaElement struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents a set of primary keys and, for each key, the attributes to retrieve
// from the table.
//
// For each primary key, you must provide all of the key attributes. For example,
// with a hash type primary key, you only need to provide the hash attribute.
// For a hash-and-range type primary key, you must provide both the hash attribute
// and the range attribute.
type KeysAndAttributes struct {
	// One or more attributes to retrieve from the table or index. If no attribute
	// names are specified then all attributes will be returned. If any of the specified
	// attributes are not found, they will not appear in the result.
	AttributesToGet []*string `type:"list"`

	// The consistency of a read operation. If set to true, then a strongly consistent
	// read is used; otherwise, an eventually consistent read is used.
	ConsistentRead *bool `type:"boolean"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//   To access an attribute whose name conflicts with a DynamoDB reserved word.
	//
	//   To create a placeholder for repeating occurrences of an attribute name
	// in an expression.
	//
	//   To prevent special characters in an attribute name from being misinterpreted
	// in an expression.
	//
	//   Use the # character in an expression to dereference an attribute name.
	// For example, consider the following attribute name:
	//
	// Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot
	// be used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	// {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	// #P = :val
	//
	// Tokens that begin with the : character are expression attribute values,
	// which are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]*string `type:"map"`

	// The primary key attribute values that define the items and the attributes
	// associated with the items.
	Keys []map[string]*AttributeValue `type:"list" required:"true"`

	// A string that identifies one or more attributes to retrieve from the table.
	// These attributes can include scalars, sets, or elements of a JSON document.
	// The attributes in the ProjectionExpression must be separated by commas.
	//
	// If no attribute names are specified, then all attributes will be returned.
	// If any of the requested attributes are not found, they will not appear in
	// the result.
	//
	// For more information, see Accessing Item Attributes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// ProjectionExpression replaces the legacy AttributesToGet parameter.
	ProjectionExpression *string `type:"string"`

	metadataKeysAndAttributes `json:"-" xml:"-"`
}

type metadataKeysAndAttributes struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of a ListTables operation.
type ListTablesInput struct {
	// The first table name that this operation will evaluate. Use the value that
	// was returned for LastEvaluatedTableName in a previous operation, so that
	// you can obtain the next page of results.
	ExclusiveStartTableName *string `type:"string"`

	// A maximum number of table names to return. If this parameter is not specified,
	// the limit is 100.
	Limit *int64 `type:"integer"`

	metadataListTablesInput `json:"-" xml:"-"`
}

type metadataListTablesInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of a ListTables operation.
type ListTablesOutput struct {
	// The name of the last table in the current page of results. Use this value
	// as the ExclusiveStartTableName in a new request to obtain the next page of
	// results, until all the table names are returned.
	//
	// If you do not receive a LastEvaluatedTableName value in the response, this
	// means that there are no more table names to be retrieved.
	LastEvaluatedTableName *string `type:"string"`

	// The names of the tables associated with the current account at the current
	// endpoint. The maximum size of this array is 100.
	//
	// If LastEvaluatedTableName also appears in the output, you can use this value
	// as the ExclusiveStartTableName parameter in a subsequent ListTables request
	// and obtain the next page of results.
	TableNames []*string `type:"list"`

	metadataListTablesOutput `json:"-" xml:"-"`
}

type metadataListTablesOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the properties of a local secondary index.
type LocalSecondaryIndex struct {
	// The name of the local secondary index. The name must be unique among all
	// other indexes on this table.
	IndexName *string `type:"string" required:"true"`

	// The complete key schema for the local secondary index, consisting of one
	// or more pairs of attribute names and key types (HASH or RANGE).
	KeySchema []*KeySchemaElement `type:"list" required:"true"`

	// Represents attributes that are copied (projected) from the table into an
	// index. These are in addition to the primary key attributes and index key
	// attributes, which are automatically projected.
	Projection *Projection `type:"structure" required:"true"`

	metadataLocalSecondaryIndex `json:"-" xml:"-"`
}

type metadataLocalSecondaryIndex struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the properties of a local secondary index.
type LocalSecondaryIndexDescription struct {
	// Represents the name of the local secondary index.
	IndexName *string `type:"string"`

	// The total size of the specified index, in bytes. DynamoDB updates this value
	// approximately every six hours. Recent changes might not be reflected in this
	// value.
	IndexSizeBytes *int64 `type:"long"`

	// The number of items in the specified index. DynamoDB updates this value approximately
	// every six hours. Recent changes might not be reflected in this value.
	ItemCount *int64 `type:"long"`

	// The complete index key schema, which consists of one or more pairs of attribute
	// names and key types (HASH or RANGE).
	KeySchema []*KeySchemaElement `type:"list"`

	// Represents attributes that are copied (projected) from the table into an
	// index. These are in addition to the primary key attributes and index key
	// attributes, which are automatically projected.
	Projection *Projection `type:"structure"`

	metadataLocalSecondaryIndexDescription `json:"-" xml:"-"`
}

type metadataLocalSecondaryIndexDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents attributes that are copied (projected) from the table into an
// index. These are in addition to the primary key attributes and index key
// attributes, which are automatically projected.
type Projection struct {
	// Represents the non-key attribute names which will be projected into the index.
	//
	// For local secondary indexes, the total count of NonKeyAttributes summed
	// across all of the local secondary indexes, must not exceed 20. If you project
	// the same attribute into two different indexes, this counts as two distinct
	// attributes when determining the total.
	NonKeyAttributes []*string `type:"list"`

	// The set of attributes that are projected into the index:
	//
	//   KEYS_ONLY - Only the index and primary keys are projected into the index.
	//
	//   INCLUDE - Only the specified table attributes are projected into the index.
	// The list of projected attributes are in NonKeyAttributes.
	//
	//   ALL - All of the table attributes are projected into the index.
	ProjectionType *string `type:"string"`

	metadataProjection `json:"-" xml:"-"`
}

type metadataProjection struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the provisioned throughput settings for a specified table or index.
// The settings can be modified using the UpdateTable operation.
//
// For current minimum and maximum provisioned throughput values, see Limits
// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
// in the Amazon DynamoDB Developer Guide.
type ProvisionedThroughput struct {
	// The maximum number of strongly consistent reads consumed per second before
	// DynamoDB returns a ThrottlingException. For more information, see Specifying
	// Read and Write Requirements (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput)
	// in the Amazon DynamoDB Developer Guide.
	ReadCapacityUnits *int64 `type:"long" required:"true"`

	// The maximum number of writes consumed per second before DynamoDB returns
	// a ThrottlingException. For more information, see Specifying Read and Write
	// Requirements (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/WorkingWithTables.html#ProvisionedThroughput)
	// in the Amazon DynamoDB Developer Guide.
	WriteCapacityUnits *int64 `type:"long" required:"true"`

	metadataProvisionedThroughput `json:"-" xml:"-"`
}

type metadataProvisionedThroughput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the provisioned throughput settings for the table, consisting
// of read and write capacity units, along with data about increases and decreases.
type ProvisionedThroughputDescription struct {
	// The date and time of the last provisioned throughput decrease for this table.
	LastDecreaseDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The date and time of the last provisioned throughput increase for this table.
	LastIncreaseDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The number of provisioned throughput decreases for this table during this
	// UTC calendar day. For current maximums on provisioned throughput decreases,
	// see Limits (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	NumberOfDecreasesToday *int64 `type:"long"`

	// The maximum number of strongly consistent reads consumed per second before
	// DynamoDB returns a ThrottlingException. Eventually consistent reads require
	// less effort than strongly consistent reads, so a setting of 50 ReadCapacityUnits
	// per second provides 100 eventually consistent ReadCapacityUnits per second.
	ReadCapacityUnits *int64 `type:"long"`

	// The maximum number of writes consumed per second before DynamoDB returns
	// a ThrottlingException.
	WriteCapacityUnits *int64 `type:"long"`

	metadataProvisionedThroughputDescription `json:"-" xml:"-"`
}

type metadataProvisionedThroughputDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of a PutItem operation.
type PutItemInput struct {
	// A condition that must be satisfied in order for a conditional PutItem operation
	// to succeed.
	//
	// An expression can contain any of the following:
	//
	//   Boolean functions: attribute_exists | attribute_not_exists | contains
	// | begins_with
	//
	// These function names are case-sensitive.
	//
	//   Comparison operators:  = | <> | < | > | <= | >= | BETWEEN | IN
	//
	//    Logical operators: AND | OR | NOT
	//
	//   For more information on condition expressions, see Specifying Conditions
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	//  ConditionExpression replaces the legacy ConditionalOperator and Expected
	// parameters.
	ConditionExpression *string `type:"string"`

	// This is a legacy parameter, for backward compatibility. New applications
	// should use ConditionExpression instead. Do not combine legacy parameters
	// and expression parameters in a single API call; otherwise, DynamoDB will
	// return a ValidationException exception.
	//
	//  A logical operator to apply to the conditions in the Expected map:
	//
	//  AND - If all of the conditions evaluate to true, then the entire map evaluates
	// to true.
	//
	// OR - If at least one of the conditions evaluate to true, then the entire
	// map evaluates to true.
	//
	//  If you omit ConditionalOperator, then AND is the default.
	//
	// The operation will succeed only if the entire map evaluates to true.
	//
	// This parameter does not support attributes of type List or Map.
	ConditionalOperator *string `type:"string"`

	// This is a legacy parameter, for backward compatibility. New applications
	// should use ConditionExpression instead. Do not combine legacy parameters
	// and expression parameters in a single API call; otherwise, DynamoDB will
	// return a ValidationException exception.
	//
	//  A map of attribute/condition pairs. Expected provides a conditional block
	// for the PutItem operation.
	//
	// This parameter does not support attributes of type List or Map.
	//
	// Each element of Expected consists of an attribute name, a comparison operator,
	// and one or more values. DynamoDB compares the attribute with the value(s)
	// you supplied, using the comparison operator. For each Expected element, the
	// result of the evaluation is either true or false.
	//
	// If you specify more than one element in the Expected map, then by default
	// all of the conditions must evaluate to true. In other words, the conditions
	// are ANDed together. (You can use the ConditionalOperator parameter to OR
	// the conditions instead. If you do this, then at least one of the conditions
	// must evaluate to true, rather than all of them.)
	//
	// If the Expected map evaluates to true, then the conditional operation succeeds;
	// otherwise, it fails.
	//
	// Expected contains the following:
	//
	//   AttributeValueList - One or more values to evaluate against the supplied
	// attribute. The number of values in the list depends on the ComparisonOperator
	// being used.
	//
	// For type Number, value comparisons are numeric.
	//
	// String value comparisons for greater than, equals, or less than are based
	// on ASCII character code values. For example, a is greater than A, and a is
	// greater than B. For a list of code values, see http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters.
	//
	// For type Binary, DynamoDB treats each byte of the binary data as unsigned
	// when it compares binary values.
	//
	//   ComparisonOperator - A comparator for evaluating attributes in the AttributeValueList.
	// When performing the comparison, DynamoDB uses strongly consistent reads.
	//
	// The following comparison operators are available:
	//
	// EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS
	// | BEGINS_WITH | IN | BETWEEN
	//
	// The following are descriptions of each comparison operator.
	//
	//   EQ : Equal. EQ is supported for all datatypes, including lists and maps.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, Binary, String Set, Number Set, or Binary Set. If an item contains
	// an AttributeValue element of a different type than the one provided in the
	// request, the value does not match. For example, {"S":"6"} does not equal
	// {"N":"6"}. Also, {"N":"6"} does not equal {"NS":["6", "2", "1"]}.
	//
	//    NE : Not equal. NE is supported for all datatypes, including lists and
	// maps.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// Binary, String Set, Number Set, or Binary Set. If an item contains an AttributeValue
	// of a different type than the one provided in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not equal {"NS":["6", "2", "1"]}.
	//
	//    LE : Less than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    LT : Less than.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// or Binary (not a set type). If an item contains an AttributeValue element
	// of a different type than the one provided in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GE : Greater than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GT : Greater than.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    NOT_NULL : The attribute exists. NOT_NULL is supported for all datatypes,
	// including lists and maps.
	//
	// This operator tests for the existence of an attribute, not its data type.
	// If the data type of attribute "a" is null, and you evaluate it using NOT_NULL,
	// the result is a Boolean true. This result is because the attribute "a" exists;
	// its data type is not relevant to the NOT_NULL comparison operator.
	//
	//    NULL : The attribute does not exist. NULL is supported for all datatypes,
	// including lists and maps.
	//
	// This operator tests for the nonexistence of an attribute, not its data type.
	// If the data type of attribute "a" is null, and you evaluate it using NULL,
	// the result is a Boolean false. This is because the attribute "a" exists;
	// its data type is not relevant to the NULL comparison operator.
	//
	//    CONTAINS : Checks for a subsequence, or value in a set.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If the target attribute of the comparison
	// is of type String, then the operator checks for a substring match. If the
	// target attribute of the comparison is of type Binary, then the operator looks
	// for a subsequence of the target that matches the input. If the target attribute
	// of the comparison is a set ("SS", "NS", or "BS"), then the operator evaluates
	// to true if it finds an exact match with any member of the set.
	//
	// CONTAINS is supported for lists: When evaluating "a CONTAINS b", "a" can
	// be a list; however, "b" cannot be a set, a map, or a list.
	//
	//   NOT_CONTAINS : Checks for absence of a subsequence, or absence of a value
	// in a set.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If the target attribute of the comparison
	// is a String, then the operator checks for the absence of a substring match.
	// If the target attribute of the comparison is Binary, then the operator checks
	// for the absence of a subsequence of the target that matches the input. If
	// the target attribute of the comparison is a set ("SS", "NS", or "BS"), then
	// the operator evaluates to true if it does not find an exact match with any
	// member of the set.
	//
	// NOT_CONTAINS is supported for lists: When evaluating "a NOT CONTAINS b",
	// "a" can be a list; however, "b" cannot be a set, a map, or a list.
	//
	//   BEGINS_WITH : Checks for a prefix.
	//
	// AttributeValueList can contain only one AttributeValue of type String or
	// Binary (not a Number or a set type). The target attribute of the comparison
	// must be of type String or Binary (not a Number or a set type).
	//
	//    IN : Checks for matching elements within two sets.
	//
	// AttributeValueList can contain one or more AttributeValue elements of type
	// String, Number, or Binary (not a set type). These attributes are compared
	// against an existing set type attribute of an item. If any elements of the
	// input set are present in the item attribute, the expression evaluates to
	// true.
	//
	//   BETWEEN : Greater than or equal to the first value, and less than or equal
	// to the second value.
	//
	// AttributeValueList must contain two AttributeValue elements of the same
	// type, either String, Number, or Binary (not a set type). A target attribute
	// matches if the target value is greater than, or equal to, the first element
	// and less than, or equal to, the second element. If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not compare to {"N":"6"}. Also,
	// {"N":"6"} does not compare to {"NS":["6", "2", "1"]}
	//
	//     For usage examples of AttributeValueList and ComparisonOperator, see
	// Legacy Conditional Parameters (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// For backward compatibility with previous DynamoDB releases, the following
	// parameters can be used instead of AttributeValueList and ComparisonOperator:
	//
	//   Value - A value for DynamoDB to compare with an attribute.
	//
	//   Exists - A Boolean value that causes DynamoDB to evaluate the value before
	// attempting the conditional operation:
	//
	//   If Exists is true, DynamoDB will check to see if that attribute value
	// already exists in the table. If it is found, then the condition evaluates
	// to true; otherwise the condition evaluate to false.
	//
	//  If Exists is false, DynamoDB assumes that the attribute value does not
	// exist in the table. If in fact the value does not exist, then the assumption
	// is valid and the condition evaluates to true. If the value is found, despite
	// the assumption that it does not exist, the condition evaluates to false.
	//
	//  Note that the default value for Exists is true.
	//
	//   The Value and Exists parameters are incompatible with AttributeValueList
	// and ComparisonOperator. Note that if you use both sets of parameters at once,
	// DynamoDB will return a ValidationException exception.
	Expected map[string]*ExpectedAttributeValue `type:"map"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//   To access an attribute whose name conflicts with a DynamoDB reserved word.
	//
	//   To create a placeholder for repeating occurrences of an attribute name
	// in an expression.
	//
	//   To prevent special characters in an attribute name from being misinterpreted
	// in an expression.
	//
	//   Use the # character in an expression to dereference an attribute name.
	// For example, consider the following attribute name:
	//
	// Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot
	// be used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	// {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	// #P = :val
	//
	// Tokens that begin with the : character are expression attribute values,
	// which are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]*string `type:"map"`

	// One or more values that can be substituted in an expression.
	//
	// Use the : (colon) character in an expression to dereference an attribute
	// value. For example, suppose that you wanted to check whether the value of
	// the ProductStatus attribute was one of the following:
	//
	// Available | Backordered | Discontinued
	//
	// You would first need to specify ExpressionAttributeValues as follows:
	//
	// { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"}
	// }
	//
	// You could then use these values in an expression, such as this:
	//
	// ProductStatus IN (:avail, :back, :disc)
	//
	// For more information on expression attribute values, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeValues map[string]*AttributeValue `type:"map"`

	// A map of attribute name/value pairs, one for each attribute. Only the primary
	// key attributes are required; you can optionally provide other attribute name-value
	// pairs for the item.
	//
	// You must provide all of the attributes for the primary key. For example,
	// with a hash type primary key, you only need to provide the hash attribute.
	// For a hash-and-range type primary key, you must provide both the hash attribute
	// and the range attribute.
	//
	// If you specify any attributes that are part of an index key, then the data
	// types for those attributes must match those of the schema in the table's
	// attribute definition.
	//
	// For more information about primary keys, see Primary Key (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModelPrimaryKey)
	// in the Amazon DynamoDB Developer Guide.
	//
	// Each element in the Item map is an AttributeValue object.
	Item map[string]*AttributeValue `type:"map" required:"true"`

	// A value that if set to TOTAL, the response includes ConsumedCapacity data
	// for tables and indexes. If set to INDEXES, the response includes ConsumedCapacity
	// for indexes. If set to NONE (the default), ConsumedCapacity is not included
	// in the response.
	ReturnConsumedCapacity *string `type:"string"`

	// A value that if set to SIZE, the response includes statistics about item
	// collections, if any, that were modified during the operation are returned
	// in the response. If set to NONE (the default), no statistics are returned.
	ReturnItemCollectionMetrics *string `type:"string"`

	// Use ReturnValues if you want to get the item attributes as they appeared
	// before they were updated with the PutItem request. For PutItem, the valid
	// values are:
	//
	//   NONE - If ReturnValues is not specified, or if its value is NONE, then
	// nothing is returned. (This setting is the default for ReturnValues.)
	//
	//   ALL_OLD - If PutItem overwrote an attribute name-value pair, then the
	// content of the old item is returned.
	ReturnValues *string `type:"string"`

	// The name of the table to contain the item.
	TableName *string `type:"string" required:"true"`

	metadataPutItemInput `json:"-" xml:"-"`
}

type metadataPutItemInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of a PutItem operation.
type PutItemOutput struct {
	// The attribute values as they appeared before the PutItem operation, but only
	// if ReturnValues is specified as ALL_OLD in the request. Each element consists
	// of an attribute name and an attribute value.
	Attributes map[string]*AttributeValue `type:"map"`

	// The capacity units consumed by an operation. The data returned includes the
	// total provisioned throughput consumed, along with statistics for the table
	// and any indexes involved in the operation. ConsumedCapacity is only returned
	// if the request asked for it. For more information, see Provisioned Throughput
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// Information about item collections, if any, that were affected by the operation.
	// ItemCollectionMetrics is only returned if the request asked for it. If the
	// table does not have any local secondary indexes, this information is not
	// returned in the response.
	//
	// Each ItemCollectionMetrics element consists of:
	//
	//  ItemCollectionKey - The hash key value of the item collection. This is
	// the same as the hash key of the item.
	//
	// SizeEstimateRange - An estimate of item collection size, in gigabytes. This
	// value is a two-element array containing a lower bound and an upper bound
	// for the estimate. The estimate includes the size of all the items in the
	// table, plus the size of all attributes projected into all of the local secondary
	// indexes on that table. Use this estimate to measure whether a local secondary
	// index is approaching its size limit.
	//
	// The estimate is subject to change over time; therefore, do not rely on the
	// precision or accuracy of the estimate.
	ItemCollectionMetrics *ItemCollectionMetrics `type:"structure"`

	metadataPutItemOutput `json:"-" xml:"-"`
}

type metadataPutItemOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents a request to perform a PutItem operation on an item.
type PutRequest struct {
	// A map of attribute name to attribute values, representing the primary key
	// of an item to be processed by PutItem. All of the table's primary key attributes
	// must be specified, and their data types must match those of the table's key
	// schema. If any attributes are present in the item which are part of an index
	// key schema for the table, their types must match the index key schema.
	Item map[string]*AttributeValue `type:"map" required:"true"`

	metadataPutRequest `json:"-" xml:"-"`
}

type metadataPutRequest struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of a Query operation.
type QueryInput struct {
	// This is a legacy parameter, for backward compatibility. New applications
	// should use ProjectionExpression instead. Do not combine legacy parameters
	// and expression parameters in a single API call; otherwise, DynamoDB will
	// return a ValidationException exception.
	//
	// This parameter allows you to retrieve attributes of type List or Map; however,
	// it cannot retrieve individual elements within a List or a Map.
	//
	// The names of one or more attributes to retrieve. If no attribute names are
	// provided, then all attributes will be returned. If any of the requested attributes
	// are not found, they will not appear in the result.
	//
	// Note that AttributesToGet has no effect on provisioned throughput consumption.
	// DynamoDB determines capacity units consumed based on item size, not on the
	// amount of data that is returned to an application.
	//
	// You cannot use both AttributesToGet and Select together in a Query request,
	// unless the value for Select is SPECIFIC_ATTRIBUTES. (This usage is equivalent
	// to specifying AttributesToGet without any value for Select.)
	//
	// If you query a local secondary index and request only attributes that are
	// projected into that index, the operation will read only the index and not
	// the table. If any of the requested attributes are not projected into the
	// local secondary index, DynamoDB will fetch each of these attributes from
	// the parent table. This extra fetching incurs additional throughput cost and
	// latency.
	//
	// If you query a global secondary index, you can only request attributes that
	// are projected into the index. Global secondary index queries cannot fetch
	// attributes from the parent table.
	AttributesToGet []*string `type:"list"`

	// This is a legacy parameter, for backward compatibility. New applications
	// should use FilterExpression instead. Do not combine legacy parameters and
	// expression parameters in a single API call; otherwise, DynamoDB will return
	// a ValidationException exception.
	//
	//  A logical operator to apply to the conditions in a QueryFilter map:
	//
	//  AND - If all of the conditions evaluate to true, then the entire map evaluates
	// to true.
	//
	// OR - If at least one of the conditions evaluate to true, then the entire
	// map evaluates to true.
	//
	//  If you omit ConditionalOperator, then AND is the default.
	//
	// The operation will succeed only if the entire map evaluates to true.
	//
	// This parameter does not support attributes of type List or Map.
	ConditionalOperator *string `type:"string"`

	// A value that if set to true, then the operation uses strongly consistent
	// reads; otherwise, eventually consistent reads are used.
	//
	// Strongly consistent reads are not supported on global secondary indexes.
	// If you query a global secondary index with ConsistentRead set to true, you
	// will receive an error message.
	ConsistentRead *bool `type:"boolean"`

	// The primary key of the first item that this operation will evaluate. Use
	// the value that was returned for LastEvaluatedKey in the previous operation.
	//
	// The data type for ExclusiveStartKey must be String, Number or Binary. No
	// set data types are allowed.
	ExclusiveStartKey map[string]*AttributeValue `type:"map"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//   To access an attribute whose name conflicts with a DynamoDB reserved word.
	//
	//   To create a placeholder for repeating occurrences of an attribute name
	// in an expression.
	//
	//   To prevent special characters in an attribute name from being misinterpreted
	// in an expression.
	//
	//   Use the # character in an expression to dereference an attribute name.
	// For example, consider the following attribute name:
	//
	// Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot
	// be used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	// {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	// #P = :val
	//
	// Tokens that begin with the : character are expression attribute values,
	// which are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]*string `type:"map"`

	// One or more values that can be substituted in an expression.
	//
	// Use the : (colon) character in an expression to dereference an attribute
	// value. For example, suppose that you wanted to check whether the value of
	// the ProductStatus attribute was one of the following:
	//
	// Available | Backordered | Discontinued
	//
	// You would first need to specify ExpressionAttributeValues as follows:
	//
	// { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"}
	// }
	//
	// You could then use these values in an expression, such as this:
	//
	// ProductStatus IN (:avail, :back, :disc)
	//
	// For more information on expression attribute values, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeValues map[string]*AttributeValue `type:"map"`

	// A string that contains conditions that DynamoDB applies after the Query operation,
	// but before the data is returned to you. Items that do not satisfy the FilterExpression
	// criteria are not returned.
	//
	//  A FilterExpression is applied after the items have already been read; the
	// process of filtering does not consume any additional read capacity units.
	//
	//  For more information, see Filter Expressions (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#FilteringResults)
	// in the Amazon DynamoDB Developer Guide.
	//
	// FilterExpression replaces the legacy QueryFilter and ConditionalOperator
	// parameters.
	FilterExpression *string `type:"string"`

	// The name of an index to query. This index can be any local secondary index
	// or global secondary index on the table. Note that if you use the IndexName
	// parameter, you must also provide TableName.
	IndexName *string `type:"string"`

	// The condition that specifies the key value(s) for items to be retrieved by
	// the Query action.
	//
	// The condition must perform an equality test on a single hash key value.
	// The condition can also test for one or more range key values. A Query can
	// use KeyConditionExpression to retrieve a single item with a given hash and
	// range key value, or several items that have the same hash key value but different
	// range key values.
	//
	// The hash key equality test is required, and must be specified in the following
	// format:
	//
	//  hashAttributeName = :hashval
	//
	// If you also want to provide a range key condition, it must be combined using
	// AND with the hash key condition. Following is an example, using the = comparison
	// operator for the range key:
	//
	//  hashAttributeName = :hashval AND rangeAttributeName = :rangeval
	//
	// Valid comparisons for the range key condition are as follows:
	//
	//   rangeAttributeName = :rangeval - true if the range key is equal to :rangeval.
	//
	//   rangeAttributeName < :rangeval - true if the range key is less than :rangeval.
	//
	//   rangeAttributeName <= :rangeval - true if the range key is less than or
	// equal to :rangeval.
	//
	//   rangeAttributeName > :rangeval - true if the range key is greater than
	// :rangeval.
	//
	//   rangeAttributeName >= :rangeval - true if the range key is greater than
	// or equal to :rangeval.
	//
	//   rangeAttributeName BETWEEN :rangeval1 AND :rangeval2 - true if the range
	// key is less than or greater than :rangeval1, and less than or equal to :rangeval2.
	//
	//   begins_with (rangeAttributeName, :rangeval) - true if the range key begins
	// with a particular operand. Note that the function name begins_with is case-sensitive.
	//
	//   Use the ExpressionAttributeValues parameter to replace tokens such as
	// :hashval and :rangeval with actual values at runtime.
	//
	// You can optionally use the ExpressionAttributeNames parameter to replace
	// the names of the hash and range attributes with placeholder tokens. This
	// might be necessary if an attribute name conflicts with a DynamoDB reserved
	// word. For example, the following KeyConditionExpression causes an error because
	// Size is a reserved word:
	//
	//   Size = :myval   To work around this, define a placeholder (such a #myval)
	// to represent the attribute name Size. KeyConditionExpression then is as follows:
	//
	//   #S = :myval   For a list of reserved words, see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// For more information on ExpressionAttributeNames and ExpressionAttributeValues,
	// see Using Placeholders for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	//  KeyConditionExpression replaces the legacy KeyConditions parameter.
	KeyConditionExpression *string `type:"string"`

	// This is a legacy parameter, for backward compatibility. New applications
	// should use KeyConditionExpression instead. Do not combine legacy parameters
	// and expression parameters in a single API call; otherwise, DynamoDB will
	// return a ValidationException exception.
	//
	//  The selection criteria for the query. For a query on a table, you can have
	// conditions only on the table primary key attributes. You must provide the
	// hash key attribute name and value as an EQ condition. You can optionally
	// provide a second condition, referring to the range key attribute.
	//
	//  If you don't provide a range key condition, all of the items that match
	// the hash key will be retrieved. If a FilterExpression or QueryFilter is present,
	// it will be applied after the items are retrieved.
	//
	// For a query on an index, you can have conditions only on the index key attributes.
	// You must provide the index hash attribute name and value as an EQ condition.
	// You can optionally provide a second condition, referring to the index key
	// range attribute.
	//
	// Each KeyConditions element consists of an attribute name to compare, along
	// with the following:
	//
	//   AttributeValueList - One or more values to evaluate against the supplied
	// attribute. The number of values in the list depends on the ComparisonOperator
	// being used.
	//
	// For type Number, value comparisons are numeric.
	//
	// String value comparisons for greater than, equals, or less than are based
	// on ASCII character code values. For example, a is greater than A, and a is
	// greater than B. For a list of code values, see http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
	// (http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters).
	//
	// For Binary, DynamoDB treats each byte of the binary data as unsigned when
	// it compares binary values.
	//
	//   ComparisonOperator - A comparator for evaluating attributes, for example,
	// equals, greater than, less than, and so on.
	//
	// For KeyConditions, only the following comparison operators are supported:
	//
	//  EQ | LE | LT | GE | GT | BEGINS_WITH | BETWEEN
	//
	// The following are descriptions of these comparison operators.
	//
	//   EQ : Equal.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// or Binary (not a set type). If an item contains an AttributeValue element
	// of a different type than the one specified in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not equal {"NS":["6", "2", "1"]}.
	//
	//    LE : Less than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    LT : Less than.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// or Binary (not a set type). If an item contains an AttributeValue element
	// of a different type than the one provided in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GE : Greater than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GT : Greater than.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    BEGINS_WITH : Checks for a prefix.
	//
	// AttributeValueList can contain only one AttributeValue of type String or
	// Binary (not a Number or a set type). The target attribute of the comparison
	// must be of type String or Binary (not a Number or a set type).
	//
	//    BETWEEN : Greater than or equal to the first value, and less than or
	// equal to the second value.
	//
	// AttributeValueList must contain two AttributeValue elements of the same
	// type, either String, Number, or Binary (not a set type). A target attribute
	// matches if the target value is greater than, or equal to, the first element
	// and less than, or equal to, the second element. If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not compare to {"N":"6"}. Also,
	// {"N":"6"} does not compare to {"NS":["6", "2", "1"]}
	//
	//     For usage examples of AttributeValueList and ComparisonOperator, see
	// Legacy Conditional Parameters (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html)
	// in the Amazon DynamoDB Developer Guide.
	KeyConditions map[string]*Condition `type:"map"`

	// The maximum number of items to evaluate (not necessarily the number of matching
	// items). If DynamoDB processes the number of items up to the limit while processing
	// the results, it stops the operation and returns the matching values up to
	// that point, and a key in LastEvaluatedKey to apply in a subsequent operation,
	// so that you can pick up where you left off. Also, if the processed data set
	// size exceeds 1 MB before DynamoDB reaches this limit, it stops the operation
	// and returns the matching values up to the limit, and a key in LastEvaluatedKey
	// to apply in a subsequent operation to continue the operation. For more information,
	// see Query and Scan in the Amazon DynamoDB Developer Guide.
	Limit *int64 `type:"integer"`

	// A string that identifies one or more attributes to retrieve from the table.
	// These attributes can include scalars, sets, or elements of a JSON document.
	// The attributes in the expression must be separated by commas.
	//
	// If no attribute names are specified, then all attributes will be returned.
	// If any of the requested attributes are not found, they will not appear in
	// the result.
	//
	// For more information, see Accessing Item Attributes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// ProjectionExpression replaces the legacy AttributesToGet parameter.
	ProjectionExpression *string `type:"string"`

	// This is a legacy parameter, for backward compatibility. New applications
	// should use FilterExpression instead. Do not combine legacy parameters and
	// expression parameters in a single API call; otherwise, DynamoDB will return
	// a ValidationException exception.
	//
	//  A condition that evaluates the query results after the items are read and
	// returns only the desired values.
	//
	// This parameter does not support attributes of type List or Map.
	//
	//  A QueryFilter is applied after the items have already been read; the process
	// of filtering does not consume any additional read capacity units.
	//
	// If you provide more than one condition in the QueryFilter map, then by default
	// all of the conditions must evaluate to true. In other words, the conditions
	// are ANDed together. (You can use the ConditionalOperator parameter to OR
	// the conditions instead. If you do this, then at least one of the conditions
	// must evaluate to true, rather than all of them.)
	//
	// Note that QueryFilter does not allow key attributes. You cannot define a
	// filter condition on a hash key or range key.
	//
	// Each QueryFilter element consists of an attribute name to compare, along
	// with the following:
	//
	//   AttributeValueList - One or more values to evaluate against the supplied
	// attribute. The number of values in the list depends on the operator specified
	// in ComparisonOperator.
	//
	// For type Number, value comparisons are numeric.
	//
	// String value comparisons for greater than, equals, or less than are based
	// on ASCII character code values. For example, a is greater than A, and a is
	// greater than B. For a list of code values, see http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
	// (http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters).
	//
	// For type Binary, DynamoDB treats each byte of the binary data as unsigned
	// when it compares binary values.
	//
	// For information on specifying data types in JSON, see JSON Data Format (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataFormat.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	//   ComparisonOperator - A comparator for evaluating attributes. For example,
	// equals, greater than, less than, etc.
	//
	// The following comparison operators are available:
	//
	// EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS
	// | BEGINS_WITH | IN | BETWEEN
	//
	// For complete descriptions of all comparison operators, see the Condition
	// (http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html)
	// data type.
	QueryFilter map[string]*Condition `type:"map"`

	// A value that if set to TOTAL, the response includes ConsumedCapacity data
	// for tables and indexes. If set to INDEXES, the response includes ConsumedCapacity
	// for indexes. If set to NONE (the default), ConsumedCapacity is not included
	// in the response.
	ReturnConsumedCapacity *string `type:"string"`

	// A value that specifies ascending (true) or descending (false) traversal of
	// the index. DynamoDB returns results reflecting the requested order determined
	// by the range key. If the data type is Number, the results are returned in
	// numeric order. For type String, the results are returned in order of ASCII
	// character code values. For type Binary, DynamoDB treats each byte of the
	// binary data as unsigned when it compares binary values.
	//
	// If ScanIndexForward is not specified, the results are returned in ascending
	// order.
	ScanIndexForward *bool `type:"boolean"`

	// The attributes to be returned in the result. You can retrieve all item attributes,
	// specific item attributes, the count of matching items, or in the case of
	// an index, some or all of the attributes projected into the index.
	//
	//   ALL_ATTRIBUTES - Returns all of the item attributes from the specified
	// table or index. If you query a local secondary index, then for each matching
	// item in the index DynamoDB will fetch the entire item from the parent table.
	// If the index is configured to project all item attributes, then all of the
	// data can be obtained from the local secondary index, and no fetching is required.
	//
	//   ALL_PROJECTED_ATTRIBUTES - Allowed only when querying an index. Retrieves
	// all attributes that have been projected into the index. If the index is configured
	// to project all attributes, this return value is equivalent to specifying
	// ALL_ATTRIBUTES.
	//
	//   COUNT - Returns the number of matching items, rather than the matching
	// items themselves.
	//
	//    SPECIFIC_ATTRIBUTES - Returns only the attributes listed in AttributesToGet.
	// This return value is equivalent to specifying AttributesToGet without specifying
	// any value for Select.
	//
	// If you query a local secondary index and request only attributes that are
	// projected into that index, the operation will read only the index and not
	// the table. If any of the requested attributes are not projected into the
	// local secondary index, DynamoDB will fetch each of these attributes from
	// the parent table. This extra fetching incurs additional throughput cost and
	// latency.
	//
	// If you query a global secondary index, you can only request attributes that
	// are projected into the index. Global secondary index queries cannot fetch
	// attributes from the parent table.
	//
	//   If neither Select nor AttributesToGet are specified, DynamoDB defaults
	// to ALL_ATTRIBUTES when accessing a table, and ALL_PROJECTED_ATTRIBUTES when
	// accessing an index. You cannot use both Select and AttributesToGet together
	// in a single request, unless the value for Select is SPECIFIC_ATTRIBUTES.
	// (This usage is equivalent to specifying AttributesToGet without any value
	// for Select.)
	//
	// If you use the ProjectionExpression parameter, then the value for Select
	// can only be SPECIFIC_ATTRIBUTES. Any other value for Select will return an
	// error.
	Select *string `type:"string"`

	// The name of the table containing the requested items.
	TableName *string `type:"string" required:"true"`

	metadataQueryInput `json:"-" xml:"-"`
}

type metadataQueryInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of a Query operation.
type QueryOutput struct {
	// The capacity units consumed by an operation. The data returned includes the
	// total provisioned throughput consumed, along with statistics for the table
	// and any indexes involved in the operation. ConsumedCapacity is only returned
	// if the request asked for it. For more information, see Provisioned Throughput
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// The number of items in the response.
	//
	// If you used a QueryFilter in the request, then Count is the number of items
	// returned after the filter was applied, and ScannedCount is the number of
	// matching items before> the filter was applied.
	//
	// If you did not use a filter in the request, then Count and ScannedCount
	// are the same.
	Count *int64 `type:"integer"`

	// An array of item attributes that match the query criteria. Each element in
	// this array consists of an attribute name and the value for that attribute.
	Items []map[string]*AttributeValue `type:"list"`

	// The primary key of the item where the operation stopped, inclusive of the
	// previous result set. Use this value to start a new operation, excluding this
	// value in the new request.
	//
	// If LastEvaluatedKey is empty, then the "last page" of results has been processed
	// and there is no more data to be retrieved.
	//
	// If LastEvaluatedKey is not empty, it does not necessarily mean that there
	// is more data in the result set. The only way to know when you have reached
	// the end of the result set is when LastEvaluatedKey is empty.
	LastEvaluatedKey map[string]*AttributeValue `type:"map"`

	// The number of items evaluated, before any QueryFilter is applied. A high
	// ScannedCount value with few, or no, Count results indicates an inefficient
	// Query operation. For more information, see Count and ScannedCount (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count)
	// in the Amazon DynamoDB Developer Guide.
	//
	// If you did not use a filter in the request, then ScannedCount is the same
	// as Count.
	ScannedCount *int64 `type:"integer"`

	metadataQueryOutput `json:"-" xml:"-"`
}

type metadataQueryOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of a Scan operation.
type ScanInput struct {
	// This is a legacy parameter, for backward compatibility. New applications
	// should use ProjectionExpression instead. Do not combine legacy parameters
	// and expression parameters in a single API call; otherwise, DynamoDB will
	// return a ValidationException exception.
	//
	// This parameter allows you to retrieve attributes of type List or Map; however,
	// it cannot retrieve individual elements within a List or a Map.
	//
	// The names of one or more attributes to retrieve. If no attribute names are
	// provided, then all attributes will be returned. If any of the requested attributes
	// are not found, they will not appear in the result.
	//
	// Note that AttributesToGet has no effect on provisioned throughput consumption.
	// DynamoDB determines capacity units consumed based on item size, not on the
	// amount of data that is returned to an application.
	AttributesToGet []*string `type:"list"`

	// This is a legacy parameter, for backward compatibility. New applications
	// should use FilterExpression instead. Do not combine legacy parameters and
	// expression parameters in a single API call; otherwise, DynamoDB will return
	// a ValidationException exception.
	//
	//  A logical operator to apply to the conditions in a ScanFilter map:
	//
	//  AND - If all of the conditions evaluate to true, then the entire map evaluates
	// to true.
	//
	// OR - If at least one of the conditions evaluate to true, then the entire
	// map evaluates to true.
	//
	//  If you omit ConditionalOperator, then AND is the default.
	//
	// The operation will succeed only if the entire map evaluates to true.
	//
	// This parameter does not support attributes of type List or Map.
	ConditionalOperator *string `type:"string"`

	// The primary key of the first item that this operation will evaluate. Use
	// the value that was returned for LastEvaluatedKey in the previous operation.
	//
	// The data type for ExclusiveStartKey must be String, Number or Binary. No
	// set data types are allowed.
	//
	// In a parallel scan, a Scan request that includes ExclusiveStartKey must
	// specify the same segment whose previous Scan returned the corresponding value
	// of LastEvaluatedKey.
	ExclusiveStartKey map[string]*AttributeValue `type:"map"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//   To access an attribute whose name conflicts with a DynamoDB reserved word.
	//
	//   To create a placeholder for repeating occurrences of an attribute name
	// in an expression.
	//
	//   To prevent special characters in an attribute name from being misinterpreted
	// in an expression.
	//
	//   Use the # character in an expression to dereference an attribute name.
	// For example, consider the following attribute name:
	//
	// Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot
	// be used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	// {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	// #P = :val
	//
	// Tokens that begin with the : character are expression attribute values,
	// which are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]*string `type:"map"`

	// One or more values that can be substituted in an expression.
	//
	// Use the : (colon) character in an expression to dereference an attribute
	// value. For example, suppose that you wanted to check whether the value of
	// the ProductStatus attribute was one of the following:
	//
	// Available | Backordered | Discontinued
	//
	// You would first need to specify ExpressionAttributeValues as follows:
	//
	// { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"}
	// }
	//
	// You could then use these values in an expression, such as this:
	//
	// ProductStatus IN (:avail, :back, :disc)
	//
	// For more information on expression attribute values, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeValues map[string]*AttributeValue `type:"map"`

	// A string that contains conditions that DynamoDB applies after the Scan operation,
	// but before the data is returned to you. Items that do not satisfy the FilterExpression
	// criteria are not returned.
	//
	//  A FilterExpression is applied after the items have already been read; the
	// process of filtering does not consume any additional read capacity units.
	//
	// For more information, see Filter Expressions (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#FilteringResults)
	// in the Amazon DynamoDB Developer Guide.
	//
	// FilterExpression replaces the legacy ScanFilter and ConditionalOperator
	// parameters.
	FilterExpression *string `type:"string"`

	// The name of a secondary index to scan. This index can be any local secondary
	// index or global secondary index. Note that if you use the IndexName parameter,
	// you must also provide TableName.
	IndexName *string `type:"string"`

	// The maximum number of items to evaluate (not necessarily the number of matching
	// items). If DynamoDB processes the number of items up to the limit while processing
	// the results, it stops the operation and returns the matching values up to
	// that point, and a key in LastEvaluatedKey to apply in a subsequent operation,
	// so that you can pick up where you left off. Also, if the processed data set
	// size exceeds 1 MB before DynamoDB reaches this limit, it stops the operation
	// and returns the matching values up to the limit, and a key in LastEvaluatedKey
	// to apply in a subsequent operation to continue the operation. For more information,
	// see Query and Scan in the Amazon DynamoDB Developer Guide.
	Limit *int64 `type:"integer"`

	// A string that identifies one or more attributes to retrieve from the specified
	// table or index. These attributes can include scalars, sets, or elements of
	// a JSON document. The attributes in the expression must be separated by commas.
	//
	// If no attribute names are specified, then all attributes will be returned.
	// If any of the requested attributes are not found, they will not appear in
	// the result.
	//
	// For more information, see Accessing Item Attributes (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.AccessingItemAttributes.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// ProjectionExpression replaces the legacy AttributesToGet parameter.
	ProjectionExpression *string `type:"string"`

	// A value that if set to TOTAL, the response includes ConsumedCapacity data
	// for tables and indexes. If set to INDEXES, the response includes ConsumedCapacity
	// for indexes. If set to NONE (the default), ConsumedCapacity is not included
	// in the response.
	ReturnConsumedCapacity *string `type:"string"`

	// This is a legacy parameter, for backward compatibility. New applications
	// should use FilterExpression instead. Do not combine legacy parameters and
	// expression parameters in a single API call; otherwise, DynamoDB will return
	// a ValidationException exception.
	//
	//  A condition that evaluates the scan results and returns only the desired
	// values.
	//
	// This parameter does not support attributes of type List or Map.
	//
	// If you specify more than one condition in the ScanFilter map, then by default
	// all of the conditions must evaluate to true. In other words, the conditions
	// are ANDed together. (You can use the ConditionalOperator parameter to OR
	// the conditions instead. If you do this, then at least one of the conditions
	// must evaluate to true, rather than all of them.)
	//
	// Each ScanFilter element consists of an attribute name to compare, along
	// with the following:
	//
	//   AttributeValueList - One or more values to evaluate against the supplied
	// attribute. The number of values in the list depends on the operator specified
	// in ComparisonOperator .
	//
	// For type Number, value comparisons are numeric.
	//
	// String value comparisons for greater than, equals, or less than are based
	// on ASCII character code values. For example, a is greater than A, and a is
	// greater than B. For a list of code values, see http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters
	// (http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters).
	//
	// For Binary, DynamoDB treats each byte of the binary data as unsigned when
	// it compares binary values.
	//
	// For information on specifying data types in JSON, see JSON Data Format (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataFormat.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	//   ComparisonOperator - A comparator for evaluating attributes. For example,
	// equals, greater than, less than, etc.
	//
	// The following comparison operators are available:
	//
	// EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS
	// | BEGINS_WITH | IN | BETWEEN
	//
	// For complete descriptions of all comparison operators, see Condition (http://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_Condition.html).
	ScanFilter map[string]*Condition `type:"map"`

	// For a parallel Scan request, Segment identifies an individual segment to
	// be scanned by an application worker.
	//
	// Segment IDs are zero-based, so the first segment is always 0. For example,
	// if you want to use four application threads to scan a table or an index,
	// then the first thread specifies a Segment value of 0, the second thread specifies
	// 1, and so on.
	//
	// The value of LastEvaluatedKey returned from a parallel Scan request must
	// be used as ExclusiveStartKey with the same segment ID in a subsequent Scan
	// operation.
	//
	// The value for Segment must be greater than or equal to 0, and less than
	// the value provided for TotalSegments.
	//
	// If you provide Segment, you must also provide TotalSegments.
	Segment *int64 `type:"integer"`

	// The attributes to be returned in the result. You can retrieve all item attributes,
	// specific item attributes, or the count of matching items.
	//
	//   ALL_ATTRIBUTES - Returns all of the item attributes.
	//
	//   COUNT - Returns the number of matching items, rather than the matching
	// items themselves.
	//
	//    SPECIFIC_ATTRIBUTES - Returns only the attributes listed in AttributesToGet.
	// This return value is equivalent to specifying AttributesToGet without specifying
	// any value for Select.
	//
	//   If neither Select nor AttributesToGet are specified, DynamoDB defaults
	// to ALL_ATTRIBUTES. You cannot use both AttributesToGet and Select together
	// in a single request, unless the value for Select is SPECIFIC_ATTRIBUTES.
	// (This usage is equivalent to specifying AttributesToGet without any value
	// for Select.)
	Select *string `type:"string"`

	// The name of the table containing the requested items; or, if you provide
	// IndexName, the name of the table to which that index belongs.
	TableName *string `type:"string" required:"true"`

	// For a parallel Scan request, TotalSegments represents the total number of
	// segments into which the Scan operation will be divided. The value of TotalSegments
	// corresponds to the number of application workers that will perform the parallel
	// scan. For example, if you want to use four application threads to scan a
	// table or an index, specify a TotalSegments value of 4.
	//
	// The value for TotalSegments must be greater than or equal to 1, and less
	// than or equal to 1000000. If you specify a TotalSegments value of 1, the
	// Scan operation will be sequential rather than parallel.
	//
	// If you specify TotalSegments, you must also specify Segment.
	TotalSegments *int64 `type:"integer"`

	metadataScanInput `json:"-" xml:"-"`
}

type metadataScanInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of a Scan operation.
type ScanOutput struct {
	// The capacity units consumed by an operation. The data returned includes the
	// total provisioned throughput consumed, along with statistics for the table
	// and any indexes involved in the operation. ConsumedCapacity is only returned
	// if the request asked for it. For more information, see Provisioned Throughput
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// The number of items in the response.
	//
	// If you set ScanFilter in the request, then Count is the number of items
	// returned after the filter was applied, and ScannedCount is the number of
	// matching items before the filter was applied.
	//
	// If you did not use a filter in the request, then Count is the same as ScannedCount.
	Count *int64 `type:"integer"`

	// An array of item attributes that match the scan criteria. Each element in
	// this array consists of an attribute name and the value for that attribute.
	Items []map[string]*AttributeValue `type:"list"`

	// The primary key of the item where the operation stopped, inclusive of the
	// previous result set. Use this value to start a new operation, excluding this
	// value in the new request.
	//
	// If LastEvaluatedKey is empty, then the "last page" of results has been processed
	// and there is no more data to be retrieved.
	//
	// If LastEvaluatedKey is not empty, it does not necessarily mean that there
	// is more data in the result set. The only way to know when you have reached
	// the end of the result set is when LastEvaluatedKey is empty.
	LastEvaluatedKey map[string]*AttributeValue `type:"map"`

	// The number of items evaluated, before any ScanFilter is applied. A high ScannedCount
	// value with few, or no, Count results indicates an inefficient Scan operation.
	// For more information, see Count and ScannedCount (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/QueryAndScan.html#Count)
	// in the Amazon DynamoDB Developer Guide.
	//
	// If you did not use a filter in the request, then ScannedCount is the same
	// as Count.
	ScannedCount *int64 `type:"integer"`

	metadataScanOutput `json:"-" xml:"-"`
}

type metadataScanOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the properties of a table.
type TableDescription struct {
	// An array of AttributeDefinition objects. Each of these objects describes
	// one attribute in the table and index key schema.
	//
	// Each AttributeDefinition object in this array is composed of:
	//
	//   AttributeName - The name of the attribute.
	//
	//   AttributeType - The data type for the attribute.
	AttributeDefinitions []*AttributeDefinition `type:"list"`

	// The date and time when the table was created, in UNIX epoch time (http://www.epochconverter.com/)
	// format.
	CreationDateTime *time.Time `type:"timestamp" timestampFormat:"unix"`

	// The global secondary indexes, if any, on the table. Each index is scoped
	// to a given hash key value. Each element is composed of:
	//
	//   Backfilling - If true, then the index is currently in the backfilling
	// phase. Backfilling occurs only when a new global secondary index is added
	// to the table; it is the process by which DynamoDB populates the new index
	// with data from the table. (This attribute does not appear for indexes that
	// were created during a CreateTable operation.)
	//
	//   IndexName - The name of the global secondary index.
	//
	//   IndexSizeBytes - The total size of the global secondary index, in bytes.
	// DynamoDB updates this value approximately every six hours. Recent changes
	// might not be reflected in this value.
	//
	//   IndexStatus - The current status of the global secondary index:
	//
	//   CREATING - The index is being created.
	//
	//   UPDATING - The index is being updated.
	//
	//   DELETING - The index is being deleted.
	//
	//   ACTIVE - The index is ready for use.
	//
	//     ItemCount - The number of items in the global secondary index. DynamoDB
	// updates this value approximately every six hours. Recent changes might not
	// be reflected in this value.
	//
	//   KeySchema - Specifies the complete index key schema. The attribute names
	// in the key schema must be between 1 and 255 characters (inclusive). The key
	// schema must begin with the same hash key attribute as the table.
	//
	//   Projection - Specifies attributes that are copied (projected) from the
	// table into the index. These are in addition to the primary key attributes
	// and index key attributes, which are automatically projected. Each attribute
	// specification is composed of:
	//
	//   ProjectionType - One of the following:
	//
	//   KEYS_ONLY - Only the index and primary keys are projected into the index.
	//
	//   INCLUDE - Only the specified table attributes are projected into the index.
	// The list of projected attributes are in NonKeyAttributes.
	//
	//   ALL - All of the table attributes are projected into the index.
	//
	//     NonKeyAttributes - A list of one or more non-key attribute names that
	// are projected into the secondary index. The total count of attributes provided
	// in NonKeyAttributes, summed across all of the secondary indexes, must not
	// exceed 20. If you project the same attribute into two different indexes,
	// this counts as two distinct attributes when determining the total.
	//
	//     ProvisionedThroughput - The provisioned throughput settings for the
	// global secondary index, consisting of read and write capacity units, along
	// with data about increases and decreases.
	//
	//   If the table is in the DELETING state, no information about indexes will
	// be returned.
	GlobalSecondaryIndexes []*GlobalSecondaryIndexDescription `type:"list"`

	// The number of items in the specified table. DynamoDB updates this value approximately
	// every six hours. Recent changes might not be reflected in this value.
	ItemCount *int64 `type:"long"`

	// The primary key structure for the table. Each KeySchemaElement consists of:
	//
	//   AttributeName - The name of the attribute.
	//
	//   KeyType - The key type for the attribute. Can be either HASH or RANGE.
	//
	//   For more information about primary keys, see Primary Key (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DataModel.html#DataModelPrimaryKey)
	// in the Amazon DynamoDB Developer Guide.
	KeySchema []*KeySchemaElement `type:"list"`

	// Represents one or more local secondary indexes on the table. Each index is
	// scoped to a given hash key value. Tables with one or more local secondary
	// indexes are subject to an item collection size limit, where the amount of
	// data within a given item collection cannot exceed 10 GB. Each element is
	// composed of:
	//
	//   IndexName - The name of the local secondary index.
	//
	//   KeySchema - Specifies the complete index key schema. The attribute names
	// in the key schema must be between 1 and 255 characters (inclusive). The key
	// schema must begin with the same hash key attribute as the table.
	//
	//   Projection - Specifies attributes that are copied (projected) from the
	// table into the index. These are in addition to the primary key attributes
	// and index key attributes, which are automatically projected. Each attribute
	// specification is composed of:
	//
	//   ProjectionType - One of the following:
	//
	//   KEYS_ONLY - Only the index and primary keys are projected into the index.
	//
	//   INCLUDE - Only the specified table attributes are projected into the index.
	// The list of projected attributes are in NonKeyAttributes.
	//
	//   ALL - All of the table attributes are projected into the index.
	//
	//     NonKeyAttributes - A list of one or more non-key attribute names that
	// are projected into the secondary index. The total count of attributes provided
	// in NonKeyAttributes, summed across all of the secondary indexes, must not
	// exceed 20. If you project the same attribute into two different indexes,
	// this counts as two distinct attributes when determining the total.
	//
	//     IndexSizeBytes - Represents the total size of the index, in bytes. DynamoDB
	// updates this value approximately every six hours. Recent changes might not
	// be reflected in this value.
	//
	//   ItemCount - Represents the number of items in the index. DynamoDB updates
	// this value approximately every six hours. Recent changes might not be reflected
	// in this value.
	//
	//   If the table is in the DELETING state, no information about indexes will
	// be returned.
	LocalSecondaryIndexes []*LocalSecondaryIndexDescription `type:"list"`

	// The provisioned throughput settings for the table, consisting of read and
	// write capacity units, along with data about increases and decreases.
	ProvisionedThroughput *ProvisionedThroughputDescription `type:"structure"`

	// The name of the table.
	TableName *string `type:"string"`

	// The total size of the specified table, in bytes. DynamoDB updates this value
	// approximately every six hours. Recent changes might not be reflected in this
	// value.
	TableSizeBytes *int64 `type:"long"`

	// The current state of the table:
	//
	//   CREATING - The table is being created.
	//
	//   UPDATING - The table is being updated.
	//
	//   DELETING - The table is being deleted.
	//
	//   ACTIVE - The table is ready for use.
	TableStatus *string `type:"string"`

	metadataTableDescription `json:"-" xml:"-"`
}

type metadataTableDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the new provisioned throughput settings to be applied to a global
// secondary index.
type UpdateGlobalSecondaryIndexAction struct {
	// The name of the global secondary index to be updated.
	IndexName *string `type:"string" required:"true"`

	// Represents the provisioned throughput settings for a specified table or index.
	// The settings can be modified using the UpdateTable operation.
	//
	// For current minimum and maximum provisioned throughput values, see Limits
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	ProvisionedThroughput *ProvisionedThroughput `type:"structure" required:"true"`

	metadataUpdateGlobalSecondaryIndexAction `json:"-" xml:"-"`
}

type metadataUpdateGlobalSecondaryIndexAction struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of an UpdateItem operation.
type UpdateItemInput struct {
	// This is a legacy parameter, for backward compatibility. New applications
	// should use UpdateExpression instead. Do not combine legacy parameters and
	// expression parameters in a single API call; otherwise, DynamoDB will return
	// a ValidationException exception.
	//
	// This parameter can be used for modifying top-level attributes; however,
	// it does not support individual list or map elements.
	//
	//  The names of attributes to be modified, the action to perform on each,
	// and the new value for each. If you are updating an attribute that is an index
	// key attribute for any indexes on that table, the attribute type must match
	// the index key type defined in the AttributesDefinition of the table description.
	// You can use UpdateItem to update any nonkey attributes.
	//
	// Attribute values cannot be null. String and Binary type attributes must
	// have lengths greater than zero. Set type attributes must not be empty. Requests
	// with empty values will be rejected with a ValidationException exception.
	//
	// Each AttributeUpdates element consists of an attribute name to modify, along
	// with the following:
	//
	//   Value - The new value, if applicable, for this attribute.
	//
	//   Action - A value that specifies how to perform the update. This action
	// is only valid for an existing attribute whose data type is Number or is a
	// set; do not use ADD for other data types.
	//
	// If an item with the specified primary key is found in the table, the following
	// values perform the following actions:
	//
	//   PUT - Adds the specified attribute to the item. If the attribute already
	// exists, it is replaced by the new value.
	//
	//   DELETE - Removes the attribute and its value, if no value is specified
	// for DELETE. The data type of the specified value must match the existing
	// value's data type.
	//
	// If a set of values is specified, then those values are subtracted from the
	// old set. For example, if the attribute value was the set [a,b,c] and the
	// DELETE action specifies [a,c], then the final attribute value is [b]. Specifying
	// an empty set is an error.
	//
	//   ADD - Adds the specified value to the item, if the attribute does not
	// already exist. If the attribute does exist, then the behavior of ADD depends
	// on the data type of the attribute:
	//
	//   If the existing attribute is a number, and if Value is also a number,
	// then Value is mathematically added to the existing attribute. If Value is
	// a negative number, then it is subtracted from the existing attribute.
	//
	//  If you use ADD to increment or decrement a number value for an item that
	// doesn't exist before the update, DynamoDB uses 0 as the initial value.
	//
	// Similarly, if you use ADD for an existing item to increment or decrement
	// an attribute value that doesn't exist before the update, DynamoDB uses 0
	// as the initial value. For example, suppose that the item you want to update
	// doesn't have an attribute named itemcount, but you decide to ADD the number
	// 3 to this attribute anyway. DynamoDB will create the itemcount attribute,
	// set its initial value to 0, and finally add 3 to it. The result will be a
	// new itemcount attribute, with a value of 3.
	//
	//    If the existing data type is a set, and if Value is also a set, then
	// Value is appended to the existing set. For example, if the attribute value
	// is the set [1,2], and the ADD action specified [3], then the final attribute
	// value is [1,2,3]. An error occurs if an ADD action is specified for a set
	// attribute and the attribute type specified does not match the existing set
	// type.
	//
	// Both sets must have the same primitive data type. For example, if the existing
	// data type is a set of strings, Value must also be a set of strings.
	//
	//     If no item with the specified key is found in the table, the following
	// values perform the following actions:
	//
	//   PUT - Causes DynamoDB to create a new item with the specified primary
	// key, and then adds the attribute.
	//
	//   DELETE - Nothing happens, because attributes cannot be deleted from a
	// nonexistent item. The operation succeeds, but DynamoDB does not create a
	// new item.
	//
	//   ADD - Causes DynamoDB to create an item with the supplied primary key
	// and number (or set of numbers) for the attribute value. The only data types
	// allowed are Number and Number Set.
	//
	//     If you provide any attributes that are part of an index key, then the
	// data types for those attributes must match those of the schema in the table's
	// attribute definition.
	AttributeUpdates map[string]*AttributeValueUpdate `type:"map"`

	// A condition that must be satisfied in order for a conditional update to succeed.
	//
	// An expression can contain any of the following:
	//
	//   Boolean functions: attribute_exists | attribute_not_exists | contains
	// | begins_with
	//
	// These function names are case-sensitive.
	//
	//   Comparison operators:  = | <> | < | > | <= | >= | BETWEEN | IN
	//
	//    Logical operators: AND | OR | NOT
	//
	//   For more information on condition expressions, see Specifying Conditions
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.SpecifyingConditions.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// ConditionExpression replaces the legacy ConditionalOperator and Expected
	// parameters.
	ConditionExpression *string `type:"string"`

	// This is a legacy parameter, for backward compatibility. New applications
	// should use ConditionExpression instead. Do not combine legacy parameters
	// and expression parameters in a single API call; otherwise, DynamoDB will
	// return a ValidationException exception.
	//
	//  A logical operator to apply to the conditions in the Expected map:
	//
	//  AND - If all of the conditions evaluate to true, then the entire map evaluates
	// to true.
	//
	// OR - If at least one of the conditions evaluate to true, then the entire
	// map evaluates to true.
	//
	//  If you omit ConditionalOperator, then AND is the default.
	//
	// The operation will succeed only if the entire map evaluates to true.
	//
	// This parameter does not support attributes of type List or Map.
	ConditionalOperator *string `type:"string"`

	// This is a legacy parameter, for backward compatibility. New applications
	// should use  ConditionExpression  instead. Do not combine legacy parameters
	// and expression parameters in a single API call; otherwise, DynamoDB will
	// return a ValidationException exception.
	//
	//  A map of attribute/condition pairs. Expected provides a conditional block
	// for the UpdateItem operation.
	//
	// Each element of Expected consists of an attribute name, a comparison operator,
	// and one or more values. DynamoDB compares the attribute with the value(s)
	// you supplied, using the comparison operator. For each Expected element, the
	// result of the evaluation is either true or false.
	//
	// If you specify more than one element in the Expected map, then by default
	// all of the conditions must evaluate to true. In other words, the conditions
	// are ANDed together. (You can use the ConditionalOperator parameter to OR
	// the conditions instead. If you do this, then at least one of the conditions
	// must evaluate to true, rather than all of them.)
	//
	// If the Expected map evaluates to true, then the conditional operation succeeds;
	// otherwise, it fails.
	//
	// Expected contains the following:
	//
	//   AttributeValueList - One or more values to evaluate against the supplied
	// attribute. The number of values in the list depends on the ComparisonOperator
	// being used.
	//
	// For type Number, value comparisons are numeric.
	//
	// String value comparisons for greater than, equals, or less than are based
	// on ASCII character code values. For example, a is greater than A, and a is
	// greater than B. For a list of code values, see http://en.wikipedia.org/wiki/ASCII#ASCII_printable_characters.
	//
	// For type Binary, DynamoDB treats each byte of the binary data as unsigned
	// when it compares binary values.
	//
	//   ComparisonOperator - A comparator for evaluating attributes in the AttributeValueList.
	// When performing the comparison, DynamoDB uses strongly consistent reads.
	//
	// The following comparison operators are available:
	//
	// EQ | NE | LE | LT | GE | GT | NOT_NULL | NULL | CONTAINS | NOT_CONTAINS
	// | BEGINS_WITH | IN | BETWEEN
	//
	// The following are descriptions of each comparison operator.
	//
	//   EQ : Equal. EQ is supported for all datatypes, including lists and maps.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, Binary, String Set, Number Set, or Binary Set. If an item contains
	// an AttributeValue element of a different type than the one provided in the
	// request, the value does not match. For example, {"S":"6"} does not equal
	// {"N":"6"}. Also, {"N":"6"} does not equal {"NS":["6", "2", "1"]}.
	//
	//    NE : Not equal. NE is supported for all datatypes, including lists and
	// maps.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// Binary, String Set, Number Set, or Binary Set. If an item contains an AttributeValue
	// of a different type than the one provided in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not equal {"NS":["6", "2", "1"]}.
	//
	//    LE : Less than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    LT : Less than.
	//
	// AttributeValueList can contain only one AttributeValue of type String, Number,
	// or Binary (not a set type). If an item contains an AttributeValue element
	// of a different type than the one provided in the request, the value does
	// not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GE : Greater than or equal.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    GT : Greater than.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not equal {"N":"6"}. Also, {"N":"6"}
	// does not compare to {"NS":["6", "2", "1"]}.
	//
	//    NOT_NULL : The attribute exists. NOT_NULL is supported for all datatypes,
	// including lists and maps.
	//
	// This operator tests for the existence of an attribute, not its data type.
	// If the data type of attribute "a" is null, and you evaluate it using NOT_NULL,
	// the result is a Boolean true. This result is because the attribute "a" exists;
	// its data type is not relevant to the NOT_NULL comparison operator.
	//
	//    NULL : The attribute does not exist. NULL is supported for all datatypes,
	// including lists and maps.
	//
	// This operator tests for the nonexistence of an attribute, not its data type.
	// If the data type of attribute "a" is null, and you evaluate it using NULL,
	// the result is a Boolean false. This is because the attribute "a" exists;
	// its data type is not relevant to the NULL comparison operator.
	//
	//    CONTAINS : Checks for a subsequence, or value in a set.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If the target attribute of the comparison
	// is of type String, then the operator checks for a substring match. If the
	// target attribute of the comparison is of type Binary, then the operator looks
	// for a subsequence of the target that matches the input. If the target attribute
	// of the comparison is a set ("SS", "NS", or "BS"), then the operator evaluates
	// to true if it finds an exact match with any member of the set.
	//
	// CONTAINS is supported for lists: When evaluating "a CONTAINS b", "a" can
	// be a list; however, "b" cannot be a set, a map, or a list.
	//
	//   NOT_CONTAINS : Checks for absence of a subsequence, or absence of a value
	// in a set.
	//
	// AttributeValueList can contain only one AttributeValue element of type String,
	// Number, or Binary (not a set type). If the target attribute of the comparison
	// is a String, then the operator checks for the absence of a substring match.
	// If the target attribute of the comparison is Binary, then the operator checks
	// for the absence of a subsequence of the target that matches the input. If
	// the target attribute of the comparison is a set ("SS", "NS", or "BS"), then
	// the operator evaluates to true if it does not find an exact match with any
	// member of the set.
	//
	// NOT_CONTAINS is supported for lists: When evaluating "a NOT CONTAINS b",
	// "a" can be a list; however, "b" cannot be a set, a map, or a list.
	//
	//   BEGINS_WITH : Checks for a prefix.
	//
	// AttributeValueList can contain only one AttributeValue of type String or
	// Binary (not a Number or a set type). The target attribute of the comparison
	// must be of type String or Binary (not a Number or a set type).
	//
	//    IN : Checks for matching elements within two sets.
	//
	// AttributeValueList can contain one or more AttributeValue elements of type
	// String, Number, or Binary (not a set type). These attributes are compared
	// against an existing set type attribute of an item. If any elements of the
	// input set are present in the item attribute, the expression evaluates to
	// true.
	//
	//   BETWEEN : Greater than or equal to the first value, and less than or equal
	// to the second value.
	//
	// AttributeValueList must contain two AttributeValue elements of the same
	// type, either String, Number, or Binary (not a set type). A target attribute
	// matches if the target value is greater than, or equal to, the first element
	// and less than, or equal to, the second element. If an item contains an AttributeValue
	// element of a different type than the one provided in the request, the value
	// does not match. For example, {"S":"6"} does not compare to {"N":"6"}. Also,
	// {"N":"6"} does not compare to {"NS":["6", "2", "1"]}
	//
	//     For usage examples of AttributeValueList and ComparisonOperator, see
	// Legacy Conditional Parameters (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/LegacyConditionalParameters.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// For backward compatibility with previous DynamoDB releases, the following
	// parameters can be used instead of AttributeValueList and ComparisonOperator:
	//
	//   Value - A value for DynamoDB to compare with an attribute.
	//
	//   Exists - A Boolean value that causes DynamoDB to evaluate the value before
	// attempting the conditional operation:
	//
	//   If Exists is true, DynamoDB will check to see if that attribute value
	// already exists in the table. If it is found, then the condition evaluates
	// to true; otherwise the condition evaluate to false.
	//
	//  If Exists is false, DynamoDB assumes that the attribute value does not
	// exist in the table. If in fact the value does not exist, then the assumption
	// is valid and the condition evaluates to true. If the value is found, despite
	// the assumption that it does not exist, the condition evaluates to false.
	//
	//  Note that the default value for Exists is true.
	//
	//   The Value and Exists parameters are incompatible with AttributeValueList
	// and ComparisonOperator. Note that if you use both sets of parameters at once,
	// DynamoDB will return a ValidationException exception.
	//
	// This parameter does not support attributes of type List or Map.
	Expected map[string]*ExpectedAttributeValue `type:"map"`

	// One or more substitution tokens for attribute names in an expression. The
	// following are some use cases for using ExpressionAttributeNames:
	//
	//   To access an attribute whose name conflicts with a DynamoDB reserved word.
	//
	//   To create a placeholder for repeating occurrences of an attribute name
	// in an expression.
	//
	//   To prevent special characters in an attribute name from being misinterpreted
	// in an expression.
	//
	//   Use the # character in an expression to dereference an attribute name.
	// For example, consider the following attribute name:
	//
	// Percentile
	//
	// The name of this attribute conflicts with a reserved word, so it cannot
	// be used directly in an expression. (For the complete list of reserved words,
	// see Reserved Words (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ReservedWords.html)
	// in the Amazon DynamoDB Developer Guide). To work around this, you could specify
	// the following for ExpressionAttributeNames:
	//
	// {"#P":"Percentile"}
	//
	// You could then use this substitution in an expression, as in this example:
	//
	// #P = :val
	//
	// Tokens that begin with the : character are expression attribute values,
	// which are placeholders for the actual value at runtime.
	//
	// For more information on expression attribute names, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeNames map[string]*string `type:"map"`

	// One or more values that can be substituted in an expression.
	//
	// Use the : (colon) character in an expression to dereference an attribute
	// value. For example, suppose that you wanted to check whether the value of
	// the ProductStatus attribute was one of the following:
	//
	// Available | Backordered | Discontinued
	//
	// You would first need to specify ExpressionAttributeValues as follows:
	//
	// { ":avail":{"S":"Available"}, ":back":{"S":"Backordered"}, ":disc":{"S":"Discontinued"}
	// }
	//
	// You could then use these values in an expression, such as this:
	//
	// ProductStatus IN (:avail, :back, :disc)
	//
	// For more information on expression attribute values, see Using Placeholders
	// for Attribute Names and Values (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.ExpressionPlaceholders.html)
	// in the Amazon DynamoDB Developer Guide.
	ExpressionAttributeValues map[string]*AttributeValue `type:"map"`

	// The primary key of the item to be updated. Each element consists of an attribute
	// name and a value for that attribute.
	//
	// For the primary key, you must provide all of the attributes. For example,
	// with a hash type primary key, you only need to provide the hash attribute.
	// For a hash-and-range type primary key, you must provide both the hash attribute
	// and the range attribute.
	Key map[string]*AttributeValue `type:"map" required:"true"`

	// A value that if set to TOTAL, the response includes ConsumedCapacity data
	// for tables and indexes. If set to INDEXES, the response includes ConsumedCapacity
	// for indexes. If set to NONE (the default), ConsumedCapacity is not included
	// in the response.
	ReturnConsumedCapacity *string `type:"string"`

	// A value that if set to SIZE, the response includes statistics about item
	// collections, if any, that were modified during the operation are returned
	// in the response. If set to NONE (the default), no statistics are returned.
	ReturnItemCollectionMetrics *string `type:"string"`

	// Use ReturnValues if you want to get the item attributes as they appeared
	// either before or after they were updated. For UpdateItem, the valid values
	// are:
	//
	//   NONE - If ReturnValues is not specified, or if its value is NONE, then
	// nothing is returned. (This setting is the default for ReturnValues.)
	//
	//   ALL_OLD - If UpdateItem overwrote an attribute name-value pair, then the
	// content of the old item is returned.
	//
	//   UPDATED_OLD - The old versions of only the updated attributes are returned.
	//
	//   ALL_NEW - All of the attributes of the new version of the item are returned.
	//
	//   UPDATED_NEW - The new versions of only the updated attributes are returned.
	ReturnValues *string `type:"string"`

	// The name of the table containing the item to update.
	TableName *string `type:"string" required:"true"`

	// An expression that defines one or more attributes to be updated, the action
	// to be performed on them, and new value(s) for them.
	//
	// The following action values are available for UpdateExpression.
	//
	//   SET - Adds one or more attributes and values to an item. If any of these
	// attribute already exist, they are replaced by the new values. You can also
	// use SET to add or subtract from an attribute that is of type Number.
	//
	// SET supports the following functions:
	//
	//  if_not_exists (path, operand) - if the item does not contain an attribute
	// at the specified path, then if_not_exists evaluates to operand; otherwise,
	// it evaluates to path. You can use this function to avoid overwriting an attribute
	// that may already be present in the item.
	//
	// list_append (operand, operand) - evaluates to a list with a new element
	// added to it. You can append the new element to the start or the end of the
	// list by reversing the order of the operands.
	//
	//  These function names are case-sensitive.
	//
	//   REMOVE - Removes one or more attributes from an item.
	//
	//   ADD - Adds the specified value to the item, if the attribute does not
	// already exist. If the attribute does exist, then the behavior of ADD depends
	// on the data type of the attribute:
	//
	//   If the existing attribute is a number, and if Value is also a number,
	// then Value is mathematically added to the existing attribute. If Value is
	// a negative number, then it is subtracted from the existing attribute.
	//
	//  If you use ADD to increment or decrement a number value for an item that
	// doesn't exist before the update, DynamoDB uses 0 as the initial value.
	//
	// Similarly, if you use ADD for an existing item to increment or decrement
	// an attribute value that doesn't exist before the update, DynamoDB uses 0
	// as the initial value. For example, suppose that the item you want to update
	// doesn't have an attribute named itemcount, but you decide to ADD the number
	// 3 to this attribute anyway. DynamoDB will create the itemcount attribute,
	// set its initial value to 0, and finally add 3 to it. The result will be a
	// new itemcount attribute in the item, with a value of 3.
	//
	//    If the existing data type is a set and if Value is also a set, then Value
	// is added to the existing set. For example, if the attribute value is the
	// set [1,2], and the ADD action specified [3], then the final attribute value
	// is [1,2,3]. An error occurs if an ADD action is specified for a set attribute
	// and the attribute type specified does not match the existing set type.
	//
	// Both sets must have the same primitive data type. For example, if the existing
	// data type is a set of strings, the Value must also be a set of strings.
	//
	//   The ADD action only supports Number and set data types. In addition, ADD
	// can only be used on top-level attributes, not nested attributes.
	//
	//    DELETE - Deletes an element from a set.
	//
	// If a set of values is specified, then those values are subtracted from the
	// old set. For example, if the attribute value was the set [a,b,c] and the
	// DELETE action specifies [a,c], then the final attribute value is [b]. Specifying
	// an empty set is an error.
	//
	// The DELETE action only supports Number and set data types. In addition,
	// DELETE can only be used on top-level attributes, not nested attributes.
	//
	//    You can have many actions in a single expression, such as the following:
	// SET a=:value1, b=:value2 DELETE :value3, :value4, :value5
	//
	// For more information on update expressions, see Modifying Items and Attributes
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Expressions.Modifying.html)
	// in the Amazon DynamoDB Developer Guide.
	//
	// UpdateExpression replaces the legacy AttributeUpdates parameter.
	UpdateExpression *string `type:"string"`

	metadataUpdateItemInput `json:"-" xml:"-"`
}

type metadataUpdateItemInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of an UpdateItem operation.
type UpdateItemOutput struct {
	// A map of attribute values as they appeared before the UpdateItem operation.
	// This map only appears if ReturnValues was specified as something other than
	// NONE in the request. Each element represents one attribute.
	Attributes map[string]*AttributeValue `type:"map"`

	// The capacity units consumed by an operation. The data returned includes the
	// total provisioned throughput consumed, along with statistics for the table
	// and any indexes involved in the operation. ConsumedCapacity is only returned
	// if the request asked for it. For more information, see Provisioned Throughput
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/ProvisionedThroughputIntro.html)
	// in the Amazon DynamoDB Developer Guide.
	ConsumedCapacity *ConsumedCapacity `type:"structure"`

	// Information about item collections, if any, that were affected by the operation.
	// ItemCollectionMetrics is only returned if the request asked for it. If the
	// table does not have any local secondary indexes, this information is not
	// returned in the response.
	ItemCollectionMetrics *ItemCollectionMetrics `type:"structure"`

	metadataUpdateItemOutput `json:"-" xml:"-"`
}

type metadataUpdateItemOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the input of an UpdateTable operation.
type UpdateTableInput struct {
	// An array of attributes that describe the key schema for the table and indexes.
	// If you are adding a new global secondary index to the table, AttributeDefinitions
	// must include the key element(s) of the new index.
	AttributeDefinitions []*AttributeDefinition `type:"list"`

	// An array of one or more global secondary indexes for the table. For each
	// index in the array, you can request one action:
	//
	//  Create - add a new global secondary index to the table.
	//
	// Update - modify the provisioned throughput settings of an existing global
	// secondary index.
	//
	// Delete - remove a global secondary index from the table.
	GlobalSecondaryIndexUpdates []*GlobalSecondaryIndexUpdate `type:"list"`

	// Represents the provisioned throughput settings for a specified table or index.
	// The settings can be modified using the UpdateTable operation.
	//
	// For current minimum and maximum provisioned throughput values, see Limits
	// (http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Limits.html)
	// in the Amazon DynamoDB Developer Guide.
	ProvisionedThroughput *ProvisionedThroughput `type:"structure"`

	// The name of the table to be updated.
	TableName *string `type:"string" required:"true"`

	metadataUpdateTableInput `json:"-" xml:"-"`
}

type metadataUpdateTableInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents the output of an UpdateTable operation.
type UpdateTableOutput struct {
	// Represents the properties of a table.
	TableDescription *TableDescription `type:"structure"`

	metadataUpdateTableOutput `json:"-" xml:"-"`
}

type metadataUpdateTableOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents an operation to perform - either DeleteItem or PutItem. You can
// only request one of these operations, not both, in a single WriteRequest.
// If you do need to perform both of these operations, you will need to provide
// two separate WriteRequest objects.
type WriteRequest struct {
	// A request to perform a DeleteItem operation.
	DeleteRequest *DeleteRequest `type:"structure"`

	// A request to perform a PutItem operation.
	PutRequest *PutRequest `type:"structure"`

	metadataWriteRequest `json:"-" xml:"-"`
}

type metadataWriteRequest struct {
	SDKShapeTraits bool `type:"structure"`
}
