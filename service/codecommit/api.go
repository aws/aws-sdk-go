// Code generated by private/model/cli/gen-api/main.go. DO NOT EDIT.

package codecommit

import (
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awsutil"
	"github.com/aws/aws-sdk-go/aws/request"
	"github.com/aws/aws-sdk-go/private/protocol"
	"github.com/aws/aws-sdk-go/private/protocol/jsonrpc"
)

const opAssociateApprovalRuleTemplateWithRepository = "AssociateApprovalRuleTemplateWithRepository"

// AssociateApprovalRuleTemplateWithRepositoryRequest generates a "aws/request.Request" representing the
// client's request for the AssociateApprovalRuleTemplateWithRepository operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See AssociateApprovalRuleTemplateWithRepository for more information on using the AssociateApprovalRuleTemplateWithRepository
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the AssociateApprovalRuleTemplateWithRepositoryRequest method.
//    req, resp := client.AssociateApprovalRuleTemplateWithRepositoryRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/AssociateApprovalRuleTemplateWithRepository
func (c *CodeCommit) AssociateApprovalRuleTemplateWithRepositoryRequest(input *AssociateApprovalRuleTemplateWithRepositoryInput) (req *request.Request, output *AssociateApprovalRuleTemplateWithRepositoryOutput) {
	op := &request.Operation{
		Name:       opAssociateApprovalRuleTemplateWithRepository,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &AssociateApprovalRuleTemplateWithRepositoryInput{}
	}

	output = &AssociateApprovalRuleTemplateWithRepositoryOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// AssociateApprovalRuleTemplateWithRepository API operation for AWS CodeCommit.
//
// Creates an association between an approval rule template and a specified
// repository. Then, the next time a pull request is created in the repository
// where the destination reference (if specified) matches the destination reference
// (branch) for the pull request, an approval rule that matches the template
// conditions is automatically created for that pull request. If no destination
// references are specified in the template, an approval rule that matches the
// template contents is created for all pull requests in that repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation AssociateApprovalRuleTemplateWithRepository for usage and error information.
//
// Returned Error Types:
//   * ApprovalRuleTemplateNameRequiredException
//   An approval rule template name is required, but was not specified.
//
//   * InvalidApprovalRuleTemplateNameException
//   The name of the approval rule template is not valid. Template names must
//   be between 1 and 100 valid characters in length. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * ApprovalRuleTemplateDoesNotExistException
//   The specified approval rule template does not exist. Verify that the name
//   is correct and that you are signed in to the AWS Region where the template
//   was created, and then try again.
//
//   * MaximumRuleTemplatesAssociatedWithRepositoryException
//   The maximum number of approval rule templates for a repository has been exceeded.
//   You cannot associate more than 25 approval rule templates with a repository.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/AssociateApprovalRuleTemplateWithRepository
func (c *CodeCommit) AssociateApprovalRuleTemplateWithRepository(input *AssociateApprovalRuleTemplateWithRepositoryInput) (*AssociateApprovalRuleTemplateWithRepositoryOutput, error) {
	req, out := c.AssociateApprovalRuleTemplateWithRepositoryRequest(input)
	return out, req.Send()
}

// AssociateApprovalRuleTemplateWithRepositoryWithContext is the same as AssociateApprovalRuleTemplateWithRepository with the addition of
// the ability to pass a context and additional request options.
//
// See AssociateApprovalRuleTemplateWithRepository for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) AssociateApprovalRuleTemplateWithRepositoryWithContext(ctx aws.Context, input *AssociateApprovalRuleTemplateWithRepositoryInput, opts ...request.Option) (*AssociateApprovalRuleTemplateWithRepositoryOutput, error) {
	req, out := c.AssociateApprovalRuleTemplateWithRepositoryRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchAssociateApprovalRuleTemplateWithRepositories = "BatchAssociateApprovalRuleTemplateWithRepositories"

// BatchAssociateApprovalRuleTemplateWithRepositoriesRequest generates a "aws/request.Request" representing the
// client's request for the BatchAssociateApprovalRuleTemplateWithRepositories operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchAssociateApprovalRuleTemplateWithRepositories for more information on using the BatchAssociateApprovalRuleTemplateWithRepositories
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchAssociateApprovalRuleTemplateWithRepositoriesRequest method.
//    req, resp := client.BatchAssociateApprovalRuleTemplateWithRepositoriesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchAssociateApprovalRuleTemplateWithRepositories
func (c *CodeCommit) BatchAssociateApprovalRuleTemplateWithRepositoriesRequest(input *BatchAssociateApprovalRuleTemplateWithRepositoriesInput) (req *request.Request, output *BatchAssociateApprovalRuleTemplateWithRepositoriesOutput) {
	op := &request.Operation{
		Name:       opBatchAssociateApprovalRuleTemplateWithRepositories,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchAssociateApprovalRuleTemplateWithRepositoriesInput{}
	}

	output = &BatchAssociateApprovalRuleTemplateWithRepositoriesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchAssociateApprovalRuleTemplateWithRepositories API operation for AWS CodeCommit.
//
// Creates an association between an approval rule template and one or more
// specified repositories.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation BatchAssociateApprovalRuleTemplateWithRepositories for usage and error information.
//
// Returned Error Types:
//   * ApprovalRuleTemplateNameRequiredException
//   An approval rule template name is required, but was not specified.
//
//   * InvalidApprovalRuleTemplateNameException
//   The name of the approval rule template is not valid. Template names must
//   be between 1 and 100 valid characters in length. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * ApprovalRuleTemplateDoesNotExistException
//   The specified approval rule template does not exist. Verify that the name
//   is correct and that you are signed in to the AWS Region where the template
//   was created, and then try again.
//
//   * RepositoryNamesRequiredException
//   At least one repository name object is required, but was not specified.
//
//   * MaximumRepositoryNamesExceededException
//   The maximum number of allowed repository names was exceeded. Currently, this
//   number is 100.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchAssociateApprovalRuleTemplateWithRepositories
func (c *CodeCommit) BatchAssociateApprovalRuleTemplateWithRepositories(input *BatchAssociateApprovalRuleTemplateWithRepositoriesInput) (*BatchAssociateApprovalRuleTemplateWithRepositoriesOutput, error) {
	req, out := c.BatchAssociateApprovalRuleTemplateWithRepositoriesRequest(input)
	return out, req.Send()
}

// BatchAssociateApprovalRuleTemplateWithRepositoriesWithContext is the same as BatchAssociateApprovalRuleTemplateWithRepositories with the addition of
// the ability to pass a context and additional request options.
//
// See BatchAssociateApprovalRuleTemplateWithRepositories for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) BatchAssociateApprovalRuleTemplateWithRepositoriesWithContext(ctx aws.Context, input *BatchAssociateApprovalRuleTemplateWithRepositoriesInput, opts ...request.Option) (*BatchAssociateApprovalRuleTemplateWithRepositoriesOutput, error) {
	req, out := c.BatchAssociateApprovalRuleTemplateWithRepositoriesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchDescribeMergeConflicts = "BatchDescribeMergeConflicts"

// BatchDescribeMergeConflictsRequest generates a "aws/request.Request" representing the
// client's request for the BatchDescribeMergeConflicts operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchDescribeMergeConflicts for more information on using the BatchDescribeMergeConflicts
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchDescribeMergeConflictsRequest method.
//    req, resp := client.BatchDescribeMergeConflictsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchDescribeMergeConflicts
func (c *CodeCommit) BatchDescribeMergeConflictsRequest(input *BatchDescribeMergeConflictsInput) (req *request.Request, output *BatchDescribeMergeConflictsOutput) {
	op := &request.Operation{
		Name:       opBatchDescribeMergeConflicts,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchDescribeMergeConflictsInput{}
	}

	output = &BatchDescribeMergeConflictsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchDescribeMergeConflicts API operation for AWS CodeCommit.
//
// Returns information about one or more merge conflicts in the attempted merge
// of two commit specifiers using the squash or three-way merge strategy.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation BatchDescribeMergeConflicts for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * MergeOptionRequiredException
//   A merge option or stategy is required, and none was provided.
//
//   * InvalidMergeOptionException
//   The specified merge option is not valid for this operation. Not all merge
//   strategies are supported for all operations.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
//   * CommitRequiredException
//   A commit was not specified.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * TipsDivergenceExceededException
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * InvalidMaxConflictFilesException
//   The specified value for the number of conflict files to return is not valid.
//
//   * InvalidMaxMergeHunksException
//   The specified value for the number of merge hunks to return is not valid.
//
//   * InvalidConflictDetailLevelException
//   The specified conflict detail level is not valid.
//
//   * InvalidConflictResolutionStrategyException
//   The specified conflict resolution strategy is not valid.
//
//   * MaximumFileContentToLoadExceededException
//   The number of files to load exceeds the allowed limit.
//
//   * MaximumItemsToCompareExceededException
//   The number of items to compare between the source or destination branches
//   and the merge base has exceeded the maximum allowed.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchDescribeMergeConflicts
func (c *CodeCommit) BatchDescribeMergeConflicts(input *BatchDescribeMergeConflictsInput) (*BatchDescribeMergeConflictsOutput, error) {
	req, out := c.BatchDescribeMergeConflictsRequest(input)
	return out, req.Send()
}

// BatchDescribeMergeConflictsWithContext is the same as BatchDescribeMergeConflicts with the addition of
// the ability to pass a context and additional request options.
//
// See BatchDescribeMergeConflicts for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) BatchDescribeMergeConflictsWithContext(ctx aws.Context, input *BatchDescribeMergeConflictsInput, opts ...request.Option) (*BatchDescribeMergeConflictsOutput, error) {
	req, out := c.BatchDescribeMergeConflictsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchDisassociateApprovalRuleTemplateFromRepositories = "BatchDisassociateApprovalRuleTemplateFromRepositories"

// BatchDisassociateApprovalRuleTemplateFromRepositoriesRequest generates a "aws/request.Request" representing the
// client's request for the BatchDisassociateApprovalRuleTemplateFromRepositories operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchDisassociateApprovalRuleTemplateFromRepositories for more information on using the BatchDisassociateApprovalRuleTemplateFromRepositories
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchDisassociateApprovalRuleTemplateFromRepositoriesRequest method.
//    req, resp := client.BatchDisassociateApprovalRuleTemplateFromRepositoriesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchDisassociateApprovalRuleTemplateFromRepositories
func (c *CodeCommit) BatchDisassociateApprovalRuleTemplateFromRepositoriesRequest(input *BatchDisassociateApprovalRuleTemplateFromRepositoriesInput) (req *request.Request, output *BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput) {
	op := &request.Operation{
		Name:       opBatchDisassociateApprovalRuleTemplateFromRepositories,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchDisassociateApprovalRuleTemplateFromRepositoriesInput{}
	}

	output = &BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchDisassociateApprovalRuleTemplateFromRepositories API operation for AWS CodeCommit.
//
// Removes the association between an approval rule template and one or more
// specified repositories.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation BatchDisassociateApprovalRuleTemplateFromRepositories for usage and error information.
//
// Returned Error Types:
//   * ApprovalRuleTemplateNameRequiredException
//   An approval rule template name is required, but was not specified.
//
//   * InvalidApprovalRuleTemplateNameException
//   The name of the approval rule template is not valid. Template names must
//   be between 1 and 100 valid characters in length. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * ApprovalRuleTemplateDoesNotExistException
//   The specified approval rule template does not exist. Verify that the name
//   is correct and that you are signed in to the AWS Region where the template
//   was created, and then try again.
//
//   * RepositoryNamesRequiredException
//   At least one repository name object is required, but was not specified.
//
//   * MaximumRepositoryNamesExceededException
//   The maximum number of allowed repository names was exceeded. Currently, this
//   number is 100.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchDisassociateApprovalRuleTemplateFromRepositories
func (c *CodeCommit) BatchDisassociateApprovalRuleTemplateFromRepositories(input *BatchDisassociateApprovalRuleTemplateFromRepositoriesInput) (*BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput, error) {
	req, out := c.BatchDisassociateApprovalRuleTemplateFromRepositoriesRequest(input)
	return out, req.Send()
}

// BatchDisassociateApprovalRuleTemplateFromRepositoriesWithContext is the same as BatchDisassociateApprovalRuleTemplateFromRepositories with the addition of
// the ability to pass a context and additional request options.
//
// See BatchDisassociateApprovalRuleTemplateFromRepositories for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) BatchDisassociateApprovalRuleTemplateFromRepositoriesWithContext(ctx aws.Context, input *BatchDisassociateApprovalRuleTemplateFromRepositoriesInput, opts ...request.Option) (*BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput, error) {
	req, out := c.BatchDisassociateApprovalRuleTemplateFromRepositoriesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchGetCommits = "BatchGetCommits"

// BatchGetCommitsRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetCommits operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetCommits for more information on using the BatchGetCommits
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetCommitsRequest method.
//    req, resp := client.BatchGetCommitsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchGetCommits
func (c *CodeCommit) BatchGetCommitsRequest(input *BatchGetCommitsInput) (req *request.Request, output *BatchGetCommitsOutput) {
	op := &request.Operation{
		Name:       opBatchGetCommits,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchGetCommitsInput{}
	}

	output = &BatchGetCommitsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchGetCommits API operation for AWS CodeCommit.
//
// Returns information about the contents of one or more commits in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation BatchGetCommits for usage and error information.
//
// Returned Error Types:
//   * CommitIdsListRequiredException
//   A list of commit IDs is required, but was either not specified or the list
//   was empty.
//
//   * CommitIdsLimitExceededException
//   The maximum number of allowed commit IDs in a batch request is 100. Verify
//   that your batch requests contains no more than 100 commit IDs, and then try
//   again.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchGetCommits
func (c *CodeCommit) BatchGetCommits(input *BatchGetCommitsInput) (*BatchGetCommitsOutput, error) {
	req, out := c.BatchGetCommitsRequest(input)
	return out, req.Send()
}

// BatchGetCommitsWithContext is the same as BatchGetCommits with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetCommits for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) BatchGetCommitsWithContext(ctx aws.Context, input *BatchGetCommitsInput, opts ...request.Option) (*BatchGetCommitsOutput, error) {
	req, out := c.BatchGetCommitsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opBatchGetRepositories = "BatchGetRepositories"

// BatchGetRepositoriesRequest generates a "aws/request.Request" representing the
// client's request for the BatchGetRepositories operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See BatchGetRepositories for more information on using the BatchGetRepositories
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the BatchGetRepositoriesRequest method.
//    req, resp := client.BatchGetRepositoriesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchGetRepositories
func (c *CodeCommit) BatchGetRepositoriesRequest(input *BatchGetRepositoriesInput) (req *request.Request, output *BatchGetRepositoriesOutput) {
	op := &request.Operation{
		Name:       opBatchGetRepositories,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &BatchGetRepositoriesInput{}
	}

	output = &BatchGetRepositoriesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// BatchGetRepositories API operation for AWS CodeCommit.
//
// Returns information about one or more repositories.
//
// The description field for a repository accepts all HTML characters and all
// valid Unicode characters. Applications that do not HTML-encode the description
// and display it in a webpage can expose users to potentially malicious code.
// Make sure that you HTML-encode the description field in any application that
// uses this API to display the repository description on a webpage.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation BatchGetRepositories for usage and error information.
//
// Returned Error Types:
//   * RepositoryNamesRequiredException
//   At least one repository name object is required, but was not specified.
//
//   * MaximumRepositoryNamesExceededException
//   The maximum number of allowed repository names was exceeded. Currently, this
//   number is 100.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/BatchGetRepositories
func (c *CodeCommit) BatchGetRepositories(input *BatchGetRepositoriesInput) (*BatchGetRepositoriesOutput, error) {
	req, out := c.BatchGetRepositoriesRequest(input)
	return out, req.Send()
}

// BatchGetRepositoriesWithContext is the same as BatchGetRepositories with the addition of
// the ability to pass a context and additional request options.
//
// See BatchGetRepositories for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) BatchGetRepositoriesWithContext(ctx aws.Context, input *BatchGetRepositoriesInput, opts ...request.Option) (*BatchGetRepositoriesOutput, error) {
	req, out := c.BatchGetRepositoriesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateApprovalRuleTemplate = "CreateApprovalRuleTemplate"

// CreateApprovalRuleTemplateRequest generates a "aws/request.Request" representing the
// client's request for the CreateApprovalRuleTemplate operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateApprovalRuleTemplate for more information on using the CreateApprovalRuleTemplate
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateApprovalRuleTemplateRequest method.
//    req, resp := client.CreateApprovalRuleTemplateRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateApprovalRuleTemplate
func (c *CodeCommit) CreateApprovalRuleTemplateRequest(input *CreateApprovalRuleTemplateInput) (req *request.Request, output *CreateApprovalRuleTemplateOutput) {
	op := &request.Operation{
		Name:       opCreateApprovalRuleTemplate,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateApprovalRuleTemplateInput{}
	}

	output = &CreateApprovalRuleTemplateOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateApprovalRuleTemplate API operation for AWS CodeCommit.
//
// Creates a template for approval rules that can then be associated with one
// or more repositories in your AWS account. When you associate a template with
// a repository, AWS CodeCommit creates an approval rule that matches the conditions
// of the template for all pull requests that meet the conditions of the template.
// For more information, see AssociateApprovalRuleTemplateWithRepository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreateApprovalRuleTemplate for usage and error information.
//
// Returned Error Types:
//   * ApprovalRuleTemplateNameRequiredException
//   An approval rule template name is required, but was not specified.
//
//   * InvalidApprovalRuleTemplateNameException
//   The name of the approval rule template is not valid. Template names must
//   be between 1 and 100 valid characters in length. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * ApprovalRuleTemplateNameAlreadyExistsException
//   You cannot create an approval rule template with that name because a template
//   with that name already exists in this AWS Region for your AWS account. Approval
//   rule template names must be unique.
//
//   * ApprovalRuleTemplateContentRequiredException
//   The content for the approval rule template is empty. You must provide some
//   content for an approval rule template. The content cannot be null.
//
//   * InvalidApprovalRuleTemplateContentException
//   The content of the approval rule template is not valid.
//
//   * InvalidApprovalRuleTemplateDescriptionException
//   The description for the approval rule template is not valid because it exceeds
//   the maximum characters allowed for a description. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * NumberOfRuleTemplatesExceededException
//   The maximum number of approval rule templates has been exceeded for this
//   AWS Region.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateApprovalRuleTemplate
func (c *CodeCommit) CreateApprovalRuleTemplate(input *CreateApprovalRuleTemplateInput) (*CreateApprovalRuleTemplateOutput, error) {
	req, out := c.CreateApprovalRuleTemplateRequest(input)
	return out, req.Send()
}

// CreateApprovalRuleTemplateWithContext is the same as CreateApprovalRuleTemplate with the addition of
// the ability to pass a context and additional request options.
//
// See CreateApprovalRuleTemplate for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreateApprovalRuleTemplateWithContext(ctx aws.Context, input *CreateApprovalRuleTemplateInput, opts ...request.Option) (*CreateApprovalRuleTemplateOutput, error) {
	req, out := c.CreateApprovalRuleTemplateRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateBranch = "CreateBranch"

// CreateBranchRequest generates a "aws/request.Request" representing the
// client's request for the CreateBranch operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateBranch for more information on using the CreateBranch
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateBranchRequest method.
//    req, resp := client.CreateBranchRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateBranch
func (c *CodeCommit) CreateBranchRequest(input *CreateBranchInput) (req *request.Request, output *CreateBranchOutput) {
	op := &request.Operation{
		Name:       opCreateBranch,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateBranchInput{}
	}

	output = &CreateBranchOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// CreateBranch API operation for AWS CodeCommit.
//
// Creates a branch in a repository and points the branch to a commit.
//
// Calling the create branch operation does not set a repository's default branch.
// To do this, call the update default branch operation.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreateBranch for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * BranchNameRequiredException
//   A branch name is required, but was not specified.
//
//   * BranchNameExistsException
//   Cannot create the branch with the specified name because the commit conflicts
//   with an existing branch with the same name. Branch names must be unique.
//
//   * InvalidBranchNameException
//   The specified reference name is not valid.
//
//   * CommitIdRequiredException
//   A commit ID was not specified.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidCommitIdException
//   The specified commit ID is not valid.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateBranch
func (c *CodeCommit) CreateBranch(input *CreateBranchInput) (*CreateBranchOutput, error) {
	req, out := c.CreateBranchRequest(input)
	return out, req.Send()
}

// CreateBranchWithContext is the same as CreateBranch with the addition of
// the ability to pass a context and additional request options.
//
// See CreateBranch for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreateBranchWithContext(ctx aws.Context, input *CreateBranchInput, opts ...request.Option) (*CreateBranchOutput, error) {
	req, out := c.CreateBranchRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateCommit = "CreateCommit"

// CreateCommitRequest generates a "aws/request.Request" representing the
// client's request for the CreateCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateCommit for more information on using the CreateCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateCommitRequest method.
//    req, resp := client.CreateCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateCommit
func (c *CodeCommit) CreateCommitRequest(input *CreateCommitInput) (req *request.Request, output *CreateCommitOutput) {
	op := &request.Operation{
		Name:       opCreateCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateCommitInput{}
	}

	output = &CreateCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateCommit API operation for AWS CodeCommit.
//
// Creates a commit for a repository on the tip of a specified branch.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreateCommit for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * ParentCommitIdRequiredException
//   A parent commit ID is required. To view the full commit ID of a branch in
//   a repository, use GetBranch or a Git command (for example, git pull or git
//   log).
//
//   * InvalidParentCommitIdException
//   The parent commit ID is not valid. The commit ID cannot be empty, and must
//   match the head commit ID for the branch of the repository where you want
//   to add or update a file.
//
//   * ParentCommitDoesNotExistException
//   The parent commit ID is not valid because it does not exist. The specified
//   parent commit ID does not exist in the specified branch of the repository.
//
//   * ParentCommitIdOutdatedException
//   The file could not be added because the provided parent commit ID is not
//   the current tip of the specified branch. To view the full commit ID of the
//   current head of the branch, use GetBranch.
//
//   * BranchNameRequiredException
//   A branch name is required, but was not specified.
//
//   * InvalidBranchNameException
//   The specified reference name is not valid.
//
//   * BranchDoesNotExistException
//   The specified branch does not exist.
//
//   * BranchNameIsTagNameException
//   The specified branch name is not valid because it is a tag name. Enter the
//   name of a branch in the repository. For a list of valid branch names, use
//   ListBranches.
//
//   * FileEntryRequiredException
//   The commit cannot be created because no files have been specified as added,
//   updated, or changed (PutFile or DeleteFile) for the commit.
//
//   * MaximumFileEntriesExceededException
//   The number of specified files to change as part of this commit exceeds the
//   maximum number of files that can be changed in a single commit. Consider
//   using a Git client for these changes.
//
//   * PutFileEntryConflictException
//   The commit cannot be created because one or more files specified in the commit
//   reference both a file and a folder.
//
//   * SourceFileOrContentRequiredException
//   The commit cannot be created because no source files or file content have
//   been specified for the commit.
//
//   * FileContentAndSourceFileSpecifiedException
//   The commit cannot be created because both a source file and file content
//   have been specified for the same file. You cannot provide both. Either specify
//   a source file or provide the file content directly.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * SamePathRequestException
//   The commit cannot be created because one or more changes in this commit duplicate
//   actions in the same file path. For example, you cannot make the same delete
//   request to the same file in the same file path twice, or make a delete request
//   and a move request to the same file as part of the same commit.
//
//   * FileDoesNotExistException
//   The specified file does not exist. Verify that you have used the correct
//   file name, full path, and extension.
//
//   * FileContentSizeLimitExceededException
//   The file cannot be added because it is too large. The maximum file size is
//   6 MB, and the combined file content change size is 7 MB. Consider making
//   these changes using a Git client.
//
//   * FolderContentSizeLimitExceededException
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * InvalidDeletionParameterException
//   The specified deletion parameter is not valid.
//
//   * RestrictedSourceFileException
//   The commit cannot be created because one of the changes specifies copying
//   or moving a .gitkeep file.
//
//   * FileModeRequiredException
//   The commit cannot be created because no file mode has been specified. A file
//   mode is required to update mode permissions for a file.
//
//   * InvalidFileModeException
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * NameLengthExceededException
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * InvalidEmailException
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * CommitMessageLengthExceededException
//   The commit message is too long. Provide a shorter string.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
//   * NoChangeException
//   The commit cannot be created because no changes will be made to the repository
//   as a result of this commit. A commit must contain at least one change.
//
//   * FileNameConflictsWithDirectoryNameException
//   A file cannot be added to the repository because the specified file name
//   has the same name as a directory in this repository. Either provide another
//   name for the file, or add the file in a directory that does not match the
//   file name.
//
//   * DirectoryNameConflictsWithFileNameException
//   A file cannot be added to the repository because the specified path name
//   has the same name as a file that already exists in this repository. Either
//   provide a different name for the file, or specify a different path for the
//   file.
//
//   * FilePathConflictsWithSubmodulePathException
//   The commit cannot be created because a specified file path points to a submodule.
//   Verify that the destination files have valid file paths that do not point
//   to a submodule.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateCommit
func (c *CodeCommit) CreateCommit(input *CreateCommitInput) (*CreateCommitOutput, error) {
	req, out := c.CreateCommitRequest(input)
	return out, req.Send()
}

// CreateCommitWithContext is the same as CreateCommit with the addition of
// the ability to pass a context and additional request options.
//
// See CreateCommit for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreateCommitWithContext(ctx aws.Context, input *CreateCommitInput, opts ...request.Option) (*CreateCommitOutput, error) {
	req, out := c.CreateCommitRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreatePullRequest = "CreatePullRequest"

// CreatePullRequestRequest generates a "aws/request.Request" representing the
// client's request for the CreatePullRequest operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreatePullRequest for more information on using the CreatePullRequest
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreatePullRequestRequest method.
//    req, resp := client.CreatePullRequestRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreatePullRequest
func (c *CodeCommit) CreatePullRequestRequest(input *CreatePullRequestInput) (req *request.Request, output *CreatePullRequestOutput) {
	op := &request.Operation{
		Name:       opCreatePullRequest,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreatePullRequestInput{}
	}

	output = &CreatePullRequestOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreatePullRequest API operation for AWS CodeCommit.
//
// Creates a pull request in the specified repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreatePullRequest for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
//   * ClientRequestTokenRequiredException
//   A client request token is required. A client request token is an unique,
//   client-generated idempotency token that, when provided in a request, ensures
//   the request cannot be repeated with a changed parameter. If a request is
//   received with the same parameters and a token is included, the request returns
//   information about the initial request that used that token.
//
//   * InvalidClientRequestTokenException
//   The client request token is not valid.
//
//   * IdempotencyParameterMismatchException
//   The client request token is not valid. Either the token is not in a valid
//   format, or the token has been used in a previous request and cannot be reused.
//
//   * ReferenceNameRequiredException
//   A reference name is required, but none was provided.
//
//   * InvalidReferenceNameException
//   The specified reference name format is not valid. Reference names must conform
//   to the Git references format (for example, refs/heads/master). For more information,
//   see Git Internals - Git References (https://git-scm.com/book/en/v2/Git-Internals-Git-References)
//   or consult your Git documentation.
//
//   * ReferenceDoesNotExistException
//   The specified reference does not exist. You must provide a full commit ID.
//
//   * ReferenceTypeNotSupportedException
//   The specified reference is not a supported type.
//
//   * TitleRequiredException
//   A pull request title is required. It cannot be empty or null.
//
//   * InvalidTitleException
//   The title of the pull request is not valid. Pull request titles cannot exceed
//   100 characters in length.
//
//   * InvalidDescriptionException
//   The pull request description is not valid. Descriptions cannot be more than
//   1,000 characters.
//
//   * TargetsRequiredException
//   An array of target objects is required. It cannot be empty or null.
//
//   * InvalidTargetsException
//   The targets for the pull request is not valid or not in a valid format. Targets
//   are a list of target objects. Each target object must contain the full values
//   for the repository name, source branch, and destination branch for a pull
//   request.
//
//   * TargetRequiredException
//   A pull request target is required. It cannot be empty or null. A pull request
//   target must contain the full values for the repository name, source branch,
//   and destination branch for the pull request.
//
//   * InvalidTargetException
//   The target for the pull request is not valid. A target must contain the full
//   values for the repository name, source branch, and destination branch for
//   the pull request.
//
//   * MultipleRepositoriesInPullRequestException
//   You cannot include more than one repository in a pull request. Make sure
//   you have specified only one repository name in your request, and then try
//   again.
//
//   * MaximumOpenPullRequestsExceededException
//   You cannot create the pull request because the repository has too many open
//   pull requests. The maximum number of open pull requests for a repository
//   is 1,000. Close one or more open pull requests, and then try again.
//
//   * SourceAndDestinationAreSameException
//   The source branch and destination branch for the pull request are the same.
//   You must specify different branches for the source and destination.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreatePullRequest
func (c *CodeCommit) CreatePullRequest(input *CreatePullRequestInput) (*CreatePullRequestOutput, error) {
	req, out := c.CreatePullRequestRequest(input)
	return out, req.Send()
}

// CreatePullRequestWithContext is the same as CreatePullRequest with the addition of
// the ability to pass a context and additional request options.
//
// See CreatePullRequest for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreatePullRequestWithContext(ctx aws.Context, input *CreatePullRequestInput, opts ...request.Option) (*CreatePullRequestOutput, error) {
	req, out := c.CreatePullRequestRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreatePullRequestApprovalRule = "CreatePullRequestApprovalRule"

// CreatePullRequestApprovalRuleRequest generates a "aws/request.Request" representing the
// client's request for the CreatePullRequestApprovalRule operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreatePullRequestApprovalRule for more information on using the CreatePullRequestApprovalRule
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreatePullRequestApprovalRuleRequest method.
//    req, resp := client.CreatePullRequestApprovalRuleRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreatePullRequestApprovalRule
func (c *CodeCommit) CreatePullRequestApprovalRuleRequest(input *CreatePullRequestApprovalRuleInput) (req *request.Request, output *CreatePullRequestApprovalRuleOutput) {
	op := &request.Operation{
		Name:       opCreatePullRequestApprovalRule,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreatePullRequestApprovalRuleInput{}
	}

	output = &CreatePullRequestApprovalRuleOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreatePullRequestApprovalRule API operation for AWS CodeCommit.
//
// Creates an approval rule for a pull request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreatePullRequestApprovalRule for usage and error information.
//
// Returned Error Types:
//   * ApprovalRuleNameRequiredException
//   An approval rule name is required, but was not specified.
//
//   * InvalidApprovalRuleNameException
//   The name for the approval rule is not valid.
//
//   * ApprovalRuleNameAlreadyExistsException
//   An approval rule with that name already exists. Approval rule names must
//   be unique within the scope of a pull request.
//
//   * ApprovalRuleContentRequiredException
//   The content for the approval rule is empty. You must provide some content
//   for an approval rule. The content cannot be null.
//
//   * InvalidApprovalRuleContentException
//   The content for the approval rule is not valid.
//
//   * NumberOfRulesExceededException
//   The approval rule cannot be added. The pull request has the maximum number
//   of approval rules associated with it.
//
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * PullRequestAlreadyClosedException
//   The pull request status cannot be updated because it is already closed.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreatePullRequestApprovalRule
func (c *CodeCommit) CreatePullRequestApprovalRule(input *CreatePullRequestApprovalRuleInput) (*CreatePullRequestApprovalRuleOutput, error) {
	req, out := c.CreatePullRequestApprovalRuleRequest(input)
	return out, req.Send()
}

// CreatePullRequestApprovalRuleWithContext is the same as CreatePullRequestApprovalRule with the addition of
// the ability to pass a context and additional request options.
//
// See CreatePullRequestApprovalRule for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreatePullRequestApprovalRuleWithContext(ctx aws.Context, input *CreatePullRequestApprovalRuleInput, opts ...request.Option) (*CreatePullRequestApprovalRuleOutput, error) {
	req, out := c.CreatePullRequestApprovalRuleRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateRepository = "CreateRepository"

// CreateRepositoryRequest generates a "aws/request.Request" representing the
// client's request for the CreateRepository operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateRepository for more information on using the CreateRepository
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateRepositoryRequest method.
//    req, resp := client.CreateRepositoryRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateRepository
func (c *CodeCommit) CreateRepositoryRequest(input *CreateRepositoryInput) (req *request.Request, output *CreateRepositoryOutput) {
	op := &request.Operation{
		Name:       opCreateRepository,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateRepositoryInput{}
	}

	output = &CreateRepositoryOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateRepository API operation for AWS CodeCommit.
//
// Creates a new, empty repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreateRepository for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameExistsException
//   The specified repository name already exists.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * InvalidRepositoryDescriptionException
//   The specified repository description is not valid.
//
//   * RepositoryLimitExceededException
//   A repository resource limit was exceeded.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
//   * InvalidTagsMapException
//   The map of tags is not valid.
//
//   * TooManyTagsException
//   The maximum number of tags for an AWS CodeCommit resource has been exceeded.
//
//   * InvalidSystemTagUsageException
//   The specified tag is not valid. Key names cannot be prefixed with aws:.
//
//   * TagPolicyException
//   The tag policy is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateRepository
func (c *CodeCommit) CreateRepository(input *CreateRepositoryInput) (*CreateRepositoryOutput, error) {
	req, out := c.CreateRepositoryRequest(input)
	return out, req.Send()
}

// CreateRepositoryWithContext is the same as CreateRepository with the addition of
// the ability to pass a context and additional request options.
//
// See CreateRepository for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreateRepositoryWithContext(ctx aws.Context, input *CreateRepositoryInput, opts ...request.Option) (*CreateRepositoryOutput, error) {
	req, out := c.CreateRepositoryRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opCreateUnreferencedMergeCommit = "CreateUnreferencedMergeCommit"

// CreateUnreferencedMergeCommitRequest generates a "aws/request.Request" representing the
// client's request for the CreateUnreferencedMergeCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See CreateUnreferencedMergeCommit for more information on using the CreateUnreferencedMergeCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the CreateUnreferencedMergeCommitRequest method.
//    req, resp := client.CreateUnreferencedMergeCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateUnreferencedMergeCommit
func (c *CodeCommit) CreateUnreferencedMergeCommitRequest(input *CreateUnreferencedMergeCommitInput) (req *request.Request, output *CreateUnreferencedMergeCommitOutput) {
	op := &request.Operation{
		Name:       opCreateUnreferencedMergeCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &CreateUnreferencedMergeCommitInput{}
	}

	output = &CreateUnreferencedMergeCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// CreateUnreferencedMergeCommit API operation for AWS CodeCommit.
//
// Creates an unreferenced commit that represents the result of merging two
// branches using a specified merge strategy. This can help you determine the
// outcome of a potential merge. This API cannot be used with the fast-forward
// merge strategy because that strategy does not create a merge commit.
//
// This unreferenced merge commit can only be accessed using the GetCommit API
// or through git commands such as git fetch. To retrieve this commit, you must
// specify its commit ID or otherwise reference it.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation CreateUnreferencedMergeCommit for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * TipsDivergenceExceededException
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * CommitRequiredException
//   A commit was not specified.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * MergeOptionRequiredException
//   A merge option or stategy is required, and none was provided.
//
//   * InvalidMergeOptionException
//   The specified merge option is not valid for this operation. Not all merge
//   strategies are supported for all operations.
//
//   * InvalidConflictDetailLevelException
//   The specified conflict detail level is not valid.
//
//   * InvalidConflictResolutionStrategyException
//   The specified conflict resolution strategy is not valid.
//
//   * InvalidConflictResolutionException
//   The specified conflict resolution list is not valid.
//
//   * ManualMergeRequiredException
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * MaximumConflictResolutionEntriesExceededException
//   The number of allowed conflict resolution entries was exceeded.
//
//   * MultipleConflictResolutionEntriesException
//   More than one conflict resolution entries exists for the conflict. A conflict
//   can have only one conflict resolution entry.
//
//   * ReplacementTypeRequiredException
//   A replacement type is required.
//
//   * InvalidReplacementTypeException
//   Automerge was specified for resolving the conflict, but the specified replacement
//   type is not valid.
//
//   * ReplacementContentRequiredException
//   USE_NEW_CONTENT was specified, but no replacement content has been provided.
//
//   * InvalidReplacementContentException
//   Automerge was specified for resolving the conflict, but the replacement type
//   is not valid or content is missing.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * FileContentSizeLimitExceededException
//   The file cannot be added because it is too large. The maximum file size is
//   6 MB, and the combined file content change size is 7 MB. Consider making
//   these changes using a Git client.
//
//   * FolderContentSizeLimitExceededException
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * MaximumFileContentToLoadExceededException
//   The number of files to load exceeds the allowed limit.
//
//   * MaximumItemsToCompareExceededException
//   The number of items to compare between the source or destination branches
//   and the merge base has exceeded the maximum allowed.
//
//   * ConcurrentReferenceUpdateException
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * FileModeRequiredException
//   The commit cannot be created because no file mode has been specified. A file
//   mode is required to update mode permissions for a file.
//
//   * InvalidFileModeException
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * NameLengthExceededException
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * InvalidEmailException
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * CommitMessageLengthExceededException
//   The commit message is too long. Provide a shorter string.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/CreateUnreferencedMergeCommit
func (c *CodeCommit) CreateUnreferencedMergeCommit(input *CreateUnreferencedMergeCommitInput) (*CreateUnreferencedMergeCommitOutput, error) {
	req, out := c.CreateUnreferencedMergeCommitRequest(input)
	return out, req.Send()
}

// CreateUnreferencedMergeCommitWithContext is the same as CreateUnreferencedMergeCommit with the addition of
// the ability to pass a context and additional request options.
//
// See CreateUnreferencedMergeCommit for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) CreateUnreferencedMergeCommitWithContext(ctx aws.Context, input *CreateUnreferencedMergeCommitInput, opts ...request.Option) (*CreateUnreferencedMergeCommitOutput, error) {
	req, out := c.CreateUnreferencedMergeCommitRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteApprovalRuleTemplate = "DeleteApprovalRuleTemplate"

// DeleteApprovalRuleTemplateRequest generates a "aws/request.Request" representing the
// client's request for the DeleteApprovalRuleTemplate operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteApprovalRuleTemplate for more information on using the DeleteApprovalRuleTemplate
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteApprovalRuleTemplateRequest method.
//    req, resp := client.DeleteApprovalRuleTemplateRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteApprovalRuleTemplate
func (c *CodeCommit) DeleteApprovalRuleTemplateRequest(input *DeleteApprovalRuleTemplateInput) (req *request.Request, output *DeleteApprovalRuleTemplateOutput) {
	op := &request.Operation{
		Name:       opDeleteApprovalRuleTemplate,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteApprovalRuleTemplateInput{}
	}

	output = &DeleteApprovalRuleTemplateOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteApprovalRuleTemplate API operation for AWS CodeCommit.
//
// Deletes a specified approval rule template. Deleting a template does not
// remove approval rules on pull requests already created with the template.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DeleteApprovalRuleTemplate for usage and error information.
//
// Returned Error Types:
//   * ApprovalRuleTemplateNameRequiredException
//   An approval rule template name is required, but was not specified.
//
//   * InvalidApprovalRuleTemplateNameException
//   The name of the approval rule template is not valid. Template names must
//   be between 1 and 100 valid characters in length. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * ApprovalRuleTemplateInUseException
//   The approval rule template is associated with one or more repositories. You
//   cannot delete a template that is associated with a repository. Remove all
//   associations, and then try again.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteApprovalRuleTemplate
func (c *CodeCommit) DeleteApprovalRuleTemplate(input *DeleteApprovalRuleTemplateInput) (*DeleteApprovalRuleTemplateOutput, error) {
	req, out := c.DeleteApprovalRuleTemplateRequest(input)
	return out, req.Send()
}

// DeleteApprovalRuleTemplateWithContext is the same as DeleteApprovalRuleTemplate with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteApprovalRuleTemplate for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DeleteApprovalRuleTemplateWithContext(ctx aws.Context, input *DeleteApprovalRuleTemplateInput, opts ...request.Option) (*DeleteApprovalRuleTemplateOutput, error) {
	req, out := c.DeleteApprovalRuleTemplateRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteBranch = "DeleteBranch"

// DeleteBranchRequest generates a "aws/request.Request" representing the
// client's request for the DeleteBranch operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteBranch for more information on using the DeleteBranch
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteBranchRequest method.
//    req, resp := client.DeleteBranchRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteBranch
func (c *CodeCommit) DeleteBranchRequest(input *DeleteBranchInput) (req *request.Request, output *DeleteBranchOutput) {
	op := &request.Operation{
		Name:       opDeleteBranch,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteBranchInput{}
	}

	output = &DeleteBranchOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteBranch API operation for AWS CodeCommit.
//
// Deletes a branch from a repository, unless that branch is the default branch
// for the repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DeleteBranch for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * BranchNameRequiredException
//   A branch name is required, but was not specified.
//
//   * InvalidBranchNameException
//   The specified reference name is not valid.
//
//   * DefaultBranchCannotBeDeletedException
//   The specified branch is the default branch for the repository, and cannot
//   be deleted. To delete this branch, you must first set another branch as the
//   default branch.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteBranch
func (c *CodeCommit) DeleteBranch(input *DeleteBranchInput) (*DeleteBranchOutput, error) {
	req, out := c.DeleteBranchRequest(input)
	return out, req.Send()
}

// DeleteBranchWithContext is the same as DeleteBranch with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteBranch for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DeleteBranchWithContext(ctx aws.Context, input *DeleteBranchInput, opts ...request.Option) (*DeleteBranchOutput, error) {
	req, out := c.DeleteBranchRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteCommentContent = "DeleteCommentContent"

// DeleteCommentContentRequest generates a "aws/request.Request" representing the
// client's request for the DeleteCommentContent operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteCommentContent for more information on using the DeleteCommentContent
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteCommentContentRequest method.
//    req, resp := client.DeleteCommentContentRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteCommentContent
func (c *CodeCommit) DeleteCommentContentRequest(input *DeleteCommentContentInput) (req *request.Request, output *DeleteCommentContentOutput) {
	op := &request.Operation{
		Name:       opDeleteCommentContent,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteCommentContentInput{}
	}

	output = &DeleteCommentContentOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteCommentContent API operation for AWS CodeCommit.
//
// Deletes the content of a comment made on a change, file, or commit in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DeleteCommentContent for usage and error information.
//
// Returned Error Types:
//   * CommentDoesNotExistException
//   No comment exists with the provided ID. Verify that you have used the correct
//   ID, and then try again.
//
//   * CommentIdRequiredException
//   The comment ID is missing or null. A comment ID is required.
//
//   * InvalidCommentIdException
//   The comment ID is not in a valid format. Make sure that you have provided
//   the full comment ID.
//
//   * CommentDeletedException
//   This comment has already been deleted. You cannot edit or delete a deleted
//   comment.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteCommentContent
func (c *CodeCommit) DeleteCommentContent(input *DeleteCommentContentInput) (*DeleteCommentContentOutput, error) {
	req, out := c.DeleteCommentContentRequest(input)
	return out, req.Send()
}

// DeleteCommentContentWithContext is the same as DeleteCommentContent with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteCommentContent for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DeleteCommentContentWithContext(ctx aws.Context, input *DeleteCommentContentInput, opts ...request.Option) (*DeleteCommentContentOutput, error) {
	req, out := c.DeleteCommentContentRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteFile = "DeleteFile"

// DeleteFileRequest generates a "aws/request.Request" representing the
// client's request for the DeleteFile operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteFile for more information on using the DeleteFile
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteFileRequest method.
//    req, resp := client.DeleteFileRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteFile
func (c *CodeCommit) DeleteFileRequest(input *DeleteFileInput) (req *request.Request, output *DeleteFileOutput) {
	op := &request.Operation{
		Name:       opDeleteFile,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteFileInput{}
	}

	output = &DeleteFileOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteFile API operation for AWS CodeCommit.
//
// Deletes a specified file from a specified branch. A commit is created on
// the branch that contains the revision. The file still exists in the commits
// earlier to the commit that contains the deletion.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DeleteFile for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * ParentCommitIdRequiredException
//   A parent commit ID is required. To view the full commit ID of a branch in
//   a repository, use GetBranch or a Git command (for example, git pull or git
//   log).
//
//   * InvalidParentCommitIdException
//   The parent commit ID is not valid. The commit ID cannot be empty, and must
//   match the head commit ID for the branch of the repository where you want
//   to add or update a file.
//
//   * ParentCommitDoesNotExistException
//   The parent commit ID is not valid because it does not exist. The specified
//   parent commit ID does not exist in the specified branch of the repository.
//
//   * ParentCommitIdOutdatedException
//   The file could not be added because the provided parent commit ID is not
//   the current tip of the specified branch. To view the full commit ID of the
//   current head of the branch, use GetBranch.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * FileDoesNotExistException
//   The specified file does not exist. Verify that you have used the correct
//   file name, full path, and extension.
//
//   * BranchNameRequiredException
//   A branch name is required, but was not specified.
//
//   * InvalidBranchNameException
//   The specified reference name is not valid.
//
//   * BranchDoesNotExistException
//   The specified branch does not exist.
//
//   * BranchNameIsTagNameException
//   The specified branch name is not valid because it is a tag name. Enter the
//   name of a branch in the repository. For a list of valid branch names, use
//   ListBranches.
//
//   * NameLengthExceededException
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * InvalidEmailException
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * CommitMessageLengthExceededException
//   The commit message is too long. Provide a shorter string.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteFile
func (c *CodeCommit) DeleteFile(input *DeleteFileInput) (*DeleteFileOutput, error) {
	req, out := c.DeleteFileRequest(input)
	return out, req.Send()
}

// DeleteFileWithContext is the same as DeleteFile with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteFile for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DeleteFileWithContext(ctx aws.Context, input *DeleteFileInput, opts ...request.Option) (*DeleteFileOutput, error) {
	req, out := c.DeleteFileRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeletePullRequestApprovalRule = "DeletePullRequestApprovalRule"

// DeletePullRequestApprovalRuleRequest generates a "aws/request.Request" representing the
// client's request for the DeletePullRequestApprovalRule operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeletePullRequestApprovalRule for more information on using the DeletePullRequestApprovalRule
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeletePullRequestApprovalRuleRequest method.
//    req, resp := client.DeletePullRequestApprovalRuleRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeletePullRequestApprovalRule
func (c *CodeCommit) DeletePullRequestApprovalRuleRequest(input *DeletePullRequestApprovalRuleInput) (req *request.Request, output *DeletePullRequestApprovalRuleOutput) {
	op := &request.Operation{
		Name:       opDeletePullRequestApprovalRule,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeletePullRequestApprovalRuleInput{}
	}

	output = &DeletePullRequestApprovalRuleOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeletePullRequestApprovalRule API operation for AWS CodeCommit.
//
// Deletes an approval rule from a specified pull request. Approval rules can
// be deleted from a pull request only if the pull request is open, and if the
// approval rule was created specifically for a pull request and not generated
// from an approval rule template associated with the repository where the pull
// request was created. You cannot delete an approval rule from a merged or
// closed pull request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DeletePullRequestApprovalRule for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * PullRequestAlreadyClosedException
//   The pull request status cannot be updated because it is already closed.
//
//   * ApprovalRuleNameRequiredException
//   An approval rule name is required, but was not specified.
//
//   * InvalidApprovalRuleNameException
//   The name for the approval rule is not valid.
//
//   * CannotDeleteApprovalRuleFromTemplateException
//   The approval rule cannot be deleted from the pull request because it was
//   created by an approval rule template and applied to the pull request automatically.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeletePullRequestApprovalRule
func (c *CodeCommit) DeletePullRequestApprovalRule(input *DeletePullRequestApprovalRuleInput) (*DeletePullRequestApprovalRuleOutput, error) {
	req, out := c.DeletePullRequestApprovalRuleRequest(input)
	return out, req.Send()
}

// DeletePullRequestApprovalRuleWithContext is the same as DeletePullRequestApprovalRule with the addition of
// the ability to pass a context and additional request options.
//
// See DeletePullRequestApprovalRule for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DeletePullRequestApprovalRuleWithContext(ctx aws.Context, input *DeletePullRequestApprovalRuleInput, opts ...request.Option) (*DeletePullRequestApprovalRuleOutput, error) {
	req, out := c.DeletePullRequestApprovalRuleRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDeleteRepository = "DeleteRepository"

// DeleteRepositoryRequest generates a "aws/request.Request" representing the
// client's request for the DeleteRepository operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DeleteRepository for more information on using the DeleteRepository
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DeleteRepositoryRequest method.
//    req, resp := client.DeleteRepositoryRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteRepository
func (c *CodeCommit) DeleteRepositoryRequest(input *DeleteRepositoryInput) (req *request.Request, output *DeleteRepositoryOutput) {
	op := &request.Operation{
		Name:       opDeleteRepository,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DeleteRepositoryInput{}
	}

	output = &DeleteRepositoryOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DeleteRepository API operation for AWS CodeCommit.
//
// Deletes a repository. If a specified repository was already deleted, a null
// repository ID is returned.
//
// Deleting a repository also deletes all associated objects and metadata. After
// a repository is deleted, all future push calls to the deleted repository
// fail.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DeleteRepository for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DeleteRepository
func (c *CodeCommit) DeleteRepository(input *DeleteRepositoryInput) (*DeleteRepositoryOutput, error) {
	req, out := c.DeleteRepositoryRequest(input)
	return out, req.Send()
}

// DeleteRepositoryWithContext is the same as DeleteRepository with the addition of
// the ability to pass a context and additional request options.
//
// See DeleteRepository for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DeleteRepositoryWithContext(ctx aws.Context, input *DeleteRepositoryInput, opts ...request.Option) (*DeleteRepositoryOutput, error) {
	req, out := c.DeleteRepositoryRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opDescribeMergeConflicts = "DescribeMergeConflicts"

// DescribeMergeConflictsRequest generates a "aws/request.Request" representing the
// client's request for the DescribeMergeConflicts operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribeMergeConflicts for more information on using the DescribeMergeConflicts
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribeMergeConflictsRequest method.
//    req, resp := client.DescribeMergeConflictsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DescribeMergeConflicts
func (c *CodeCommit) DescribeMergeConflictsRequest(input *DescribeMergeConflictsInput) (req *request.Request, output *DescribeMergeConflictsOutput) {
	op := &request.Operation{
		Name:       opDescribeMergeConflicts,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxMergeHunks",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribeMergeConflictsInput{}
	}

	output = &DescribeMergeConflictsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DescribeMergeConflicts API operation for AWS CodeCommit.
//
// Returns information about one or more merge conflicts in the attempted merge
// of two commit specifiers using the squash or three-way merge strategy. If
// the merge option for the attempted merge is specified as FAST_FORWARD_MERGE,
// an exception is thrown.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DescribeMergeConflicts for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * MergeOptionRequiredException
//   A merge option or stategy is required, and none was provided.
//
//   * InvalidMergeOptionException
//   The specified merge option is not valid for this operation. Not all merge
//   strategies are supported for all operations.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
//   * CommitRequiredException
//   A commit was not specified.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * TipsDivergenceExceededException
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * FileDoesNotExistException
//   The specified file does not exist. Verify that you have used the correct
//   file name, full path, and extension.
//
//   * InvalidMaxMergeHunksException
//   The specified value for the number of merge hunks to return is not valid.
//
//   * InvalidConflictDetailLevelException
//   The specified conflict detail level is not valid.
//
//   * InvalidConflictResolutionStrategyException
//   The specified conflict resolution strategy is not valid.
//
//   * MaximumFileContentToLoadExceededException
//   The number of files to load exceeds the allowed limit.
//
//   * MaximumItemsToCompareExceededException
//   The number of items to compare between the source or destination branches
//   and the merge base has exceeded the maximum allowed.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DescribeMergeConflicts
func (c *CodeCommit) DescribeMergeConflicts(input *DescribeMergeConflictsInput) (*DescribeMergeConflictsOutput, error) {
	req, out := c.DescribeMergeConflictsRequest(input)
	return out, req.Send()
}

// DescribeMergeConflictsWithContext is the same as DescribeMergeConflicts with the addition of
// the ability to pass a context and additional request options.
//
// See DescribeMergeConflicts for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DescribeMergeConflictsWithContext(ctx aws.Context, input *DescribeMergeConflictsInput, opts ...request.Option) (*DescribeMergeConflictsOutput, error) {
	req, out := c.DescribeMergeConflictsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// DescribeMergeConflictsPages iterates over the pages of a DescribeMergeConflicts operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See DescribeMergeConflicts method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribeMergeConflicts operation.
//    pageNum := 0
//    err := client.DescribeMergeConflictsPages(params,
//        func(page *codecommit.DescribeMergeConflictsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) DescribeMergeConflictsPages(input *DescribeMergeConflictsInput, fn func(*DescribeMergeConflictsOutput, bool) bool) error {
	return c.DescribeMergeConflictsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// DescribeMergeConflictsPagesWithContext same as DescribeMergeConflictsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DescribeMergeConflictsPagesWithContext(ctx aws.Context, input *DescribeMergeConflictsInput, fn func(*DescribeMergeConflictsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *DescribeMergeConflictsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.DescribeMergeConflictsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*DescribeMergeConflictsOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opDescribePullRequestEvents = "DescribePullRequestEvents"

// DescribePullRequestEventsRequest generates a "aws/request.Request" representing the
// client's request for the DescribePullRequestEvents operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DescribePullRequestEvents for more information on using the DescribePullRequestEvents
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DescribePullRequestEventsRequest method.
//    req, resp := client.DescribePullRequestEventsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DescribePullRequestEvents
func (c *CodeCommit) DescribePullRequestEventsRequest(input *DescribePullRequestEventsInput) (req *request.Request, output *DescribePullRequestEventsOutput) {
	op := &request.Operation{
		Name:       opDescribePullRequestEvents,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &DescribePullRequestEventsInput{}
	}

	output = &DescribePullRequestEventsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// DescribePullRequestEvents API operation for AWS CodeCommit.
//
// Returns information about one or more pull request events.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DescribePullRequestEvents for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * InvalidPullRequestEventTypeException
//   The pull request event type is not valid.
//
//   * InvalidActorArnException
//   The Amazon Resource Name (ARN) is not valid. Make sure that you have provided
//   the full ARN for the user who initiated the change for the pull request,
//   and then try again.
//
//   * ActorDoesNotExistException
//   The specified Amazon Resource Name (ARN) does not exist in the AWS account.
//
//   * InvalidMaxResultsException
//   The specified number of maximum results is not valid.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DescribePullRequestEvents
func (c *CodeCommit) DescribePullRequestEvents(input *DescribePullRequestEventsInput) (*DescribePullRequestEventsOutput, error) {
	req, out := c.DescribePullRequestEventsRequest(input)
	return out, req.Send()
}

// DescribePullRequestEventsWithContext is the same as DescribePullRequestEvents with the addition of
// the ability to pass a context and additional request options.
//
// See DescribePullRequestEvents for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DescribePullRequestEventsWithContext(ctx aws.Context, input *DescribePullRequestEventsInput, opts ...request.Option) (*DescribePullRequestEventsOutput, error) {
	req, out := c.DescribePullRequestEventsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// DescribePullRequestEventsPages iterates over the pages of a DescribePullRequestEvents operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See DescribePullRequestEvents method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a DescribePullRequestEvents operation.
//    pageNum := 0
//    err := client.DescribePullRequestEventsPages(params,
//        func(page *codecommit.DescribePullRequestEventsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) DescribePullRequestEventsPages(input *DescribePullRequestEventsInput, fn func(*DescribePullRequestEventsOutput, bool) bool) error {
	return c.DescribePullRequestEventsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// DescribePullRequestEventsPagesWithContext same as DescribePullRequestEventsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DescribePullRequestEventsPagesWithContext(ctx aws.Context, input *DescribePullRequestEventsInput, fn func(*DescribePullRequestEventsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *DescribePullRequestEventsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.DescribePullRequestEventsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*DescribePullRequestEventsOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opDisassociateApprovalRuleTemplateFromRepository = "DisassociateApprovalRuleTemplateFromRepository"

// DisassociateApprovalRuleTemplateFromRepositoryRequest generates a "aws/request.Request" representing the
// client's request for the DisassociateApprovalRuleTemplateFromRepository operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See DisassociateApprovalRuleTemplateFromRepository for more information on using the DisassociateApprovalRuleTemplateFromRepository
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the DisassociateApprovalRuleTemplateFromRepositoryRequest method.
//    req, resp := client.DisassociateApprovalRuleTemplateFromRepositoryRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DisassociateApprovalRuleTemplateFromRepository
func (c *CodeCommit) DisassociateApprovalRuleTemplateFromRepositoryRequest(input *DisassociateApprovalRuleTemplateFromRepositoryInput) (req *request.Request, output *DisassociateApprovalRuleTemplateFromRepositoryOutput) {
	op := &request.Operation{
		Name:       opDisassociateApprovalRuleTemplateFromRepository,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &DisassociateApprovalRuleTemplateFromRepositoryInput{}
	}

	output = &DisassociateApprovalRuleTemplateFromRepositoryOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// DisassociateApprovalRuleTemplateFromRepository API operation for AWS CodeCommit.
//
// Removes the association between a template and a repository so that approval
// rules based on the template are not automatically created when pull requests
// are created in the specified repository. This does not delete any approval
// rules previously created for pull requests through the template association.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation DisassociateApprovalRuleTemplateFromRepository for usage and error information.
//
// Returned Error Types:
//   * ApprovalRuleTemplateNameRequiredException
//   An approval rule template name is required, but was not specified.
//
//   * InvalidApprovalRuleTemplateNameException
//   The name of the approval rule template is not valid. Template names must
//   be between 1 and 100 valid characters in length. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * ApprovalRuleTemplateDoesNotExistException
//   The specified approval rule template does not exist. Verify that the name
//   is correct and that you are signed in to the AWS Region where the template
//   was created, and then try again.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/DisassociateApprovalRuleTemplateFromRepository
func (c *CodeCommit) DisassociateApprovalRuleTemplateFromRepository(input *DisassociateApprovalRuleTemplateFromRepositoryInput) (*DisassociateApprovalRuleTemplateFromRepositoryOutput, error) {
	req, out := c.DisassociateApprovalRuleTemplateFromRepositoryRequest(input)
	return out, req.Send()
}

// DisassociateApprovalRuleTemplateFromRepositoryWithContext is the same as DisassociateApprovalRuleTemplateFromRepository with the addition of
// the ability to pass a context and additional request options.
//
// See DisassociateApprovalRuleTemplateFromRepository for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) DisassociateApprovalRuleTemplateFromRepositoryWithContext(ctx aws.Context, input *DisassociateApprovalRuleTemplateFromRepositoryInput, opts ...request.Option) (*DisassociateApprovalRuleTemplateFromRepositoryOutput, error) {
	req, out := c.DisassociateApprovalRuleTemplateFromRepositoryRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opEvaluatePullRequestApprovalRules = "EvaluatePullRequestApprovalRules"

// EvaluatePullRequestApprovalRulesRequest generates a "aws/request.Request" representing the
// client's request for the EvaluatePullRequestApprovalRules operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See EvaluatePullRequestApprovalRules for more information on using the EvaluatePullRequestApprovalRules
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the EvaluatePullRequestApprovalRulesRequest method.
//    req, resp := client.EvaluatePullRequestApprovalRulesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/EvaluatePullRequestApprovalRules
func (c *CodeCommit) EvaluatePullRequestApprovalRulesRequest(input *EvaluatePullRequestApprovalRulesInput) (req *request.Request, output *EvaluatePullRequestApprovalRulesOutput) {
	op := &request.Operation{
		Name:       opEvaluatePullRequestApprovalRules,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &EvaluatePullRequestApprovalRulesInput{}
	}

	output = &EvaluatePullRequestApprovalRulesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// EvaluatePullRequestApprovalRules API operation for AWS CodeCommit.
//
// Evaluates whether a pull request has met all the conditions specified in
// its associated approval rules.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation EvaluatePullRequestApprovalRules for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * InvalidRevisionIdException
//   The revision ID is not valid. Use GetPullRequest to determine the value.
//
//   * RevisionIdRequiredException
//   A revision ID is required, but was not provided.
//
//   * RevisionNotCurrentException
//   The revision ID provided in the request does not match the current revision
//   ID. Use GetPullRequest to retrieve the current revision ID.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/EvaluatePullRequestApprovalRules
func (c *CodeCommit) EvaluatePullRequestApprovalRules(input *EvaluatePullRequestApprovalRulesInput) (*EvaluatePullRequestApprovalRulesOutput, error) {
	req, out := c.EvaluatePullRequestApprovalRulesRequest(input)
	return out, req.Send()
}

// EvaluatePullRequestApprovalRulesWithContext is the same as EvaluatePullRequestApprovalRules with the addition of
// the ability to pass a context and additional request options.
//
// See EvaluatePullRequestApprovalRules for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) EvaluatePullRequestApprovalRulesWithContext(ctx aws.Context, input *EvaluatePullRequestApprovalRulesInput, opts ...request.Option) (*EvaluatePullRequestApprovalRulesOutput, error) {
	req, out := c.EvaluatePullRequestApprovalRulesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetApprovalRuleTemplate = "GetApprovalRuleTemplate"

// GetApprovalRuleTemplateRequest generates a "aws/request.Request" representing the
// client's request for the GetApprovalRuleTemplate operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetApprovalRuleTemplate for more information on using the GetApprovalRuleTemplate
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetApprovalRuleTemplateRequest method.
//    req, resp := client.GetApprovalRuleTemplateRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetApprovalRuleTemplate
func (c *CodeCommit) GetApprovalRuleTemplateRequest(input *GetApprovalRuleTemplateInput) (req *request.Request, output *GetApprovalRuleTemplateOutput) {
	op := &request.Operation{
		Name:       opGetApprovalRuleTemplate,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetApprovalRuleTemplateInput{}
	}

	output = &GetApprovalRuleTemplateOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetApprovalRuleTemplate API operation for AWS CodeCommit.
//
// Returns information about a specified approval rule template.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetApprovalRuleTemplate for usage and error information.
//
// Returned Error Types:
//   * ApprovalRuleTemplateNameRequiredException
//   An approval rule template name is required, but was not specified.
//
//   * InvalidApprovalRuleTemplateNameException
//   The name of the approval rule template is not valid. Template names must
//   be between 1 and 100 valid characters in length. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * ApprovalRuleTemplateDoesNotExistException
//   The specified approval rule template does not exist. Verify that the name
//   is correct and that you are signed in to the AWS Region where the template
//   was created, and then try again.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetApprovalRuleTemplate
func (c *CodeCommit) GetApprovalRuleTemplate(input *GetApprovalRuleTemplateInput) (*GetApprovalRuleTemplateOutput, error) {
	req, out := c.GetApprovalRuleTemplateRequest(input)
	return out, req.Send()
}

// GetApprovalRuleTemplateWithContext is the same as GetApprovalRuleTemplate with the addition of
// the ability to pass a context and additional request options.
//
// See GetApprovalRuleTemplate for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetApprovalRuleTemplateWithContext(ctx aws.Context, input *GetApprovalRuleTemplateInput, opts ...request.Option) (*GetApprovalRuleTemplateOutput, error) {
	req, out := c.GetApprovalRuleTemplateRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetBlob = "GetBlob"

// GetBlobRequest generates a "aws/request.Request" representing the
// client's request for the GetBlob operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetBlob for more information on using the GetBlob
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetBlobRequest method.
//    req, resp := client.GetBlobRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetBlob
func (c *CodeCommit) GetBlobRequest(input *GetBlobInput) (req *request.Request, output *GetBlobOutput) {
	op := &request.Operation{
		Name:       opGetBlob,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetBlobInput{}
	}

	output = &GetBlobOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetBlob API operation for AWS CodeCommit.
//
// Returns the base-64 encoded content of an individual blob in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetBlob for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * BlobIdRequiredException
//   A blob ID is required, but was not specified.
//
//   * InvalidBlobIdException
//   The specified blob is not valid.
//
//   * BlobIdDoesNotExistException
//   The specified blob does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
//   * FileTooLargeException
//   The specified file exceeds the file size limit for AWS CodeCommit. For more
//   information about limits in AWS CodeCommit, see AWS CodeCommit User Guide
//   (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetBlob
func (c *CodeCommit) GetBlob(input *GetBlobInput) (*GetBlobOutput, error) {
	req, out := c.GetBlobRequest(input)
	return out, req.Send()
}

// GetBlobWithContext is the same as GetBlob with the addition of
// the ability to pass a context and additional request options.
//
// See GetBlob for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetBlobWithContext(ctx aws.Context, input *GetBlobInput, opts ...request.Option) (*GetBlobOutput, error) {
	req, out := c.GetBlobRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetBranch = "GetBranch"

// GetBranchRequest generates a "aws/request.Request" representing the
// client's request for the GetBranch operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetBranch for more information on using the GetBranch
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetBranchRequest method.
//    req, resp := client.GetBranchRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetBranch
func (c *CodeCommit) GetBranchRequest(input *GetBranchInput) (req *request.Request, output *GetBranchOutput) {
	op := &request.Operation{
		Name:       opGetBranch,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetBranchInput{}
	}

	output = &GetBranchOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetBranch API operation for AWS CodeCommit.
//
// Returns information about a repository branch, including its name and the
// last commit ID.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetBranch for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * BranchNameRequiredException
//   A branch name is required, but was not specified.
//
//   * InvalidBranchNameException
//   The specified reference name is not valid.
//
//   * BranchDoesNotExistException
//   The specified branch does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetBranch
func (c *CodeCommit) GetBranch(input *GetBranchInput) (*GetBranchOutput, error) {
	req, out := c.GetBranchRequest(input)
	return out, req.Send()
}

// GetBranchWithContext is the same as GetBranch with the addition of
// the ability to pass a context and additional request options.
//
// See GetBranch for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetBranchWithContext(ctx aws.Context, input *GetBranchInput, opts ...request.Option) (*GetBranchOutput, error) {
	req, out := c.GetBranchRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetComment = "GetComment"

// GetCommentRequest generates a "aws/request.Request" representing the
// client's request for the GetComment operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetComment for more information on using the GetComment
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetCommentRequest method.
//    req, resp := client.GetCommentRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetComment
func (c *CodeCommit) GetCommentRequest(input *GetCommentInput) (req *request.Request, output *GetCommentOutput) {
	op := &request.Operation{
		Name:       opGetComment,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetCommentInput{}
	}

	output = &GetCommentOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetComment API operation for AWS CodeCommit.
//
// Returns the content of a comment made on a change, file, or commit in a repository.
//
// Reaction counts might include numbers from user identities who were deleted
// after the reaction was made. For a count of reactions from active identities,
// use GetCommentReactions.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetComment for usage and error information.
//
// Returned Error Types:
//   * CommentDoesNotExistException
//   No comment exists with the provided ID. Verify that you have used the correct
//   ID, and then try again.
//
//   * CommentDeletedException
//   This comment has already been deleted. You cannot edit or delete a deleted
//   comment.
//
//   * CommentIdRequiredException
//   The comment ID is missing or null. A comment ID is required.
//
//   * InvalidCommentIdException
//   The comment ID is not in a valid format. Make sure that you have provided
//   the full comment ID.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetComment
func (c *CodeCommit) GetComment(input *GetCommentInput) (*GetCommentOutput, error) {
	req, out := c.GetCommentRequest(input)
	return out, req.Send()
}

// GetCommentWithContext is the same as GetComment with the addition of
// the ability to pass a context and additional request options.
//
// See GetComment for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentWithContext(ctx aws.Context, input *GetCommentInput, opts ...request.Option) (*GetCommentOutput, error) {
	req, out := c.GetCommentRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetCommentReactions = "GetCommentReactions"

// GetCommentReactionsRequest generates a "aws/request.Request" representing the
// client's request for the GetCommentReactions operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetCommentReactions for more information on using the GetCommentReactions
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetCommentReactionsRequest method.
//    req, resp := client.GetCommentReactionsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommentReactions
func (c *CodeCommit) GetCommentReactionsRequest(input *GetCommentReactionsInput) (req *request.Request, output *GetCommentReactionsOutput) {
	op := &request.Operation{
		Name:       opGetCommentReactions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetCommentReactionsInput{}
	}

	output = &GetCommentReactionsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetCommentReactions API operation for AWS CodeCommit.
//
// Returns information about reactions to a specified comment ID. Reactions
// from users who have been deleted will not be included in the count.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetCommentReactions for usage and error information.
//
// Returned Error Types:
//   * CommentDoesNotExistException
//   No comment exists with the provided ID. Verify that you have used the correct
//   ID, and then try again.
//
//   * CommentIdRequiredException
//   The comment ID is missing or null. A comment ID is required.
//
//   * InvalidCommentIdException
//   The comment ID is not in a valid format. Make sure that you have provided
//   the full comment ID.
//
//   * InvalidReactionUserArnException
//   The Amazon Resource Name (ARN) of the user or identity is not valid.
//
//   * InvalidMaxResultsException
//   The specified number of maximum results is not valid.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
//   * CommentDeletedException
//   This comment has already been deleted. You cannot edit or delete a deleted
//   comment.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommentReactions
func (c *CodeCommit) GetCommentReactions(input *GetCommentReactionsInput) (*GetCommentReactionsOutput, error) {
	req, out := c.GetCommentReactionsRequest(input)
	return out, req.Send()
}

// GetCommentReactionsWithContext is the same as GetCommentReactions with the addition of
// the ability to pass a context and additional request options.
//
// See GetCommentReactions for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentReactionsWithContext(ctx aws.Context, input *GetCommentReactionsInput, opts ...request.Option) (*GetCommentReactionsOutput, error) {
	req, out := c.GetCommentReactionsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// GetCommentReactionsPages iterates over the pages of a GetCommentReactions operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See GetCommentReactions method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetCommentReactions operation.
//    pageNum := 0
//    err := client.GetCommentReactionsPages(params,
//        func(page *codecommit.GetCommentReactionsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) GetCommentReactionsPages(input *GetCommentReactionsInput, fn func(*GetCommentReactionsOutput, bool) bool) error {
	return c.GetCommentReactionsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// GetCommentReactionsPagesWithContext same as GetCommentReactionsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentReactionsPagesWithContext(ctx aws.Context, input *GetCommentReactionsInput, fn func(*GetCommentReactionsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *GetCommentReactionsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.GetCommentReactionsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*GetCommentReactionsOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opGetCommentsForComparedCommit = "GetCommentsForComparedCommit"

// GetCommentsForComparedCommitRequest generates a "aws/request.Request" representing the
// client's request for the GetCommentsForComparedCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetCommentsForComparedCommit for more information on using the GetCommentsForComparedCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetCommentsForComparedCommitRequest method.
//    req, resp := client.GetCommentsForComparedCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommentsForComparedCommit
func (c *CodeCommit) GetCommentsForComparedCommitRequest(input *GetCommentsForComparedCommitInput) (req *request.Request, output *GetCommentsForComparedCommitOutput) {
	op := &request.Operation{
		Name:       opGetCommentsForComparedCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetCommentsForComparedCommitInput{}
	}

	output = &GetCommentsForComparedCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetCommentsForComparedCommit API operation for AWS CodeCommit.
//
// Returns information about comments made on the comparison between two commits.
//
// Reaction counts might include numbers from user identities who were deleted
// after the reaction was made. For a count of reactions from active identities,
// use GetCommentReactions.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetCommentsForComparedCommit for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * CommitIdRequiredException
//   A commit ID was not specified.
//
//   * InvalidCommitIdException
//   The specified commit ID is not valid.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidMaxResultsException
//   The specified number of maximum results is not valid.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommentsForComparedCommit
func (c *CodeCommit) GetCommentsForComparedCommit(input *GetCommentsForComparedCommitInput) (*GetCommentsForComparedCommitOutput, error) {
	req, out := c.GetCommentsForComparedCommitRequest(input)
	return out, req.Send()
}

// GetCommentsForComparedCommitWithContext is the same as GetCommentsForComparedCommit with the addition of
// the ability to pass a context and additional request options.
//
// See GetCommentsForComparedCommit for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentsForComparedCommitWithContext(ctx aws.Context, input *GetCommentsForComparedCommitInput, opts ...request.Option) (*GetCommentsForComparedCommitOutput, error) {
	req, out := c.GetCommentsForComparedCommitRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// GetCommentsForComparedCommitPages iterates over the pages of a GetCommentsForComparedCommit operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See GetCommentsForComparedCommit method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetCommentsForComparedCommit operation.
//    pageNum := 0
//    err := client.GetCommentsForComparedCommitPages(params,
//        func(page *codecommit.GetCommentsForComparedCommitOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) GetCommentsForComparedCommitPages(input *GetCommentsForComparedCommitInput, fn func(*GetCommentsForComparedCommitOutput, bool) bool) error {
	return c.GetCommentsForComparedCommitPagesWithContext(aws.BackgroundContext(), input, fn)
}

// GetCommentsForComparedCommitPagesWithContext same as GetCommentsForComparedCommitPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentsForComparedCommitPagesWithContext(ctx aws.Context, input *GetCommentsForComparedCommitInput, fn func(*GetCommentsForComparedCommitOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *GetCommentsForComparedCommitInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.GetCommentsForComparedCommitRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*GetCommentsForComparedCommitOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opGetCommentsForPullRequest = "GetCommentsForPullRequest"

// GetCommentsForPullRequestRequest generates a "aws/request.Request" representing the
// client's request for the GetCommentsForPullRequest operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetCommentsForPullRequest for more information on using the GetCommentsForPullRequest
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetCommentsForPullRequestRequest method.
//    req, resp := client.GetCommentsForPullRequestRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommentsForPullRequest
func (c *CodeCommit) GetCommentsForPullRequestRequest(input *GetCommentsForPullRequestInput) (req *request.Request, output *GetCommentsForPullRequestOutput) {
	op := &request.Operation{
		Name:       opGetCommentsForPullRequest,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetCommentsForPullRequestInput{}
	}

	output = &GetCommentsForPullRequestOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetCommentsForPullRequest API operation for AWS CodeCommit.
//
// Returns comments made on a pull request.
//
// Reaction counts might include numbers from user identities who were deleted
// after the reaction was made. For a count of reactions from active identities,
// use GetCommentReactions.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetCommentsForPullRequest for usage and error information.
//
// Returned Error Types:
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * CommitIdRequiredException
//   A commit ID was not specified.
//
//   * InvalidCommitIdException
//   The specified commit ID is not valid.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidMaxResultsException
//   The specified number of maximum results is not valid.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
//   * RepositoryNotAssociatedWithPullRequestException
//   The repository does not contain any pull requests with that pull request
//   ID. Use GetPullRequest to verify the correct repository name for the pull
//   request ID.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommentsForPullRequest
func (c *CodeCommit) GetCommentsForPullRequest(input *GetCommentsForPullRequestInput) (*GetCommentsForPullRequestOutput, error) {
	req, out := c.GetCommentsForPullRequestRequest(input)
	return out, req.Send()
}

// GetCommentsForPullRequestWithContext is the same as GetCommentsForPullRequest with the addition of
// the ability to pass a context and additional request options.
//
// See GetCommentsForPullRequest for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentsForPullRequestWithContext(ctx aws.Context, input *GetCommentsForPullRequestInput, opts ...request.Option) (*GetCommentsForPullRequestOutput, error) {
	req, out := c.GetCommentsForPullRequestRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// GetCommentsForPullRequestPages iterates over the pages of a GetCommentsForPullRequest operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See GetCommentsForPullRequest method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetCommentsForPullRequest operation.
//    pageNum := 0
//    err := client.GetCommentsForPullRequestPages(params,
//        func(page *codecommit.GetCommentsForPullRequestOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) GetCommentsForPullRequestPages(input *GetCommentsForPullRequestInput, fn func(*GetCommentsForPullRequestOutput, bool) bool) error {
	return c.GetCommentsForPullRequestPagesWithContext(aws.BackgroundContext(), input, fn)
}

// GetCommentsForPullRequestPagesWithContext same as GetCommentsForPullRequestPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommentsForPullRequestPagesWithContext(ctx aws.Context, input *GetCommentsForPullRequestInput, fn func(*GetCommentsForPullRequestOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *GetCommentsForPullRequestInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.GetCommentsForPullRequestRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*GetCommentsForPullRequestOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opGetCommit = "GetCommit"

// GetCommitRequest generates a "aws/request.Request" representing the
// client's request for the GetCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetCommit for more information on using the GetCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetCommitRequest method.
//    req, resp := client.GetCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommit
func (c *CodeCommit) GetCommitRequest(input *GetCommitInput) (req *request.Request, output *GetCommitOutput) {
	op := &request.Operation{
		Name:       opGetCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetCommitInput{}
	}

	output = &GetCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetCommit API operation for AWS CodeCommit.
//
// Returns information about a commit, including commit message and committer
// information.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetCommit for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * CommitIdRequiredException
//   A commit ID was not specified.
//
//   * InvalidCommitIdException
//   The specified commit ID is not valid.
//
//   * CommitIdDoesNotExistException
//   The specified commit ID does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetCommit
func (c *CodeCommit) GetCommit(input *GetCommitInput) (*GetCommitOutput, error) {
	req, out := c.GetCommitRequest(input)
	return out, req.Send()
}

// GetCommitWithContext is the same as GetCommit with the addition of
// the ability to pass a context and additional request options.
//
// See GetCommit for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetCommitWithContext(ctx aws.Context, input *GetCommitInput, opts ...request.Option) (*GetCommitOutput, error) {
	req, out := c.GetCommitRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetDifferences = "GetDifferences"

// GetDifferencesRequest generates a "aws/request.Request" representing the
// client's request for the GetDifferences operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetDifferences for more information on using the GetDifferences
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetDifferencesRequest method.
//    req, resp := client.GetDifferencesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetDifferences
func (c *CodeCommit) GetDifferencesRequest(input *GetDifferencesInput) (req *request.Request, output *GetDifferencesOutput) {
	op := &request.Operation{
		Name:       opGetDifferences,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"NextToken"},
			OutputTokens:    []string{"NextToken"},
			LimitToken:      "MaxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetDifferencesInput{}
	}

	output = &GetDifferencesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetDifferences API operation for AWS CodeCommit.
//
// Returns information about the differences in a valid commit specifier (such
// as a branch, tag, HEAD, commit ID, or other fully qualified reference). Results
// can be limited to a specified path.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetDifferences for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
//   * InvalidMaxResultsException
//   The specified number of maximum results is not valid.
//
//   * InvalidCommitIdException
//   The specified commit ID is not valid.
//
//   * CommitRequiredException
//   A commit was not specified.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * PathDoesNotExistException
//   The specified path does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetDifferences
func (c *CodeCommit) GetDifferences(input *GetDifferencesInput) (*GetDifferencesOutput, error) {
	req, out := c.GetDifferencesRequest(input)
	return out, req.Send()
}

// GetDifferencesWithContext is the same as GetDifferences with the addition of
// the ability to pass a context and additional request options.
//
// See GetDifferences for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetDifferencesWithContext(ctx aws.Context, input *GetDifferencesInput, opts ...request.Option) (*GetDifferencesOutput, error) {
	req, out := c.GetDifferencesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// GetDifferencesPages iterates over the pages of a GetDifferences operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See GetDifferences method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetDifferences operation.
//    pageNum := 0
//    err := client.GetDifferencesPages(params,
//        func(page *codecommit.GetDifferencesOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) GetDifferencesPages(input *GetDifferencesInput, fn func(*GetDifferencesOutput, bool) bool) error {
	return c.GetDifferencesPagesWithContext(aws.BackgroundContext(), input, fn)
}

// GetDifferencesPagesWithContext same as GetDifferencesPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetDifferencesPagesWithContext(ctx aws.Context, input *GetDifferencesInput, fn func(*GetDifferencesOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *GetDifferencesInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.GetDifferencesRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*GetDifferencesOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opGetFile = "GetFile"

// GetFileRequest generates a "aws/request.Request" representing the
// client's request for the GetFile operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetFile for more information on using the GetFile
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetFileRequest method.
//    req, resp := client.GetFileRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetFile
func (c *CodeCommit) GetFileRequest(input *GetFileInput) (req *request.Request, output *GetFileOutput) {
	op := &request.Operation{
		Name:       opGetFile,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetFileInput{}
	}

	output = &GetFileOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetFile API operation for AWS CodeCommit.
//
// Returns the base-64 encoded contents of a specified file and its metadata.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetFile for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * FileDoesNotExistException
//   The specified file does not exist. Verify that you have used the correct
//   file name, full path, and extension.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
//   * FileTooLargeException
//   The specified file exceeds the file size limit for AWS CodeCommit. For more
//   information about limits in AWS CodeCommit, see AWS CodeCommit User Guide
//   (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetFile
func (c *CodeCommit) GetFile(input *GetFileInput) (*GetFileOutput, error) {
	req, out := c.GetFileRequest(input)
	return out, req.Send()
}

// GetFileWithContext is the same as GetFile with the addition of
// the ability to pass a context and additional request options.
//
// See GetFile for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetFileWithContext(ctx aws.Context, input *GetFileInput, opts ...request.Option) (*GetFileOutput, error) {
	req, out := c.GetFileRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetFolder = "GetFolder"

// GetFolderRequest generates a "aws/request.Request" representing the
// client's request for the GetFolder operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetFolder for more information on using the GetFolder
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetFolderRequest method.
//    req, resp := client.GetFolderRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetFolder
func (c *CodeCommit) GetFolderRequest(input *GetFolderInput) (req *request.Request, output *GetFolderOutput) {
	op := &request.Operation{
		Name:       opGetFolder,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetFolderInput{}
	}

	output = &GetFolderOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetFolder API operation for AWS CodeCommit.
//
// Returns the contents of a specified folder in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetFolder for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * FolderDoesNotExistException
//   The specified folder does not exist. Either the folder name is not correct,
//   or you did not enter the full path to the folder.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetFolder
func (c *CodeCommit) GetFolder(input *GetFolderInput) (*GetFolderOutput, error) {
	req, out := c.GetFolderRequest(input)
	return out, req.Send()
}

// GetFolderWithContext is the same as GetFolder with the addition of
// the ability to pass a context and additional request options.
//
// See GetFolder for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetFolderWithContext(ctx aws.Context, input *GetFolderInput, opts ...request.Option) (*GetFolderOutput, error) {
	req, out := c.GetFolderRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetMergeCommit = "GetMergeCommit"

// GetMergeCommitRequest generates a "aws/request.Request" representing the
// client's request for the GetMergeCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetMergeCommit for more information on using the GetMergeCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetMergeCommitRequest method.
//    req, resp := client.GetMergeCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeCommit
func (c *CodeCommit) GetMergeCommitRequest(input *GetMergeCommitInput) (req *request.Request, output *GetMergeCommitOutput) {
	op := &request.Operation{
		Name:       opGetMergeCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetMergeCommitInput{}
	}

	output = &GetMergeCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetMergeCommit API operation for AWS CodeCommit.
//
// Returns information about a specified merge commit.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetMergeCommit for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * CommitRequiredException
//   A commit was not specified.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidConflictDetailLevelException
//   The specified conflict detail level is not valid.
//
//   * InvalidConflictResolutionStrategyException
//   The specified conflict resolution strategy is not valid.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeCommit
func (c *CodeCommit) GetMergeCommit(input *GetMergeCommitInput) (*GetMergeCommitOutput, error) {
	req, out := c.GetMergeCommitRequest(input)
	return out, req.Send()
}

// GetMergeCommitWithContext is the same as GetMergeCommit with the addition of
// the ability to pass a context and additional request options.
//
// See GetMergeCommit for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetMergeCommitWithContext(ctx aws.Context, input *GetMergeCommitInput, opts ...request.Option) (*GetMergeCommitOutput, error) {
	req, out := c.GetMergeCommitRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetMergeConflicts = "GetMergeConflicts"

// GetMergeConflictsRequest generates a "aws/request.Request" representing the
// client's request for the GetMergeConflicts operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetMergeConflicts for more information on using the GetMergeConflicts
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetMergeConflictsRequest method.
//    req, resp := client.GetMergeConflictsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeConflicts
func (c *CodeCommit) GetMergeConflictsRequest(input *GetMergeConflictsInput) (req *request.Request, output *GetMergeConflictsOutput) {
	op := &request.Operation{
		Name:       opGetMergeConflicts,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxConflictFiles",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &GetMergeConflictsInput{}
	}

	output = &GetMergeConflictsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetMergeConflicts API operation for AWS CodeCommit.
//
// Returns information about merge conflicts between the before and after commit
// IDs for a pull request in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetMergeConflicts for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * MergeOptionRequiredException
//   A merge option or stategy is required, and none was provided.
//
//   * InvalidMergeOptionException
//   The specified merge option is not valid for this operation. Not all merge
//   strategies are supported for all operations.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
//   * CommitRequiredException
//   A commit was not specified.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * TipsDivergenceExceededException
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * InvalidMaxConflictFilesException
//   The specified value for the number of conflict files to return is not valid.
//
//   * InvalidConflictDetailLevelException
//   The specified conflict detail level is not valid.
//
//   * InvalidDestinationCommitSpecifierException
//   The destination commit specifier is not valid. You must provide a valid branch
//   name, tag, or full commit ID.
//
//   * InvalidSourceCommitSpecifierException
//   The source commit specifier is not valid. You must provide a valid branch
//   name, tag, or full commit ID.
//
//   * InvalidConflictResolutionStrategyException
//   The specified conflict resolution strategy is not valid.
//
//   * MaximumFileContentToLoadExceededException
//   The number of files to load exceeds the allowed limit.
//
//   * MaximumItemsToCompareExceededException
//   The number of items to compare between the source or destination branches
//   and the merge base has exceeded the maximum allowed.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeConflicts
func (c *CodeCommit) GetMergeConflicts(input *GetMergeConflictsInput) (*GetMergeConflictsOutput, error) {
	req, out := c.GetMergeConflictsRequest(input)
	return out, req.Send()
}

// GetMergeConflictsWithContext is the same as GetMergeConflicts with the addition of
// the ability to pass a context and additional request options.
//
// See GetMergeConflicts for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetMergeConflictsWithContext(ctx aws.Context, input *GetMergeConflictsInput, opts ...request.Option) (*GetMergeConflictsOutput, error) {
	req, out := c.GetMergeConflictsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// GetMergeConflictsPages iterates over the pages of a GetMergeConflicts operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See GetMergeConflicts method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a GetMergeConflicts operation.
//    pageNum := 0
//    err := client.GetMergeConflictsPages(params,
//        func(page *codecommit.GetMergeConflictsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) GetMergeConflictsPages(input *GetMergeConflictsInput, fn func(*GetMergeConflictsOutput, bool) bool) error {
	return c.GetMergeConflictsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// GetMergeConflictsPagesWithContext same as GetMergeConflictsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetMergeConflictsPagesWithContext(ctx aws.Context, input *GetMergeConflictsInput, fn func(*GetMergeConflictsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *GetMergeConflictsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.GetMergeConflictsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*GetMergeConflictsOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opGetMergeOptions = "GetMergeOptions"

// GetMergeOptionsRequest generates a "aws/request.Request" representing the
// client's request for the GetMergeOptions operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetMergeOptions for more information on using the GetMergeOptions
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetMergeOptionsRequest method.
//    req, resp := client.GetMergeOptionsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeOptions
func (c *CodeCommit) GetMergeOptionsRequest(input *GetMergeOptionsInput) (req *request.Request, output *GetMergeOptionsOutput) {
	op := &request.Operation{
		Name:       opGetMergeOptions,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetMergeOptionsInput{}
	}

	output = &GetMergeOptionsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetMergeOptions API operation for AWS CodeCommit.
//
// Returns information about the merge options available for merging two specified
// branches. For details about why a merge option is not available, use GetMergeConflicts
// or DescribeMergeConflicts.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetMergeOptions for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * CommitRequiredException
//   A commit was not specified.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * TipsDivergenceExceededException
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * InvalidConflictDetailLevelException
//   The specified conflict detail level is not valid.
//
//   * InvalidConflictResolutionStrategyException
//   The specified conflict resolution strategy is not valid.
//
//   * MaximumFileContentToLoadExceededException
//   The number of files to load exceeds the allowed limit.
//
//   * MaximumItemsToCompareExceededException
//   The number of items to compare between the source or destination branches
//   and the merge base has exceeded the maximum allowed.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetMergeOptions
func (c *CodeCommit) GetMergeOptions(input *GetMergeOptionsInput) (*GetMergeOptionsOutput, error) {
	req, out := c.GetMergeOptionsRequest(input)
	return out, req.Send()
}

// GetMergeOptionsWithContext is the same as GetMergeOptions with the addition of
// the ability to pass a context and additional request options.
//
// See GetMergeOptions for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetMergeOptionsWithContext(ctx aws.Context, input *GetMergeOptionsInput, opts ...request.Option) (*GetMergeOptionsOutput, error) {
	req, out := c.GetMergeOptionsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetPullRequest = "GetPullRequest"

// GetPullRequestRequest generates a "aws/request.Request" representing the
// client's request for the GetPullRequest operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetPullRequest for more information on using the GetPullRequest
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetPullRequestRequest method.
//    req, resp := client.GetPullRequestRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetPullRequest
func (c *CodeCommit) GetPullRequestRequest(input *GetPullRequestInput) (req *request.Request, output *GetPullRequestOutput) {
	op := &request.Operation{
		Name:       opGetPullRequest,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetPullRequestInput{}
	}

	output = &GetPullRequestOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetPullRequest API operation for AWS CodeCommit.
//
// Gets information about a pull request in a specified repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetPullRequest for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetPullRequest
func (c *CodeCommit) GetPullRequest(input *GetPullRequestInput) (*GetPullRequestOutput, error) {
	req, out := c.GetPullRequestRequest(input)
	return out, req.Send()
}

// GetPullRequestWithContext is the same as GetPullRequest with the addition of
// the ability to pass a context and additional request options.
//
// See GetPullRequest for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetPullRequestWithContext(ctx aws.Context, input *GetPullRequestInput, opts ...request.Option) (*GetPullRequestOutput, error) {
	req, out := c.GetPullRequestRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetPullRequestApprovalStates = "GetPullRequestApprovalStates"

// GetPullRequestApprovalStatesRequest generates a "aws/request.Request" representing the
// client's request for the GetPullRequestApprovalStates operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetPullRequestApprovalStates for more information on using the GetPullRequestApprovalStates
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetPullRequestApprovalStatesRequest method.
//    req, resp := client.GetPullRequestApprovalStatesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetPullRequestApprovalStates
func (c *CodeCommit) GetPullRequestApprovalStatesRequest(input *GetPullRequestApprovalStatesInput) (req *request.Request, output *GetPullRequestApprovalStatesOutput) {
	op := &request.Operation{
		Name:       opGetPullRequestApprovalStates,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetPullRequestApprovalStatesInput{}
	}

	output = &GetPullRequestApprovalStatesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetPullRequestApprovalStates API operation for AWS CodeCommit.
//
// Gets information about the approval states for a specified pull request.
// Approval states only apply to pull requests that have one or more approval
// rules applied to them.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetPullRequestApprovalStates for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * InvalidRevisionIdException
//   The revision ID is not valid. Use GetPullRequest to determine the value.
//
//   * RevisionIdRequiredException
//   A revision ID is required, but was not provided.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetPullRequestApprovalStates
func (c *CodeCommit) GetPullRequestApprovalStates(input *GetPullRequestApprovalStatesInput) (*GetPullRequestApprovalStatesOutput, error) {
	req, out := c.GetPullRequestApprovalStatesRequest(input)
	return out, req.Send()
}

// GetPullRequestApprovalStatesWithContext is the same as GetPullRequestApprovalStates with the addition of
// the ability to pass a context and additional request options.
//
// See GetPullRequestApprovalStates for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetPullRequestApprovalStatesWithContext(ctx aws.Context, input *GetPullRequestApprovalStatesInput, opts ...request.Option) (*GetPullRequestApprovalStatesOutput, error) {
	req, out := c.GetPullRequestApprovalStatesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetPullRequestOverrideState = "GetPullRequestOverrideState"

// GetPullRequestOverrideStateRequest generates a "aws/request.Request" representing the
// client's request for the GetPullRequestOverrideState operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetPullRequestOverrideState for more information on using the GetPullRequestOverrideState
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetPullRequestOverrideStateRequest method.
//    req, resp := client.GetPullRequestOverrideStateRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetPullRequestOverrideState
func (c *CodeCommit) GetPullRequestOverrideStateRequest(input *GetPullRequestOverrideStateInput) (req *request.Request, output *GetPullRequestOverrideStateOutput) {
	op := &request.Operation{
		Name:       opGetPullRequestOverrideState,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetPullRequestOverrideStateInput{}
	}

	output = &GetPullRequestOverrideStateOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetPullRequestOverrideState API operation for AWS CodeCommit.
//
// Returns information about whether approval rules have been set aside (overridden)
// for a pull request, and if so, the Amazon Resource Name (ARN) of the user
// or identity that overrode the rules and their requirements for the pull request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetPullRequestOverrideState for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * InvalidRevisionIdException
//   The revision ID is not valid. Use GetPullRequest to determine the value.
//
//   * RevisionIdRequiredException
//   A revision ID is required, but was not provided.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetPullRequestOverrideState
func (c *CodeCommit) GetPullRequestOverrideState(input *GetPullRequestOverrideStateInput) (*GetPullRequestOverrideStateOutput, error) {
	req, out := c.GetPullRequestOverrideStateRequest(input)
	return out, req.Send()
}

// GetPullRequestOverrideStateWithContext is the same as GetPullRequestOverrideState with the addition of
// the ability to pass a context and additional request options.
//
// See GetPullRequestOverrideState for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetPullRequestOverrideStateWithContext(ctx aws.Context, input *GetPullRequestOverrideStateInput, opts ...request.Option) (*GetPullRequestOverrideStateOutput, error) {
	req, out := c.GetPullRequestOverrideStateRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetRepository = "GetRepository"

// GetRepositoryRequest generates a "aws/request.Request" representing the
// client's request for the GetRepository operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetRepository for more information on using the GetRepository
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetRepositoryRequest method.
//    req, resp := client.GetRepositoryRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetRepository
func (c *CodeCommit) GetRepositoryRequest(input *GetRepositoryInput) (req *request.Request, output *GetRepositoryOutput) {
	op := &request.Operation{
		Name:       opGetRepository,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetRepositoryInput{}
	}

	output = &GetRepositoryOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetRepository API operation for AWS CodeCommit.
//
// Returns information about a repository.
//
// The description field for a repository accepts all HTML characters and all
// valid Unicode characters. Applications that do not HTML-encode the description
// and display it in a webpage can expose users to potentially malicious code.
// Make sure that you HTML-encode the description field in any application that
// uses this API to display the repository description on a webpage.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetRepository for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetRepository
func (c *CodeCommit) GetRepository(input *GetRepositoryInput) (*GetRepositoryOutput, error) {
	req, out := c.GetRepositoryRequest(input)
	return out, req.Send()
}

// GetRepositoryWithContext is the same as GetRepository with the addition of
// the ability to pass a context and additional request options.
//
// See GetRepository for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetRepositoryWithContext(ctx aws.Context, input *GetRepositoryInput, opts ...request.Option) (*GetRepositoryOutput, error) {
	req, out := c.GetRepositoryRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opGetRepositoryTriggers = "GetRepositoryTriggers"

// GetRepositoryTriggersRequest generates a "aws/request.Request" representing the
// client's request for the GetRepositoryTriggers operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See GetRepositoryTriggers for more information on using the GetRepositoryTriggers
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the GetRepositoryTriggersRequest method.
//    req, resp := client.GetRepositoryTriggersRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetRepositoryTriggers
func (c *CodeCommit) GetRepositoryTriggersRequest(input *GetRepositoryTriggersInput) (req *request.Request, output *GetRepositoryTriggersOutput) {
	op := &request.Operation{
		Name:       opGetRepositoryTriggers,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &GetRepositoryTriggersInput{}
	}

	output = &GetRepositoryTriggersOutput{}
	req = c.newRequest(op, input, output)
	return
}

// GetRepositoryTriggers API operation for AWS CodeCommit.
//
// Gets information about triggers configured for a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation GetRepositoryTriggers for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/GetRepositoryTriggers
func (c *CodeCommit) GetRepositoryTriggers(input *GetRepositoryTriggersInput) (*GetRepositoryTriggersOutput, error) {
	req, out := c.GetRepositoryTriggersRequest(input)
	return out, req.Send()
}

// GetRepositoryTriggersWithContext is the same as GetRepositoryTriggers with the addition of
// the ability to pass a context and additional request options.
//
// See GetRepositoryTriggers for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) GetRepositoryTriggersWithContext(ctx aws.Context, input *GetRepositoryTriggersInput, opts ...request.Option) (*GetRepositoryTriggersOutput, error) {
	req, out := c.GetRepositoryTriggersRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opListApprovalRuleTemplates = "ListApprovalRuleTemplates"

// ListApprovalRuleTemplatesRequest generates a "aws/request.Request" representing the
// client's request for the ListApprovalRuleTemplates operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListApprovalRuleTemplates for more information on using the ListApprovalRuleTemplates
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListApprovalRuleTemplatesRequest method.
//    req, resp := client.ListApprovalRuleTemplatesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListApprovalRuleTemplates
func (c *CodeCommit) ListApprovalRuleTemplatesRequest(input *ListApprovalRuleTemplatesInput) (req *request.Request, output *ListApprovalRuleTemplatesOutput) {
	op := &request.Operation{
		Name:       opListApprovalRuleTemplates,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListApprovalRuleTemplatesInput{}
	}

	output = &ListApprovalRuleTemplatesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListApprovalRuleTemplates API operation for AWS CodeCommit.
//
// Lists all approval rule templates in the specified AWS Region in your AWS
// account. If an AWS Region is not specified, the AWS Region where you are
// signed in is used.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation ListApprovalRuleTemplates for usage and error information.
//
// Returned Error Types:
//   * InvalidMaxResultsException
//   The specified number of maximum results is not valid.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListApprovalRuleTemplates
func (c *CodeCommit) ListApprovalRuleTemplates(input *ListApprovalRuleTemplatesInput) (*ListApprovalRuleTemplatesOutput, error) {
	req, out := c.ListApprovalRuleTemplatesRequest(input)
	return out, req.Send()
}

// ListApprovalRuleTemplatesWithContext is the same as ListApprovalRuleTemplates with the addition of
// the ability to pass a context and additional request options.
//
// See ListApprovalRuleTemplates for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListApprovalRuleTemplatesWithContext(ctx aws.Context, input *ListApprovalRuleTemplatesInput, opts ...request.Option) (*ListApprovalRuleTemplatesOutput, error) {
	req, out := c.ListApprovalRuleTemplatesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListApprovalRuleTemplatesPages iterates over the pages of a ListApprovalRuleTemplates operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListApprovalRuleTemplates method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListApprovalRuleTemplates operation.
//    pageNum := 0
//    err := client.ListApprovalRuleTemplatesPages(params,
//        func(page *codecommit.ListApprovalRuleTemplatesOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) ListApprovalRuleTemplatesPages(input *ListApprovalRuleTemplatesInput, fn func(*ListApprovalRuleTemplatesOutput, bool) bool) error {
	return c.ListApprovalRuleTemplatesPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListApprovalRuleTemplatesPagesWithContext same as ListApprovalRuleTemplatesPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListApprovalRuleTemplatesPagesWithContext(ctx aws.Context, input *ListApprovalRuleTemplatesInput, fn func(*ListApprovalRuleTemplatesOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListApprovalRuleTemplatesInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListApprovalRuleTemplatesRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*ListApprovalRuleTemplatesOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opListAssociatedApprovalRuleTemplatesForRepository = "ListAssociatedApprovalRuleTemplatesForRepository"

// ListAssociatedApprovalRuleTemplatesForRepositoryRequest generates a "aws/request.Request" representing the
// client's request for the ListAssociatedApprovalRuleTemplatesForRepository operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListAssociatedApprovalRuleTemplatesForRepository for more information on using the ListAssociatedApprovalRuleTemplatesForRepository
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListAssociatedApprovalRuleTemplatesForRepositoryRequest method.
//    req, resp := client.ListAssociatedApprovalRuleTemplatesForRepositoryRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListAssociatedApprovalRuleTemplatesForRepository
func (c *CodeCommit) ListAssociatedApprovalRuleTemplatesForRepositoryRequest(input *ListAssociatedApprovalRuleTemplatesForRepositoryInput) (req *request.Request, output *ListAssociatedApprovalRuleTemplatesForRepositoryOutput) {
	op := &request.Operation{
		Name:       opListAssociatedApprovalRuleTemplatesForRepository,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListAssociatedApprovalRuleTemplatesForRepositoryInput{}
	}

	output = &ListAssociatedApprovalRuleTemplatesForRepositoryOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListAssociatedApprovalRuleTemplatesForRepository API operation for AWS CodeCommit.
//
// Lists all approval rule templates that are associated with a specified repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation ListAssociatedApprovalRuleTemplatesForRepository for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidMaxResultsException
//   The specified number of maximum results is not valid.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListAssociatedApprovalRuleTemplatesForRepository
func (c *CodeCommit) ListAssociatedApprovalRuleTemplatesForRepository(input *ListAssociatedApprovalRuleTemplatesForRepositoryInput) (*ListAssociatedApprovalRuleTemplatesForRepositoryOutput, error) {
	req, out := c.ListAssociatedApprovalRuleTemplatesForRepositoryRequest(input)
	return out, req.Send()
}

// ListAssociatedApprovalRuleTemplatesForRepositoryWithContext is the same as ListAssociatedApprovalRuleTemplatesForRepository with the addition of
// the ability to pass a context and additional request options.
//
// See ListAssociatedApprovalRuleTemplatesForRepository for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListAssociatedApprovalRuleTemplatesForRepositoryWithContext(ctx aws.Context, input *ListAssociatedApprovalRuleTemplatesForRepositoryInput, opts ...request.Option) (*ListAssociatedApprovalRuleTemplatesForRepositoryOutput, error) {
	req, out := c.ListAssociatedApprovalRuleTemplatesForRepositoryRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListAssociatedApprovalRuleTemplatesForRepositoryPages iterates over the pages of a ListAssociatedApprovalRuleTemplatesForRepository operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListAssociatedApprovalRuleTemplatesForRepository method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListAssociatedApprovalRuleTemplatesForRepository operation.
//    pageNum := 0
//    err := client.ListAssociatedApprovalRuleTemplatesForRepositoryPages(params,
//        func(page *codecommit.ListAssociatedApprovalRuleTemplatesForRepositoryOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) ListAssociatedApprovalRuleTemplatesForRepositoryPages(input *ListAssociatedApprovalRuleTemplatesForRepositoryInput, fn func(*ListAssociatedApprovalRuleTemplatesForRepositoryOutput, bool) bool) error {
	return c.ListAssociatedApprovalRuleTemplatesForRepositoryPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListAssociatedApprovalRuleTemplatesForRepositoryPagesWithContext same as ListAssociatedApprovalRuleTemplatesForRepositoryPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListAssociatedApprovalRuleTemplatesForRepositoryPagesWithContext(ctx aws.Context, input *ListAssociatedApprovalRuleTemplatesForRepositoryInput, fn func(*ListAssociatedApprovalRuleTemplatesForRepositoryOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListAssociatedApprovalRuleTemplatesForRepositoryInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListAssociatedApprovalRuleTemplatesForRepositoryRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*ListAssociatedApprovalRuleTemplatesForRepositoryOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opListBranches = "ListBranches"

// ListBranchesRequest generates a "aws/request.Request" representing the
// client's request for the ListBranches operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListBranches for more information on using the ListBranches
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListBranchesRequest method.
//    req, resp := client.ListBranchesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListBranches
func (c *CodeCommit) ListBranchesRequest(input *ListBranchesInput) (req *request.Request, output *ListBranchesOutput) {
	op := &request.Operation{
		Name:       opListBranches,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListBranchesInput{}
	}

	output = &ListBranchesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListBranches API operation for AWS CodeCommit.
//
// Gets information about one or more branches in a repository.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation ListBranches for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListBranches
func (c *CodeCommit) ListBranches(input *ListBranchesInput) (*ListBranchesOutput, error) {
	req, out := c.ListBranchesRequest(input)
	return out, req.Send()
}

// ListBranchesWithContext is the same as ListBranches with the addition of
// the ability to pass a context and additional request options.
//
// See ListBranches for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListBranchesWithContext(ctx aws.Context, input *ListBranchesInput, opts ...request.Option) (*ListBranchesOutput, error) {
	req, out := c.ListBranchesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListBranchesPages iterates over the pages of a ListBranches operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListBranches method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListBranches operation.
//    pageNum := 0
//    err := client.ListBranchesPages(params,
//        func(page *codecommit.ListBranchesOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) ListBranchesPages(input *ListBranchesInput, fn func(*ListBranchesOutput, bool) bool) error {
	return c.ListBranchesPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListBranchesPagesWithContext same as ListBranchesPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListBranchesPagesWithContext(ctx aws.Context, input *ListBranchesInput, fn func(*ListBranchesOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListBranchesInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListBranchesRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*ListBranchesOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opListPullRequests = "ListPullRequests"

// ListPullRequestsRequest generates a "aws/request.Request" representing the
// client's request for the ListPullRequests operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListPullRequests for more information on using the ListPullRequests
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListPullRequestsRequest method.
//    req, resp := client.ListPullRequestsRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListPullRequests
func (c *CodeCommit) ListPullRequestsRequest(input *ListPullRequestsInput) (req *request.Request, output *ListPullRequestsOutput) {
	op := &request.Operation{
		Name:       opListPullRequests,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListPullRequestsInput{}
	}

	output = &ListPullRequestsOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListPullRequests API operation for AWS CodeCommit.
//
// Returns a list of pull requests for a specified repository. The return list
// can be refined by pull request status or pull request author ARN.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation ListPullRequests for usage and error information.
//
// Returned Error Types:
//   * InvalidPullRequestStatusException
//   The pull request status is not valid. The only valid values are OPEN and
//   CLOSED.
//
//   * InvalidAuthorArnException
//   The Amazon Resource Name (ARN) is not valid. Make sure that you have provided
//   the full ARN for the author of the pull request, and then try again.
//
//   * AuthorDoesNotExistException
//   The specified Amazon Resource Name (ARN) does not exist in the AWS account.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidMaxResultsException
//   The specified number of maximum results is not valid.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListPullRequests
func (c *CodeCommit) ListPullRequests(input *ListPullRequestsInput) (*ListPullRequestsOutput, error) {
	req, out := c.ListPullRequestsRequest(input)
	return out, req.Send()
}

// ListPullRequestsWithContext is the same as ListPullRequests with the addition of
// the ability to pass a context and additional request options.
//
// See ListPullRequests for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListPullRequestsWithContext(ctx aws.Context, input *ListPullRequestsInput, opts ...request.Option) (*ListPullRequestsOutput, error) {
	req, out := c.ListPullRequestsRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListPullRequestsPages iterates over the pages of a ListPullRequests operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListPullRequests method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListPullRequests operation.
//    pageNum := 0
//    err := client.ListPullRequestsPages(params,
//        func(page *codecommit.ListPullRequestsOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) ListPullRequestsPages(input *ListPullRequestsInput, fn func(*ListPullRequestsOutput, bool) bool) error {
	return c.ListPullRequestsPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListPullRequestsPagesWithContext same as ListPullRequestsPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListPullRequestsPagesWithContext(ctx aws.Context, input *ListPullRequestsInput, fn func(*ListPullRequestsOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListPullRequestsInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListPullRequestsRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*ListPullRequestsOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opListRepositories = "ListRepositories"

// ListRepositoriesRequest generates a "aws/request.Request" representing the
// client's request for the ListRepositories operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListRepositories for more information on using the ListRepositories
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListRepositoriesRequest method.
//    req, resp := client.ListRepositoriesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListRepositories
func (c *CodeCommit) ListRepositoriesRequest(input *ListRepositoriesInput) (req *request.Request, output *ListRepositoriesOutput) {
	op := &request.Operation{
		Name:       opListRepositories,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListRepositoriesInput{}
	}

	output = &ListRepositoriesOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListRepositories API operation for AWS CodeCommit.
//
// Gets information about one or more repositories.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation ListRepositories for usage and error information.
//
// Returned Error Types:
//   * InvalidSortByException
//   The specified sort by value is not valid.
//
//   * InvalidOrderException
//   The specified sort order is not valid.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListRepositories
func (c *CodeCommit) ListRepositories(input *ListRepositoriesInput) (*ListRepositoriesOutput, error) {
	req, out := c.ListRepositoriesRequest(input)
	return out, req.Send()
}

// ListRepositoriesWithContext is the same as ListRepositories with the addition of
// the ability to pass a context and additional request options.
//
// See ListRepositories for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListRepositoriesWithContext(ctx aws.Context, input *ListRepositoriesInput, opts ...request.Option) (*ListRepositoriesOutput, error) {
	req, out := c.ListRepositoriesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListRepositoriesPages iterates over the pages of a ListRepositories operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListRepositories method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListRepositories operation.
//    pageNum := 0
//    err := client.ListRepositoriesPages(params,
//        func(page *codecommit.ListRepositoriesOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) ListRepositoriesPages(input *ListRepositoriesInput, fn func(*ListRepositoriesOutput, bool) bool) error {
	return c.ListRepositoriesPagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListRepositoriesPagesWithContext same as ListRepositoriesPages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListRepositoriesPagesWithContext(ctx aws.Context, input *ListRepositoriesInput, fn func(*ListRepositoriesOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListRepositoriesInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListRepositoriesRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*ListRepositoriesOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opListRepositoriesForApprovalRuleTemplate = "ListRepositoriesForApprovalRuleTemplate"

// ListRepositoriesForApprovalRuleTemplateRequest generates a "aws/request.Request" representing the
// client's request for the ListRepositoriesForApprovalRuleTemplate operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListRepositoriesForApprovalRuleTemplate for more information on using the ListRepositoriesForApprovalRuleTemplate
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListRepositoriesForApprovalRuleTemplateRequest method.
//    req, resp := client.ListRepositoriesForApprovalRuleTemplateRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListRepositoriesForApprovalRuleTemplate
func (c *CodeCommit) ListRepositoriesForApprovalRuleTemplateRequest(input *ListRepositoriesForApprovalRuleTemplateInput) (req *request.Request, output *ListRepositoriesForApprovalRuleTemplateOutput) {
	op := &request.Operation{
		Name:       opListRepositoriesForApprovalRuleTemplate,
		HTTPMethod: "POST",
		HTTPPath:   "/",
		Paginator: &request.Paginator{
			InputTokens:     []string{"nextToken"},
			OutputTokens:    []string{"nextToken"},
			LimitToken:      "maxResults",
			TruncationToken: "",
		},
	}

	if input == nil {
		input = &ListRepositoriesForApprovalRuleTemplateInput{}
	}

	output = &ListRepositoriesForApprovalRuleTemplateOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListRepositoriesForApprovalRuleTemplate API operation for AWS CodeCommit.
//
// Lists all repositories associated with the specified approval rule template.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation ListRepositoriesForApprovalRuleTemplate for usage and error information.
//
// Returned Error Types:
//   * ApprovalRuleTemplateNameRequiredException
//   An approval rule template name is required, but was not specified.
//
//   * InvalidApprovalRuleTemplateNameException
//   The name of the approval rule template is not valid. Template names must
//   be between 1 and 100 valid characters in length. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * ApprovalRuleTemplateDoesNotExistException
//   The specified approval rule template does not exist. Verify that the name
//   is correct and that you are signed in to the AWS Region where the template
//   was created, and then try again.
//
//   * InvalidMaxResultsException
//   The specified number of maximum results is not valid.
//
//   * InvalidContinuationTokenException
//   The specified continuation token is not valid.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListRepositoriesForApprovalRuleTemplate
func (c *CodeCommit) ListRepositoriesForApprovalRuleTemplate(input *ListRepositoriesForApprovalRuleTemplateInput) (*ListRepositoriesForApprovalRuleTemplateOutput, error) {
	req, out := c.ListRepositoriesForApprovalRuleTemplateRequest(input)
	return out, req.Send()
}

// ListRepositoriesForApprovalRuleTemplateWithContext is the same as ListRepositoriesForApprovalRuleTemplate with the addition of
// the ability to pass a context and additional request options.
//
// See ListRepositoriesForApprovalRuleTemplate for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListRepositoriesForApprovalRuleTemplateWithContext(ctx aws.Context, input *ListRepositoriesForApprovalRuleTemplateInput, opts ...request.Option) (*ListRepositoriesForApprovalRuleTemplateOutput, error) {
	req, out := c.ListRepositoriesForApprovalRuleTemplateRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// ListRepositoriesForApprovalRuleTemplatePages iterates over the pages of a ListRepositoriesForApprovalRuleTemplate operation,
// calling the "fn" function with the response data for each page. To stop
// iterating, return false from the fn function.
//
// See ListRepositoriesForApprovalRuleTemplate method for more information on how to use this operation.
//
// Note: This operation can generate multiple requests to a service.
//
//    // Example iterating over at most 3 pages of a ListRepositoriesForApprovalRuleTemplate operation.
//    pageNum := 0
//    err := client.ListRepositoriesForApprovalRuleTemplatePages(params,
//        func(page *codecommit.ListRepositoriesForApprovalRuleTemplateOutput, lastPage bool) bool {
//            pageNum++
//            fmt.Println(page)
//            return pageNum <= 3
//        })
//
func (c *CodeCommit) ListRepositoriesForApprovalRuleTemplatePages(input *ListRepositoriesForApprovalRuleTemplateInput, fn func(*ListRepositoriesForApprovalRuleTemplateOutput, bool) bool) error {
	return c.ListRepositoriesForApprovalRuleTemplatePagesWithContext(aws.BackgroundContext(), input, fn)
}

// ListRepositoriesForApprovalRuleTemplatePagesWithContext same as ListRepositoriesForApprovalRuleTemplatePages except
// it takes a Context and allows setting request options on the pages.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListRepositoriesForApprovalRuleTemplatePagesWithContext(ctx aws.Context, input *ListRepositoriesForApprovalRuleTemplateInput, fn func(*ListRepositoriesForApprovalRuleTemplateOutput, bool) bool, opts ...request.Option) error {
	p := request.Pagination{
		NewRequest: func() (*request.Request, error) {
			var inCpy *ListRepositoriesForApprovalRuleTemplateInput
			if input != nil {
				tmp := *input
				inCpy = &tmp
			}
			req, _ := c.ListRepositoriesForApprovalRuleTemplateRequest(inCpy)
			req.SetContext(ctx)
			req.ApplyOptions(opts...)
			return req, nil
		},
	}

	for p.Next() {
		if !fn(p.Page().(*ListRepositoriesForApprovalRuleTemplateOutput), !p.HasNextPage()) {
			break
		}
	}

	return p.Err()
}

const opListTagsForResource = "ListTagsForResource"

// ListTagsForResourceRequest generates a "aws/request.Request" representing the
// client's request for the ListTagsForResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See ListTagsForResource for more information on using the ListTagsForResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the ListTagsForResourceRequest method.
//    req, resp := client.ListTagsForResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListTagsForResource
func (c *CodeCommit) ListTagsForResourceRequest(input *ListTagsForResourceInput) (req *request.Request, output *ListTagsForResourceOutput) {
	op := &request.Operation{
		Name:       opListTagsForResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &ListTagsForResourceInput{}
	}

	output = &ListTagsForResourceOutput{}
	req = c.newRequest(op, input, output)
	return
}

// ListTagsForResource API operation for AWS CodeCommit.
//
// Gets information about AWS tags for a specified Amazon Resource Name (ARN)
// in AWS CodeCommit. For a list of valid resources in AWS CodeCommit, see CodeCommit
// Resources and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
// in the AWS CodeCommit User Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation ListTagsForResource for usage and error information.
//
// Returned Error Types:
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ResourceArnRequiredException
//   A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required.
//   For a list of valid resources in AWS CodeCommit, see CodeCommit Resources
//   and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
//   in the AWS CodeCommit User Guide.
//
//   * InvalidResourceArnException
//   The value for the resource ARN is not valid. For more information about resources
//   in AWS CodeCommit, see CodeCommit Resources and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
//   in the AWS CodeCommit User Guide.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/ListTagsForResource
func (c *CodeCommit) ListTagsForResource(input *ListTagsForResourceInput) (*ListTagsForResourceOutput, error) {
	req, out := c.ListTagsForResourceRequest(input)
	return out, req.Send()
}

// ListTagsForResourceWithContext is the same as ListTagsForResource with the addition of
// the ability to pass a context and additional request options.
//
// See ListTagsForResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) ListTagsForResourceWithContext(ctx aws.Context, input *ListTagsForResourceInput, opts ...request.Option) (*ListTagsForResourceOutput, error) {
	req, out := c.ListTagsForResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergeBranchesByFastForward = "MergeBranchesByFastForward"

// MergeBranchesByFastForwardRequest generates a "aws/request.Request" representing the
// client's request for the MergeBranchesByFastForward operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergeBranchesByFastForward for more information on using the MergeBranchesByFastForward
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergeBranchesByFastForwardRequest method.
//    req, resp := client.MergeBranchesByFastForwardRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesByFastForward
func (c *CodeCommit) MergeBranchesByFastForwardRequest(input *MergeBranchesByFastForwardInput) (req *request.Request, output *MergeBranchesByFastForwardOutput) {
	op := &request.Operation{
		Name:       opMergeBranchesByFastForward,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergeBranchesByFastForwardInput{}
	}

	output = &MergeBranchesByFastForwardOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergeBranchesByFastForward API operation for AWS CodeCommit.
//
// Merges two branches using the fast-forward merge strategy.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergeBranchesByFastForward for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * TipsDivergenceExceededException
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * CommitRequiredException
//   A commit was not specified.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidTargetBranchException
//   The specified target branch is not valid.
//
//   * InvalidBranchNameException
//   The specified reference name is not valid.
//
//   * BranchNameRequiredException
//   A branch name is required, but was not specified.
//
//   * BranchNameIsTagNameException
//   The specified branch name is not valid because it is a tag name. Enter the
//   name of a branch in the repository. For a list of valid branch names, use
//   ListBranches.
//
//   * BranchDoesNotExistException
//   The specified branch does not exist.
//
//   * ManualMergeRequiredException
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * ConcurrentReferenceUpdateException
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesByFastForward
func (c *CodeCommit) MergeBranchesByFastForward(input *MergeBranchesByFastForwardInput) (*MergeBranchesByFastForwardOutput, error) {
	req, out := c.MergeBranchesByFastForwardRequest(input)
	return out, req.Send()
}

// MergeBranchesByFastForwardWithContext is the same as MergeBranchesByFastForward with the addition of
// the ability to pass a context and additional request options.
//
// See MergeBranchesByFastForward for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergeBranchesByFastForwardWithContext(ctx aws.Context, input *MergeBranchesByFastForwardInput, opts ...request.Option) (*MergeBranchesByFastForwardOutput, error) {
	req, out := c.MergeBranchesByFastForwardRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergeBranchesBySquash = "MergeBranchesBySquash"

// MergeBranchesBySquashRequest generates a "aws/request.Request" representing the
// client's request for the MergeBranchesBySquash operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergeBranchesBySquash for more information on using the MergeBranchesBySquash
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergeBranchesBySquashRequest method.
//    req, resp := client.MergeBranchesBySquashRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesBySquash
func (c *CodeCommit) MergeBranchesBySquashRequest(input *MergeBranchesBySquashInput) (req *request.Request, output *MergeBranchesBySquashOutput) {
	op := &request.Operation{
		Name:       opMergeBranchesBySquash,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergeBranchesBySquashInput{}
	}

	output = &MergeBranchesBySquashOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergeBranchesBySquash API operation for AWS CodeCommit.
//
// Merges two branches using the squash merge strategy.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergeBranchesBySquash for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * TipsDivergenceExceededException
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * CommitRequiredException
//   A commit was not specified.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidTargetBranchException
//   The specified target branch is not valid.
//
//   * InvalidBranchNameException
//   The specified reference name is not valid.
//
//   * BranchNameRequiredException
//   A branch name is required, but was not specified.
//
//   * BranchNameIsTagNameException
//   The specified branch name is not valid because it is a tag name. Enter the
//   name of a branch in the repository. For a list of valid branch names, use
//   ListBranches.
//
//   * BranchDoesNotExistException
//   The specified branch does not exist.
//
//   * ManualMergeRequiredException
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * InvalidConflictDetailLevelException
//   The specified conflict detail level is not valid.
//
//   * InvalidConflictResolutionStrategyException
//   The specified conflict resolution strategy is not valid.
//
//   * InvalidConflictResolutionException
//   The specified conflict resolution list is not valid.
//
//   * MaximumConflictResolutionEntriesExceededException
//   The number of allowed conflict resolution entries was exceeded.
//
//   * MultipleConflictResolutionEntriesException
//   More than one conflict resolution entries exists for the conflict. A conflict
//   can have only one conflict resolution entry.
//
//   * ReplacementTypeRequiredException
//   A replacement type is required.
//
//   * InvalidReplacementTypeException
//   Automerge was specified for resolving the conflict, but the specified replacement
//   type is not valid.
//
//   * ReplacementContentRequiredException
//   USE_NEW_CONTENT was specified, but no replacement content has been provided.
//
//   * InvalidReplacementContentException
//   Automerge was specified for resolving the conflict, but the replacement type
//   is not valid or content is missing.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * FileContentSizeLimitExceededException
//   The file cannot be added because it is too large. The maximum file size is
//   6 MB, and the combined file content change size is 7 MB. Consider making
//   these changes using a Git client.
//
//   * FolderContentSizeLimitExceededException
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * MaximumFileContentToLoadExceededException
//   The number of files to load exceeds the allowed limit.
//
//   * MaximumItemsToCompareExceededException
//   The number of items to compare between the source or destination branches
//   and the merge base has exceeded the maximum allowed.
//
//   * FileModeRequiredException
//   The commit cannot be created because no file mode has been specified. A file
//   mode is required to update mode permissions for a file.
//
//   * InvalidFileModeException
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * NameLengthExceededException
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * InvalidEmailException
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * CommitMessageLengthExceededException
//   The commit message is too long. Provide a shorter string.
//
//   * ConcurrentReferenceUpdateException
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesBySquash
func (c *CodeCommit) MergeBranchesBySquash(input *MergeBranchesBySquashInput) (*MergeBranchesBySquashOutput, error) {
	req, out := c.MergeBranchesBySquashRequest(input)
	return out, req.Send()
}

// MergeBranchesBySquashWithContext is the same as MergeBranchesBySquash with the addition of
// the ability to pass a context and additional request options.
//
// See MergeBranchesBySquash for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergeBranchesBySquashWithContext(ctx aws.Context, input *MergeBranchesBySquashInput, opts ...request.Option) (*MergeBranchesBySquashOutput, error) {
	req, out := c.MergeBranchesBySquashRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergeBranchesByThreeWay = "MergeBranchesByThreeWay"

// MergeBranchesByThreeWayRequest generates a "aws/request.Request" representing the
// client's request for the MergeBranchesByThreeWay operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergeBranchesByThreeWay for more information on using the MergeBranchesByThreeWay
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergeBranchesByThreeWayRequest method.
//    req, resp := client.MergeBranchesByThreeWayRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesByThreeWay
func (c *CodeCommit) MergeBranchesByThreeWayRequest(input *MergeBranchesByThreeWayInput) (req *request.Request, output *MergeBranchesByThreeWayOutput) {
	op := &request.Operation{
		Name:       opMergeBranchesByThreeWay,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergeBranchesByThreeWayInput{}
	}

	output = &MergeBranchesByThreeWayOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergeBranchesByThreeWay API operation for AWS CodeCommit.
//
// Merges two specified branches using the three-way merge strategy.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergeBranchesByThreeWay for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * TipsDivergenceExceededException
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * CommitRequiredException
//   A commit was not specified.
//
//   * InvalidCommitException
//   The specified commit is not valid.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidTargetBranchException
//   The specified target branch is not valid.
//
//   * InvalidBranchNameException
//   The specified reference name is not valid.
//
//   * BranchNameRequiredException
//   A branch name is required, but was not specified.
//
//   * BranchNameIsTagNameException
//   The specified branch name is not valid because it is a tag name. Enter the
//   name of a branch in the repository. For a list of valid branch names, use
//   ListBranches.
//
//   * BranchDoesNotExistException
//   The specified branch does not exist.
//
//   * ManualMergeRequiredException
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * ConcurrentReferenceUpdateException
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * InvalidConflictDetailLevelException
//   The specified conflict detail level is not valid.
//
//   * InvalidConflictResolutionStrategyException
//   The specified conflict resolution strategy is not valid.
//
//   * InvalidConflictResolutionException
//   The specified conflict resolution list is not valid.
//
//   * MaximumConflictResolutionEntriesExceededException
//   The number of allowed conflict resolution entries was exceeded.
//
//   * MultipleConflictResolutionEntriesException
//   More than one conflict resolution entries exists for the conflict. A conflict
//   can have only one conflict resolution entry.
//
//   * ReplacementTypeRequiredException
//   A replacement type is required.
//
//   * InvalidReplacementTypeException
//   Automerge was specified for resolving the conflict, but the specified replacement
//   type is not valid.
//
//   * ReplacementContentRequiredException
//   USE_NEW_CONTENT was specified, but no replacement content has been provided.
//
//   * InvalidReplacementContentException
//   Automerge was specified for resolving the conflict, but the replacement type
//   is not valid or content is missing.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * FileContentSizeLimitExceededException
//   The file cannot be added because it is too large. The maximum file size is
//   6 MB, and the combined file content change size is 7 MB. Consider making
//   these changes using a Git client.
//
//   * FolderContentSizeLimitExceededException
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * MaximumFileContentToLoadExceededException
//   The number of files to load exceeds the allowed limit.
//
//   * MaximumItemsToCompareExceededException
//   The number of items to compare between the source or destination branches
//   and the merge base has exceeded the maximum allowed.
//
//   * FileModeRequiredException
//   The commit cannot be created because no file mode has been specified. A file
//   mode is required to update mode permissions for a file.
//
//   * InvalidFileModeException
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * NameLengthExceededException
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * InvalidEmailException
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * CommitMessageLengthExceededException
//   The commit message is too long. Provide a shorter string.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergeBranchesByThreeWay
func (c *CodeCommit) MergeBranchesByThreeWay(input *MergeBranchesByThreeWayInput) (*MergeBranchesByThreeWayOutput, error) {
	req, out := c.MergeBranchesByThreeWayRequest(input)
	return out, req.Send()
}

// MergeBranchesByThreeWayWithContext is the same as MergeBranchesByThreeWay with the addition of
// the ability to pass a context and additional request options.
//
// See MergeBranchesByThreeWay for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergeBranchesByThreeWayWithContext(ctx aws.Context, input *MergeBranchesByThreeWayInput, opts ...request.Option) (*MergeBranchesByThreeWayOutput, error) {
	req, out := c.MergeBranchesByThreeWayRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergePullRequestByFastForward = "MergePullRequestByFastForward"

// MergePullRequestByFastForwardRequest generates a "aws/request.Request" representing the
// client's request for the MergePullRequestByFastForward operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergePullRequestByFastForward for more information on using the MergePullRequestByFastForward
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergePullRequestByFastForwardRequest method.
//    req, resp := client.MergePullRequestByFastForwardRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestByFastForward
func (c *CodeCommit) MergePullRequestByFastForwardRequest(input *MergePullRequestByFastForwardInput) (req *request.Request, output *MergePullRequestByFastForwardOutput) {
	op := &request.Operation{
		Name:       opMergePullRequestByFastForward,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergePullRequestByFastForwardInput{}
	}

	output = &MergePullRequestByFastForwardOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergePullRequestByFastForward API operation for AWS CodeCommit.
//
// Attempts to merge the source commit of a pull request into the specified
// destination branch for that pull request at the specified commit using the
// fast-forward merge strategy. If the merge is successful, it closes the pull
// request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergePullRequestByFastForward for usage and error information.
//
// Returned Error Types:
//   * ManualMergeRequiredException
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * PullRequestAlreadyClosedException
//   The pull request status cannot be updated because it is already closed.
//
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * TipOfSourceReferenceIsDifferentException
//   The tip of the source branch in the destination repository does not match
//   the tip of the source branch specified in your request. The pull request
//   might have been updated. Make sure that you have the latest changes.
//
//   * ReferenceDoesNotExistException
//   The specified reference does not exist. You must provide a full commit ID.
//
//   * InvalidCommitIdException
//   The specified commit ID is not valid.
//
//   * RepositoryNotAssociatedWithPullRequestException
//   The repository does not contain any pull requests with that pull request
//   ID. Use GetPullRequest to verify the correct repository name for the pull
//   request ID.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * ConcurrentReferenceUpdateException
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * PullRequestApprovalRulesNotSatisfiedException
//   The pull request cannot be merged because one or more approval rules applied
//   to the pull request have conditions that have not been met.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestByFastForward
func (c *CodeCommit) MergePullRequestByFastForward(input *MergePullRequestByFastForwardInput) (*MergePullRequestByFastForwardOutput, error) {
	req, out := c.MergePullRequestByFastForwardRequest(input)
	return out, req.Send()
}

// MergePullRequestByFastForwardWithContext is the same as MergePullRequestByFastForward with the addition of
// the ability to pass a context and additional request options.
//
// See MergePullRequestByFastForward for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergePullRequestByFastForwardWithContext(ctx aws.Context, input *MergePullRequestByFastForwardInput, opts ...request.Option) (*MergePullRequestByFastForwardOutput, error) {
	req, out := c.MergePullRequestByFastForwardRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergePullRequestBySquash = "MergePullRequestBySquash"

// MergePullRequestBySquashRequest generates a "aws/request.Request" representing the
// client's request for the MergePullRequestBySquash operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergePullRequestBySquash for more information on using the MergePullRequestBySquash
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergePullRequestBySquashRequest method.
//    req, resp := client.MergePullRequestBySquashRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestBySquash
func (c *CodeCommit) MergePullRequestBySquashRequest(input *MergePullRequestBySquashInput) (req *request.Request, output *MergePullRequestBySquashOutput) {
	op := &request.Operation{
		Name:       opMergePullRequestBySquash,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergePullRequestBySquashInput{}
	}

	output = &MergePullRequestBySquashOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergePullRequestBySquash API operation for AWS CodeCommit.
//
// Attempts to merge the source commit of a pull request into the specified
// destination branch for that pull request at the specified commit using the
// squash merge strategy. If the merge is successful, it closes the pull request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergePullRequestBySquash for usage and error information.
//
// Returned Error Types:
//   * PullRequestAlreadyClosedException
//   The pull request status cannot be updated because it is already closed.
//
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * InvalidCommitIdException
//   The specified commit ID is not valid.
//
//   * ManualMergeRequiredException
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * TipOfSourceReferenceIsDifferentException
//   The tip of the source branch in the destination repository does not match
//   the tip of the source branch specified in your request. The pull request
//   might have been updated. Make sure that you have the latest changes.
//
//   * TipsDivergenceExceededException
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * NameLengthExceededException
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * InvalidEmailException
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * CommitMessageLengthExceededException
//   The commit message is too long. Provide a shorter string.
//
//   * InvalidConflictDetailLevelException
//   The specified conflict detail level is not valid.
//
//   * InvalidConflictResolutionStrategyException
//   The specified conflict resolution strategy is not valid.
//
//   * InvalidConflictResolutionException
//   The specified conflict resolution list is not valid.
//
//   * ReplacementTypeRequiredException
//   A replacement type is required.
//
//   * InvalidReplacementTypeException
//   Automerge was specified for resolving the conflict, but the specified replacement
//   type is not valid.
//
//   * MultipleConflictResolutionEntriesException
//   More than one conflict resolution entries exists for the conflict. A conflict
//   can have only one conflict resolution entry.
//
//   * ReplacementContentRequiredException
//   USE_NEW_CONTENT was specified, but no replacement content has been provided.
//
//   * MaximumConflictResolutionEntriesExceededException
//   The number of allowed conflict resolution entries was exceeded.
//
//   * ConcurrentReferenceUpdateException
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * InvalidFileModeException
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * InvalidReplacementContentException
//   Automerge was specified for resolving the conflict, but the replacement type
//   is not valid or content is missing.
//
//   * FileContentSizeLimitExceededException
//   The file cannot be added because it is too large. The maximum file size is
//   6 MB, and the combined file content change size is 7 MB. Consider making
//   these changes using a Git client.
//
//   * FolderContentSizeLimitExceededException
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * MaximumFileContentToLoadExceededException
//   The number of files to load exceeds the allowed limit.
//
//   * MaximumItemsToCompareExceededException
//   The number of items to compare between the source or destination branches
//   and the merge base has exceeded the maximum allowed.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * RepositoryNotAssociatedWithPullRequestException
//   The repository does not contain any pull requests with that pull request
//   ID. Use GetPullRequest to verify the correct repository name for the pull
//   request ID.
//
//   * PullRequestApprovalRulesNotSatisfiedException
//   The pull request cannot be merged because one or more approval rules applied
//   to the pull request have conditions that have not been met.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestBySquash
func (c *CodeCommit) MergePullRequestBySquash(input *MergePullRequestBySquashInput) (*MergePullRequestBySquashOutput, error) {
	req, out := c.MergePullRequestBySquashRequest(input)
	return out, req.Send()
}

// MergePullRequestBySquashWithContext is the same as MergePullRequestBySquash with the addition of
// the ability to pass a context and additional request options.
//
// See MergePullRequestBySquash for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergePullRequestBySquashWithContext(ctx aws.Context, input *MergePullRequestBySquashInput, opts ...request.Option) (*MergePullRequestBySquashOutput, error) {
	req, out := c.MergePullRequestBySquashRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opMergePullRequestByThreeWay = "MergePullRequestByThreeWay"

// MergePullRequestByThreeWayRequest generates a "aws/request.Request" representing the
// client's request for the MergePullRequestByThreeWay operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See MergePullRequestByThreeWay for more information on using the MergePullRequestByThreeWay
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the MergePullRequestByThreeWayRequest method.
//    req, resp := client.MergePullRequestByThreeWayRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestByThreeWay
func (c *CodeCommit) MergePullRequestByThreeWayRequest(input *MergePullRequestByThreeWayInput) (req *request.Request, output *MergePullRequestByThreeWayOutput) {
	op := &request.Operation{
		Name:       opMergePullRequestByThreeWay,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &MergePullRequestByThreeWayInput{}
	}

	output = &MergePullRequestByThreeWayOutput{}
	req = c.newRequest(op, input, output)
	return
}

// MergePullRequestByThreeWay API operation for AWS CodeCommit.
//
// Attempts to merge the source commit of a pull request into the specified
// destination branch for that pull request at the specified commit using the
// three-way merge strategy. If the merge is successful, it closes the pull
// request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation MergePullRequestByThreeWay for usage and error information.
//
// Returned Error Types:
//   * PullRequestAlreadyClosedException
//   The pull request status cannot be updated because it is already closed.
//
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * InvalidCommitIdException
//   The specified commit ID is not valid.
//
//   * ManualMergeRequiredException
//   The pull request cannot be merged automatically into the destination branch.
//   You must manually merge the branches and resolve any conflicts.
//
//   * TipOfSourceReferenceIsDifferentException
//   The tip of the source branch in the destination repository does not match
//   the tip of the source branch specified in your request. The pull request
//   might have been updated. Make sure that you have the latest changes.
//
//   * TipsDivergenceExceededException
//   The divergence between the tips of the provided commit specifiers is too
//   great to determine whether there might be any merge conflicts. Locally compare
//   the specifiers using git diff or a diff tool.
//
//   * NameLengthExceededException
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * InvalidEmailException
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * CommitMessageLengthExceededException
//   The commit message is too long. Provide a shorter string.
//
//   * InvalidConflictDetailLevelException
//   The specified conflict detail level is not valid.
//
//   * InvalidConflictResolutionStrategyException
//   The specified conflict resolution strategy is not valid.
//
//   * InvalidConflictResolutionException
//   The specified conflict resolution list is not valid.
//
//   * ReplacementTypeRequiredException
//   A replacement type is required.
//
//   * InvalidReplacementTypeException
//   Automerge was specified for resolving the conflict, but the specified replacement
//   type is not valid.
//
//   * MultipleConflictResolutionEntriesException
//   More than one conflict resolution entries exists for the conflict. A conflict
//   can have only one conflict resolution entry.
//
//   * ReplacementContentRequiredException
//   USE_NEW_CONTENT was specified, but no replacement content has been provided.
//
//   * MaximumConflictResolutionEntriesExceededException
//   The number of allowed conflict resolution entries was exceeded.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * InvalidFileModeException
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * InvalidReplacementContentException
//   Automerge was specified for resolving the conflict, but the replacement type
//   is not valid or content is missing.
//
//   * FileContentSizeLimitExceededException
//   The file cannot be added because it is too large. The maximum file size is
//   6 MB, and the combined file content change size is 7 MB. Consider making
//   these changes using a Git client.
//
//   * FolderContentSizeLimitExceededException
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * MaximumFileContentToLoadExceededException
//   The number of files to load exceeds the allowed limit.
//
//   * MaximumItemsToCompareExceededException
//   The number of items to compare between the source or destination branches
//   and the merge base has exceeded the maximum allowed.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * RepositoryNotAssociatedWithPullRequestException
//   The repository does not contain any pull requests with that pull request
//   ID. Use GetPullRequest to verify the correct repository name for the pull
//   request ID.
//
//   * ConcurrentReferenceUpdateException
//   The merge cannot be completed because the target branch has been modified.
//   Another user might have modified the target branch while the merge was in
//   progress. Wait a few minutes, and then try again.
//
//   * PullRequestApprovalRulesNotSatisfiedException
//   The pull request cannot be merged because one or more approval rules applied
//   to the pull request have conditions that have not been met.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/MergePullRequestByThreeWay
func (c *CodeCommit) MergePullRequestByThreeWay(input *MergePullRequestByThreeWayInput) (*MergePullRequestByThreeWayOutput, error) {
	req, out := c.MergePullRequestByThreeWayRequest(input)
	return out, req.Send()
}

// MergePullRequestByThreeWayWithContext is the same as MergePullRequestByThreeWay with the addition of
// the ability to pass a context and additional request options.
//
// See MergePullRequestByThreeWay for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) MergePullRequestByThreeWayWithContext(ctx aws.Context, input *MergePullRequestByThreeWayInput, opts ...request.Option) (*MergePullRequestByThreeWayOutput, error) {
	req, out := c.MergePullRequestByThreeWayRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opOverridePullRequestApprovalRules = "OverridePullRequestApprovalRules"

// OverridePullRequestApprovalRulesRequest generates a "aws/request.Request" representing the
// client's request for the OverridePullRequestApprovalRules operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See OverridePullRequestApprovalRules for more information on using the OverridePullRequestApprovalRules
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the OverridePullRequestApprovalRulesRequest method.
//    req, resp := client.OverridePullRequestApprovalRulesRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/OverridePullRequestApprovalRules
func (c *CodeCommit) OverridePullRequestApprovalRulesRequest(input *OverridePullRequestApprovalRulesInput) (req *request.Request, output *OverridePullRequestApprovalRulesOutput) {
	op := &request.Operation{
		Name:       opOverridePullRequestApprovalRules,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &OverridePullRequestApprovalRulesInput{}
	}

	output = &OverridePullRequestApprovalRulesOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// OverridePullRequestApprovalRules API operation for AWS CodeCommit.
//
// Sets aside (overrides) all approval rule requirements for a specified pull
// request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation OverridePullRequestApprovalRules for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * InvalidRevisionIdException
//   The revision ID is not valid. Use GetPullRequest to determine the value.
//
//   * RevisionIdRequiredException
//   A revision ID is required, but was not provided.
//
//   * InvalidOverrideStatusException
//   The override status is not valid. Valid statuses are OVERRIDE and REVOKE.
//
//   * OverrideStatusRequiredException
//   An override status is required, but no value was provided. Valid values include
//   OVERRIDE and REVOKE.
//
//   * OverrideAlreadySetException
//   The pull request has already had its approval rules set to override.
//
//   * RevisionNotCurrentException
//   The revision ID provided in the request does not match the current revision
//   ID. Use GetPullRequest to retrieve the current revision ID.
//
//   * PullRequestAlreadyClosedException
//   The pull request status cannot be updated because it is already closed.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/OverridePullRequestApprovalRules
func (c *CodeCommit) OverridePullRequestApprovalRules(input *OverridePullRequestApprovalRulesInput) (*OverridePullRequestApprovalRulesOutput, error) {
	req, out := c.OverridePullRequestApprovalRulesRequest(input)
	return out, req.Send()
}

// OverridePullRequestApprovalRulesWithContext is the same as OverridePullRequestApprovalRules with the addition of
// the ability to pass a context and additional request options.
//
// See OverridePullRequestApprovalRules for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) OverridePullRequestApprovalRulesWithContext(ctx aws.Context, input *OverridePullRequestApprovalRulesInput, opts ...request.Option) (*OverridePullRequestApprovalRulesOutput, error) {
	req, out := c.OverridePullRequestApprovalRulesRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opPostCommentForComparedCommit = "PostCommentForComparedCommit"

// PostCommentForComparedCommitRequest generates a "aws/request.Request" representing the
// client's request for the PostCommentForComparedCommit operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See PostCommentForComparedCommit for more information on using the PostCommentForComparedCommit
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the PostCommentForComparedCommitRequest method.
//    req, resp := client.PostCommentForComparedCommitRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PostCommentForComparedCommit
func (c *CodeCommit) PostCommentForComparedCommitRequest(input *PostCommentForComparedCommitInput) (req *request.Request, output *PostCommentForComparedCommitOutput) {
	op := &request.Operation{
		Name:       opPostCommentForComparedCommit,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PostCommentForComparedCommitInput{}
	}

	output = &PostCommentForComparedCommitOutput{}
	req = c.newRequest(op, input, output)
	return
}

// PostCommentForComparedCommit API operation for AWS CodeCommit.
//
// Posts a comment on the comparison between two commits.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation PostCommentForComparedCommit for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ClientRequestTokenRequiredException
//   A client request token is required. A client request token is an unique,
//   client-generated idempotency token that, when provided in a request, ensures
//   the request cannot be repeated with a changed parameter. If a request is
//   received with the same parameters and a token is included, the request returns
//   information about the initial request that used that token.
//
//   * InvalidClientRequestTokenException
//   The client request token is not valid.
//
//   * IdempotencyParameterMismatchException
//   The client request token is not valid. Either the token is not in a valid
//   format, or the token has been used in a previous request and cannot be reused.
//
//   * CommentContentRequiredException
//   The comment is empty. You must provide some content for a comment. The content
//   cannot be null.
//
//   * CommentContentSizeLimitExceededException
//   The comment is too large. Comments are limited to 1,000 characters.
//
//   * InvalidFileLocationException
//   The location of the file is not valid. Make sure that you include the file
//   name and extension.
//
//   * InvalidRelativeFileVersionEnumException
//   Either the enum is not in a valid format, or the specified file version enum
//   is not valid in respect to the current file version.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidFilePositionException
//   The position is not valid. Make sure that the line number exists in the version
//   of the file you want to comment on.
//
//   * CommitIdRequiredException
//   A commit ID was not specified.
//
//   * InvalidCommitIdException
//   The specified commit ID is not valid.
//
//   * BeforeCommitIdAndAfterCommitIdAreSameException
//   The before commit ID and the after commit ID are the same, which is not valid.
//   The before commit ID and the after commit ID must be different commit IDs.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * PathDoesNotExistException
//   The specified path does not exist.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PostCommentForComparedCommit
func (c *CodeCommit) PostCommentForComparedCommit(input *PostCommentForComparedCommitInput) (*PostCommentForComparedCommitOutput, error) {
	req, out := c.PostCommentForComparedCommitRequest(input)
	return out, req.Send()
}

// PostCommentForComparedCommitWithContext is the same as PostCommentForComparedCommit with the addition of
// the ability to pass a context and additional request options.
//
// See PostCommentForComparedCommit for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) PostCommentForComparedCommitWithContext(ctx aws.Context, input *PostCommentForComparedCommitInput, opts ...request.Option) (*PostCommentForComparedCommitOutput, error) {
	req, out := c.PostCommentForComparedCommitRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opPostCommentForPullRequest = "PostCommentForPullRequest"

// PostCommentForPullRequestRequest generates a "aws/request.Request" representing the
// client's request for the PostCommentForPullRequest operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See PostCommentForPullRequest for more information on using the PostCommentForPullRequest
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the PostCommentForPullRequestRequest method.
//    req, resp := client.PostCommentForPullRequestRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PostCommentForPullRequest
func (c *CodeCommit) PostCommentForPullRequestRequest(input *PostCommentForPullRequestInput) (req *request.Request, output *PostCommentForPullRequestOutput) {
	op := &request.Operation{
		Name:       opPostCommentForPullRequest,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PostCommentForPullRequestInput{}
	}

	output = &PostCommentForPullRequestOutput{}
	req = c.newRequest(op, input, output)
	return
}

// PostCommentForPullRequest API operation for AWS CodeCommit.
//
// Posts a comment on a pull request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation PostCommentForPullRequest for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * RepositoryNotAssociatedWithPullRequestException
//   The repository does not contain any pull requests with that pull request
//   ID. Use GetPullRequest to verify the correct repository name for the pull
//   request ID.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ClientRequestTokenRequiredException
//   A client request token is required. A client request token is an unique,
//   client-generated idempotency token that, when provided in a request, ensures
//   the request cannot be repeated with a changed parameter. If a request is
//   received with the same parameters and a token is included, the request returns
//   information about the initial request that used that token.
//
//   * InvalidClientRequestTokenException
//   The client request token is not valid.
//
//   * IdempotencyParameterMismatchException
//   The client request token is not valid. Either the token is not in a valid
//   format, or the token has been used in a previous request and cannot be reused.
//
//   * CommentContentRequiredException
//   The comment is empty. You must provide some content for a comment. The content
//   cannot be null.
//
//   * CommentContentSizeLimitExceededException
//   The comment is too large. Comments are limited to 1,000 characters.
//
//   * InvalidFileLocationException
//   The location of the file is not valid. Make sure that you include the file
//   name and extension.
//
//   * InvalidRelativeFileVersionEnumException
//   Either the enum is not in a valid format, or the specified file version enum
//   is not valid in respect to the current file version.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidFilePositionException
//   The position is not valid. Make sure that the line number exists in the version
//   of the file you want to comment on.
//
//   * CommitIdRequiredException
//   A commit ID was not specified.
//
//   * InvalidCommitIdException
//   The specified commit ID is not valid.
//
//   * BeforeCommitIdAndAfterCommitIdAreSameException
//   The before commit ID and the after commit ID are the same, which is not valid.
//   The before commit ID and the after commit ID must be different commit IDs.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
//   * CommitDoesNotExistException
//   The specified commit does not exist or no commit was specified, and the specified
//   repository has no default branch.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * PathDoesNotExistException
//   The specified path does not exist.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PostCommentForPullRequest
func (c *CodeCommit) PostCommentForPullRequest(input *PostCommentForPullRequestInput) (*PostCommentForPullRequestOutput, error) {
	req, out := c.PostCommentForPullRequestRequest(input)
	return out, req.Send()
}

// PostCommentForPullRequestWithContext is the same as PostCommentForPullRequest with the addition of
// the ability to pass a context and additional request options.
//
// See PostCommentForPullRequest for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) PostCommentForPullRequestWithContext(ctx aws.Context, input *PostCommentForPullRequestInput, opts ...request.Option) (*PostCommentForPullRequestOutput, error) {
	req, out := c.PostCommentForPullRequestRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opPostCommentReply = "PostCommentReply"

// PostCommentReplyRequest generates a "aws/request.Request" representing the
// client's request for the PostCommentReply operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See PostCommentReply for more information on using the PostCommentReply
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the PostCommentReplyRequest method.
//    req, resp := client.PostCommentReplyRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PostCommentReply
func (c *CodeCommit) PostCommentReplyRequest(input *PostCommentReplyInput) (req *request.Request, output *PostCommentReplyOutput) {
	op := &request.Operation{
		Name:       opPostCommentReply,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PostCommentReplyInput{}
	}

	output = &PostCommentReplyOutput{}
	req = c.newRequest(op, input, output)
	return
}

// PostCommentReply API operation for AWS CodeCommit.
//
// Posts a comment in reply to an existing comment on a comparison between commits
// or a pull request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation PostCommentReply for usage and error information.
//
// Returned Error Types:
//   * ClientRequestTokenRequiredException
//   A client request token is required. A client request token is an unique,
//   client-generated idempotency token that, when provided in a request, ensures
//   the request cannot be repeated with a changed parameter. If a request is
//   received with the same parameters and a token is included, the request returns
//   information about the initial request that used that token.
//
//   * InvalidClientRequestTokenException
//   The client request token is not valid.
//
//   * IdempotencyParameterMismatchException
//   The client request token is not valid. Either the token is not in a valid
//   format, or the token has been used in a previous request and cannot be reused.
//
//   * CommentContentRequiredException
//   The comment is empty. You must provide some content for a comment. The content
//   cannot be null.
//
//   * CommentContentSizeLimitExceededException
//   The comment is too large. Comments are limited to 1,000 characters.
//
//   * CommentDoesNotExistException
//   No comment exists with the provided ID. Verify that you have used the correct
//   ID, and then try again.
//
//   * CommentIdRequiredException
//   The comment ID is missing or null. A comment ID is required.
//
//   * InvalidCommentIdException
//   The comment ID is not in a valid format. Make sure that you have provided
//   the full comment ID.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PostCommentReply
func (c *CodeCommit) PostCommentReply(input *PostCommentReplyInput) (*PostCommentReplyOutput, error) {
	req, out := c.PostCommentReplyRequest(input)
	return out, req.Send()
}

// PostCommentReplyWithContext is the same as PostCommentReply with the addition of
// the ability to pass a context and additional request options.
//
// See PostCommentReply for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) PostCommentReplyWithContext(ctx aws.Context, input *PostCommentReplyInput, opts ...request.Option) (*PostCommentReplyOutput, error) {
	req, out := c.PostCommentReplyRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opPutCommentReaction = "PutCommentReaction"

// PutCommentReactionRequest generates a "aws/request.Request" representing the
// client's request for the PutCommentReaction operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See PutCommentReaction for more information on using the PutCommentReaction
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the PutCommentReactionRequest method.
//    req, resp := client.PutCommentReactionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PutCommentReaction
func (c *CodeCommit) PutCommentReactionRequest(input *PutCommentReactionInput) (req *request.Request, output *PutCommentReactionOutput) {
	op := &request.Operation{
		Name:       opPutCommentReaction,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PutCommentReactionInput{}
	}

	output = &PutCommentReactionOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// PutCommentReaction API operation for AWS CodeCommit.
//
// Adds or updates a reaction to a specified comment for the user whose identity
// is used to make the request. You can only add or update a reaction for yourself.
// You cannot add, modify, or delete a reaction for another user.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation PutCommentReaction for usage and error information.
//
// Returned Error Types:
//   * CommentDoesNotExistException
//   No comment exists with the provided ID. Verify that you have used the correct
//   ID, and then try again.
//
//   * CommentIdRequiredException
//   The comment ID is missing or null. A comment ID is required.
//
//   * InvalidCommentIdException
//   The comment ID is not in a valid format. Make sure that you have provided
//   the full comment ID.
//
//   * InvalidReactionValueException
//   The value of the reaction is not valid. For more information, see the AWS
//   CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html).
//
//   * ReactionValueRequiredException
//   A reaction value is required.
//
//   * ReactionLimitExceededException
//   The number of reactions has been exceeded. Reactions are limited to one reaction
//   per user for each individual comment ID.
//
//   * CommentDeletedException
//   This comment has already been deleted. You cannot edit or delete a deleted
//   comment.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PutCommentReaction
func (c *CodeCommit) PutCommentReaction(input *PutCommentReactionInput) (*PutCommentReactionOutput, error) {
	req, out := c.PutCommentReactionRequest(input)
	return out, req.Send()
}

// PutCommentReactionWithContext is the same as PutCommentReaction with the addition of
// the ability to pass a context and additional request options.
//
// See PutCommentReaction for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) PutCommentReactionWithContext(ctx aws.Context, input *PutCommentReactionInput, opts ...request.Option) (*PutCommentReactionOutput, error) {
	req, out := c.PutCommentReactionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opPutFile = "PutFile"

// PutFileRequest generates a "aws/request.Request" representing the
// client's request for the PutFile operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See PutFile for more information on using the PutFile
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the PutFileRequest method.
//    req, resp := client.PutFileRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PutFile
func (c *CodeCommit) PutFileRequest(input *PutFileInput) (req *request.Request, output *PutFileOutput) {
	op := &request.Operation{
		Name:       opPutFile,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PutFileInput{}
	}

	output = &PutFileOutput{}
	req = c.newRequest(op, input, output)
	return
}

// PutFile API operation for AWS CodeCommit.
//
// Adds or updates a file in a branch in an AWS CodeCommit repository, and generates
// a commit for the addition in the specified branch.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation PutFile for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * ParentCommitIdRequiredException
//   A parent commit ID is required. To view the full commit ID of a branch in
//   a repository, use GetBranch or a Git command (for example, git pull or git
//   log).
//
//   * InvalidParentCommitIdException
//   The parent commit ID is not valid. The commit ID cannot be empty, and must
//   match the head commit ID for the branch of the repository where you want
//   to add or update a file.
//
//   * ParentCommitDoesNotExistException
//   The parent commit ID is not valid because it does not exist. The specified
//   parent commit ID does not exist in the specified branch of the repository.
//
//   * ParentCommitIdOutdatedException
//   The file could not be added because the provided parent commit ID is not
//   the current tip of the specified branch. To view the full commit ID of the
//   current head of the branch, use GetBranch.
//
//   * FileContentRequiredException
//   The file cannot be added because it is empty. Empty files cannot be added
//   to the repository with this API.
//
//   * FileContentSizeLimitExceededException
//   The file cannot be added because it is too large. The maximum file size is
//   6 MB, and the combined file content change size is 7 MB. Consider making
//   these changes using a Git client.
//
//   * FolderContentSizeLimitExceededException
//   The commit cannot be created because at least one of the overall changes
//   in the commit results in a folder whose contents exceed the limit of 6 MB.
//   Either reduce the number and size of your changes, or split the changes across
//   multiple folders.
//
//   * PathRequiredException
//   The folderPath for a location cannot be null.
//
//   * InvalidPathException
//   The specified path is not valid.
//
//   * BranchNameRequiredException
//   A branch name is required, but was not specified.
//
//   * InvalidBranchNameException
//   The specified reference name is not valid.
//
//   * BranchDoesNotExistException
//   The specified branch does not exist.
//
//   * BranchNameIsTagNameException
//   The specified branch name is not valid because it is a tag name. Enter the
//   name of a branch in the repository. For a list of valid branch names, use
//   ListBranches.
//
//   * InvalidFileModeException
//   The specified file mode permission is not valid. For a list of valid file
//   mode permissions, see PutFile.
//
//   * NameLengthExceededException
//   The user name is not valid because it has exceeded the character limit for
//   author names.
//
//   * InvalidEmailException
//   The specified email address either contains one or more characters that are
//   not allowed, or it exceeds the maximum number of characters allowed for an
//   email address.
//
//   * CommitMessageLengthExceededException
//   The commit message is too long. Provide a shorter string.
//
//   * InvalidDeletionParameterException
//   The specified deletion parameter is not valid.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
//   * SameFileContentException
//   The file was not added or updated because the content of the file is exactly
//   the same as the content of that file in the repository and branch that you
//   specified.
//
//   * FileNameConflictsWithDirectoryNameException
//   A file cannot be added to the repository because the specified file name
//   has the same name as a directory in this repository. Either provide another
//   name for the file, or add the file in a directory that does not match the
//   file name.
//
//   * DirectoryNameConflictsWithFileNameException
//   A file cannot be added to the repository because the specified path name
//   has the same name as a file that already exists in this repository. Either
//   provide a different name for the file, or specify a different path for the
//   file.
//
//   * FilePathConflictsWithSubmodulePathException
//   The commit cannot be created because a specified file path points to a submodule.
//   Verify that the destination files have valid file paths that do not point
//   to a submodule.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PutFile
func (c *CodeCommit) PutFile(input *PutFileInput) (*PutFileOutput, error) {
	req, out := c.PutFileRequest(input)
	return out, req.Send()
}

// PutFileWithContext is the same as PutFile with the addition of
// the ability to pass a context and additional request options.
//
// See PutFile for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) PutFileWithContext(ctx aws.Context, input *PutFileInput, opts ...request.Option) (*PutFileOutput, error) {
	req, out := c.PutFileRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opPutRepositoryTriggers = "PutRepositoryTriggers"

// PutRepositoryTriggersRequest generates a "aws/request.Request" representing the
// client's request for the PutRepositoryTriggers operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See PutRepositoryTriggers for more information on using the PutRepositoryTriggers
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the PutRepositoryTriggersRequest method.
//    req, resp := client.PutRepositoryTriggersRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PutRepositoryTriggers
func (c *CodeCommit) PutRepositoryTriggersRequest(input *PutRepositoryTriggersInput) (req *request.Request, output *PutRepositoryTriggersOutput) {
	op := &request.Operation{
		Name:       opPutRepositoryTriggers,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &PutRepositoryTriggersInput{}
	}

	output = &PutRepositoryTriggersOutput{}
	req = c.newRequest(op, input, output)
	return
}

// PutRepositoryTriggers API operation for AWS CodeCommit.
//
// Replaces all triggers for a repository. Used to create or delete triggers.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation PutRepositoryTriggers for usage and error information.
//
// Returned Error Types:
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryTriggersListRequiredException
//   The list of triggers for the repository is required, but was not specified.
//
//   * MaximumRepositoryTriggersExceededException
//   The number of triggers allowed for the repository was exceeded.
//
//   * InvalidRepositoryTriggerNameException
//   The name of the trigger is not valid.
//
//   * InvalidRepositoryTriggerDestinationArnException
//   The Amazon Resource Name (ARN) for the trigger is not valid for the specified
//   destination. The most common reason for this error is that the ARN does not
//   meet the requirements for the service type.
//
//   * InvalidRepositoryTriggerRegionException
//   The AWS Region for the trigger target does not match the AWS Region for the
//   repository. Triggers must be created in the same Region as the target for
//   the trigger.
//
//   * InvalidRepositoryTriggerCustomDataException
//   The custom data provided for the trigger is not valid.
//
//   * MaximumBranchesExceededException
//   The number of branches for the trigger was exceeded.
//
//   * InvalidRepositoryTriggerBranchNameException
//   One or more branch names specified for the trigger is not valid.
//
//   * InvalidRepositoryTriggerEventsException
//   One or more events specified for the trigger is not valid. Check to make
//   sure that all events specified match the requirements for allowed events.
//
//   * RepositoryTriggerNameRequiredException
//   A name for the trigger is required, but was not specified.
//
//   * RepositoryTriggerDestinationArnRequiredException
//   A destination ARN for the target service for the trigger is required, but
//   was not specified.
//
//   * RepositoryTriggerBranchNameListRequiredException
//   At least one branch name is required, but was not specified in the trigger
//   configuration.
//
//   * RepositoryTriggerEventsListRequiredException
//   At least one event for the trigger is required, but was not specified.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/PutRepositoryTriggers
func (c *CodeCommit) PutRepositoryTriggers(input *PutRepositoryTriggersInput) (*PutRepositoryTriggersOutput, error) {
	req, out := c.PutRepositoryTriggersRequest(input)
	return out, req.Send()
}

// PutRepositoryTriggersWithContext is the same as PutRepositoryTriggers with the addition of
// the ability to pass a context and additional request options.
//
// See PutRepositoryTriggers for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) PutRepositoryTriggersWithContext(ctx aws.Context, input *PutRepositoryTriggersInput, opts ...request.Option) (*PutRepositoryTriggersOutput, error) {
	req, out := c.PutRepositoryTriggersRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opTagResource = "TagResource"

// TagResourceRequest generates a "aws/request.Request" representing the
// client's request for the TagResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See TagResource for more information on using the TagResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the TagResourceRequest method.
//    req, resp := client.TagResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/TagResource
func (c *CodeCommit) TagResourceRequest(input *TagResourceInput) (req *request.Request, output *TagResourceOutput) {
	op := &request.Operation{
		Name:       opTagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &TagResourceInput{}
	}

	output = &TagResourceOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// TagResource API operation for AWS CodeCommit.
//
// Adds or updates tags for a resource in AWS CodeCommit. For a list of valid
// resources in AWS CodeCommit, see CodeCommit Resources and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
// in the AWS CodeCommit User Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation TagResource for usage and error information.
//
// Returned Error Types:
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ResourceArnRequiredException
//   A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required.
//   For a list of valid resources in AWS CodeCommit, see CodeCommit Resources
//   and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
//   in the AWS CodeCommit User Guide.
//
//   * InvalidResourceArnException
//   The value for the resource ARN is not valid. For more information about resources
//   in AWS CodeCommit, see CodeCommit Resources and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
//   in the AWS CodeCommit User Guide.
//
//   * TagsMapRequiredException
//   A map of tags is required.
//
//   * InvalidTagsMapException
//   The map of tags is not valid.
//
//   * TooManyTagsException
//   The maximum number of tags for an AWS CodeCommit resource has been exceeded.
//
//   * InvalidSystemTagUsageException
//   The specified tag is not valid. Key names cannot be prefixed with aws:.
//
//   * TagPolicyException
//   The tag policy is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/TagResource
func (c *CodeCommit) TagResource(input *TagResourceInput) (*TagResourceOutput, error) {
	req, out := c.TagResourceRequest(input)
	return out, req.Send()
}

// TagResourceWithContext is the same as TagResource with the addition of
// the ability to pass a context and additional request options.
//
// See TagResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) TagResourceWithContext(ctx aws.Context, input *TagResourceInput, opts ...request.Option) (*TagResourceOutput, error) {
	req, out := c.TagResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opTestRepositoryTriggers = "TestRepositoryTriggers"

// TestRepositoryTriggersRequest generates a "aws/request.Request" representing the
// client's request for the TestRepositoryTriggers operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See TestRepositoryTriggers for more information on using the TestRepositoryTriggers
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the TestRepositoryTriggersRequest method.
//    req, resp := client.TestRepositoryTriggersRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/TestRepositoryTriggers
func (c *CodeCommit) TestRepositoryTriggersRequest(input *TestRepositoryTriggersInput) (req *request.Request, output *TestRepositoryTriggersOutput) {
	op := &request.Operation{
		Name:       opTestRepositoryTriggers,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &TestRepositoryTriggersInput{}
	}

	output = &TestRepositoryTriggersOutput{}
	req = c.newRequest(op, input, output)
	return
}

// TestRepositoryTriggers API operation for AWS CodeCommit.
//
// Tests the functionality of repository triggers by sending information to
// the trigger target. If real data is available in the repository, the test
// sends data from the last commit. If no data is available, sample data is
// generated.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation TestRepositoryTriggers for usage and error information.
//
// Returned Error Types:
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * RepositoryTriggersListRequiredException
//   The list of triggers for the repository is required, but was not specified.
//
//   * MaximumRepositoryTriggersExceededException
//   The number of triggers allowed for the repository was exceeded.
//
//   * InvalidRepositoryTriggerNameException
//   The name of the trigger is not valid.
//
//   * InvalidRepositoryTriggerDestinationArnException
//   The Amazon Resource Name (ARN) for the trigger is not valid for the specified
//   destination. The most common reason for this error is that the ARN does not
//   meet the requirements for the service type.
//
//   * InvalidRepositoryTriggerRegionException
//   The AWS Region for the trigger target does not match the AWS Region for the
//   repository. Triggers must be created in the same Region as the target for
//   the trigger.
//
//   * InvalidRepositoryTriggerCustomDataException
//   The custom data provided for the trigger is not valid.
//
//   * MaximumBranchesExceededException
//   The number of branches for the trigger was exceeded.
//
//   * InvalidRepositoryTriggerBranchNameException
//   One or more branch names specified for the trigger is not valid.
//
//   * InvalidRepositoryTriggerEventsException
//   One or more events specified for the trigger is not valid. Check to make
//   sure that all events specified match the requirements for allowed events.
//
//   * RepositoryTriggerNameRequiredException
//   A name for the trigger is required, but was not specified.
//
//   * RepositoryTriggerDestinationArnRequiredException
//   A destination ARN for the target service for the trigger is required, but
//   was not specified.
//
//   * RepositoryTriggerBranchNameListRequiredException
//   At least one branch name is required, but was not specified in the trigger
//   configuration.
//
//   * RepositoryTriggerEventsListRequiredException
//   At least one event for the trigger is required, but was not specified.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/TestRepositoryTriggers
func (c *CodeCommit) TestRepositoryTriggers(input *TestRepositoryTriggersInput) (*TestRepositoryTriggersOutput, error) {
	req, out := c.TestRepositoryTriggersRequest(input)
	return out, req.Send()
}

// TestRepositoryTriggersWithContext is the same as TestRepositoryTriggers with the addition of
// the ability to pass a context and additional request options.
//
// See TestRepositoryTriggers for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) TestRepositoryTriggersWithContext(ctx aws.Context, input *TestRepositoryTriggersInput, opts ...request.Option) (*TestRepositoryTriggersOutput, error) {
	req, out := c.TestRepositoryTriggersRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUntagResource = "UntagResource"

// UntagResourceRequest generates a "aws/request.Request" representing the
// client's request for the UntagResource operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UntagResource for more information on using the UntagResource
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UntagResourceRequest method.
//    req, resp := client.UntagResourceRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UntagResource
func (c *CodeCommit) UntagResourceRequest(input *UntagResourceInput) (req *request.Request, output *UntagResourceOutput) {
	op := &request.Operation{
		Name:       opUntagResource,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UntagResourceInput{}
	}

	output = &UntagResourceOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// UntagResource API operation for AWS CodeCommit.
//
// Removes tags for a resource in AWS CodeCommit. For a list of valid resources
// in AWS CodeCommit, see CodeCommit Resources and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
// in the AWS CodeCommit User Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UntagResource for usage and error information.
//
// Returned Error Types:
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * ResourceArnRequiredException
//   A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required.
//   For a list of valid resources in AWS CodeCommit, see CodeCommit Resources
//   and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
//   in the AWS CodeCommit User Guide.
//
//   * InvalidResourceArnException
//   The value for the resource ARN is not valid. For more information about resources
//   in AWS CodeCommit, see CodeCommit Resources and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
//   in the AWS CodeCommit User Guide.
//
//   * TagKeysListRequiredException
//   A list of tag keys is required. The list cannot be empty or null.
//
//   * InvalidTagKeysListException
//   The list of tags is not valid.
//
//   * TooManyTagsException
//   The maximum number of tags for an AWS CodeCommit resource has been exceeded.
//
//   * InvalidSystemTagUsageException
//   The specified tag is not valid. Key names cannot be prefixed with aws:.
//
//   * TagPolicyException
//   The tag policy is not valid.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UntagResource
func (c *CodeCommit) UntagResource(input *UntagResourceInput) (*UntagResourceOutput, error) {
	req, out := c.UntagResourceRequest(input)
	return out, req.Send()
}

// UntagResourceWithContext is the same as UntagResource with the addition of
// the ability to pass a context and additional request options.
//
// See UntagResource for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UntagResourceWithContext(ctx aws.Context, input *UntagResourceInput, opts ...request.Option) (*UntagResourceOutput, error) {
	req, out := c.UntagResourceRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateApprovalRuleTemplateContent = "UpdateApprovalRuleTemplateContent"

// UpdateApprovalRuleTemplateContentRequest generates a "aws/request.Request" representing the
// client's request for the UpdateApprovalRuleTemplateContent operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateApprovalRuleTemplateContent for more information on using the UpdateApprovalRuleTemplateContent
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateApprovalRuleTemplateContentRequest method.
//    req, resp := client.UpdateApprovalRuleTemplateContentRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateApprovalRuleTemplateContent
func (c *CodeCommit) UpdateApprovalRuleTemplateContentRequest(input *UpdateApprovalRuleTemplateContentInput) (req *request.Request, output *UpdateApprovalRuleTemplateContentOutput) {
	op := &request.Operation{
		Name:       opUpdateApprovalRuleTemplateContent,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateApprovalRuleTemplateContentInput{}
	}

	output = &UpdateApprovalRuleTemplateContentOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateApprovalRuleTemplateContent API operation for AWS CodeCommit.
//
// Updates the content of an approval rule template. You can change the number
// of required approvals, the membership of the approval rule, and whether an
// approval pool is defined.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdateApprovalRuleTemplateContent for usage and error information.
//
// Returned Error Types:
//   * InvalidApprovalRuleTemplateNameException
//   The name of the approval rule template is not valid. Template names must
//   be between 1 and 100 valid characters in length. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * ApprovalRuleTemplateNameRequiredException
//   An approval rule template name is required, but was not specified.
//
//   * ApprovalRuleTemplateDoesNotExistException
//   The specified approval rule template does not exist. Verify that the name
//   is correct and that you are signed in to the AWS Region where the template
//   was created, and then try again.
//
//   * InvalidApprovalRuleTemplateContentException
//   The content of the approval rule template is not valid.
//
//   * InvalidRuleContentSha256Exception
//   The SHA-256 hash signature for the rule content is not valid.
//
//   * ApprovalRuleTemplateContentRequiredException
//   The content for the approval rule template is empty. You must provide some
//   content for an approval rule template. The content cannot be null.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateApprovalRuleTemplateContent
func (c *CodeCommit) UpdateApprovalRuleTemplateContent(input *UpdateApprovalRuleTemplateContentInput) (*UpdateApprovalRuleTemplateContentOutput, error) {
	req, out := c.UpdateApprovalRuleTemplateContentRequest(input)
	return out, req.Send()
}

// UpdateApprovalRuleTemplateContentWithContext is the same as UpdateApprovalRuleTemplateContent with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateApprovalRuleTemplateContent for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdateApprovalRuleTemplateContentWithContext(ctx aws.Context, input *UpdateApprovalRuleTemplateContentInput, opts ...request.Option) (*UpdateApprovalRuleTemplateContentOutput, error) {
	req, out := c.UpdateApprovalRuleTemplateContentRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateApprovalRuleTemplateDescription = "UpdateApprovalRuleTemplateDescription"

// UpdateApprovalRuleTemplateDescriptionRequest generates a "aws/request.Request" representing the
// client's request for the UpdateApprovalRuleTemplateDescription operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateApprovalRuleTemplateDescription for more information on using the UpdateApprovalRuleTemplateDescription
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateApprovalRuleTemplateDescriptionRequest method.
//    req, resp := client.UpdateApprovalRuleTemplateDescriptionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateApprovalRuleTemplateDescription
func (c *CodeCommit) UpdateApprovalRuleTemplateDescriptionRequest(input *UpdateApprovalRuleTemplateDescriptionInput) (req *request.Request, output *UpdateApprovalRuleTemplateDescriptionOutput) {
	op := &request.Operation{
		Name:       opUpdateApprovalRuleTemplateDescription,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateApprovalRuleTemplateDescriptionInput{}
	}

	output = &UpdateApprovalRuleTemplateDescriptionOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateApprovalRuleTemplateDescription API operation for AWS CodeCommit.
//
// Updates the description for a specified approval rule template.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdateApprovalRuleTemplateDescription for usage and error information.
//
// Returned Error Types:
//   * InvalidApprovalRuleTemplateNameException
//   The name of the approval rule template is not valid. Template names must
//   be between 1 and 100 valid characters in length. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * ApprovalRuleTemplateNameRequiredException
//   An approval rule template name is required, but was not specified.
//
//   * ApprovalRuleTemplateDoesNotExistException
//   The specified approval rule template does not exist. Verify that the name
//   is correct and that you are signed in to the AWS Region where the template
//   was created, and then try again.
//
//   * InvalidApprovalRuleTemplateDescriptionException
//   The description for the approval rule template is not valid because it exceeds
//   the maximum characters allowed for a description. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateApprovalRuleTemplateDescription
func (c *CodeCommit) UpdateApprovalRuleTemplateDescription(input *UpdateApprovalRuleTemplateDescriptionInput) (*UpdateApprovalRuleTemplateDescriptionOutput, error) {
	req, out := c.UpdateApprovalRuleTemplateDescriptionRequest(input)
	return out, req.Send()
}

// UpdateApprovalRuleTemplateDescriptionWithContext is the same as UpdateApprovalRuleTemplateDescription with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateApprovalRuleTemplateDescription for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdateApprovalRuleTemplateDescriptionWithContext(ctx aws.Context, input *UpdateApprovalRuleTemplateDescriptionInput, opts ...request.Option) (*UpdateApprovalRuleTemplateDescriptionOutput, error) {
	req, out := c.UpdateApprovalRuleTemplateDescriptionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateApprovalRuleTemplateName = "UpdateApprovalRuleTemplateName"

// UpdateApprovalRuleTemplateNameRequest generates a "aws/request.Request" representing the
// client's request for the UpdateApprovalRuleTemplateName operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateApprovalRuleTemplateName for more information on using the UpdateApprovalRuleTemplateName
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateApprovalRuleTemplateNameRequest method.
//    req, resp := client.UpdateApprovalRuleTemplateNameRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateApprovalRuleTemplateName
func (c *CodeCommit) UpdateApprovalRuleTemplateNameRequest(input *UpdateApprovalRuleTemplateNameInput) (req *request.Request, output *UpdateApprovalRuleTemplateNameOutput) {
	op := &request.Operation{
		Name:       opUpdateApprovalRuleTemplateName,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateApprovalRuleTemplateNameInput{}
	}

	output = &UpdateApprovalRuleTemplateNameOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateApprovalRuleTemplateName API operation for AWS CodeCommit.
//
// Updates the name of a specified approval rule template.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdateApprovalRuleTemplateName for usage and error information.
//
// Returned Error Types:
//   * InvalidApprovalRuleTemplateNameException
//   The name of the approval rule template is not valid. Template names must
//   be between 1 and 100 valid characters in length. For more information about
//   limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
//
//   * ApprovalRuleTemplateNameRequiredException
//   An approval rule template name is required, but was not specified.
//
//   * ApprovalRuleTemplateDoesNotExistException
//   The specified approval rule template does not exist. Verify that the name
//   is correct and that you are signed in to the AWS Region where the template
//   was created, and then try again.
//
//   * ApprovalRuleTemplateNameAlreadyExistsException
//   You cannot create an approval rule template with that name because a template
//   with that name already exists in this AWS Region for your AWS account. Approval
//   rule template names must be unique.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateApprovalRuleTemplateName
func (c *CodeCommit) UpdateApprovalRuleTemplateName(input *UpdateApprovalRuleTemplateNameInput) (*UpdateApprovalRuleTemplateNameOutput, error) {
	req, out := c.UpdateApprovalRuleTemplateNameRequest(input)
	return out, req.Send()
}

// UpdateApprovalRuleTemplateNameWithContext is the same as UpdateApprovalRuleTemplateName with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateApprovalRuleTemplateName for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdateApprovalRuleTemplateNameWithContext(ctx aws.Context, input *UpdateApprovalRuleTemplateNameInput, opts ...request.Option) (*UpdateApprovalRuleTemplateNameOutput, error) {
	req, out := c.UpdateApprovalRuleTemplateNameRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateComment = "UpdateComment"

// UpdateCommentRequest generates a "aws/request.Request" representing the
// client's request for the UpdateComment operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateComment for more information on using the UpdateComment
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateCommentRequest method.
//    req, resp := client.UpdateCommentRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateComment
func (c *CodeCommit) UpdateCommentRequest(input *UpdateCommentInput) (req *request.Request, output *UpdateCommentOutput) {
	op := &request.Operation{
		Name:       opUpdateComment,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateCommentInput{}
	}

	output = &UpdateCommentOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdateComment API operation for AWS CodeCommit.
//
// Replaces the contents of a comment.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdateComment for usage and error information.
//
// Returned Error Types:
//   * CommentContentRequiredException
//   The comment is empty. You must provide some content for a comment. The content
//   cannot be null.
//
//   * CommentContentSizeLimitExceededException
//   The comment is too large. Comments are limited to 1,000 characters.
//
//   * CommentDoesNotExistException
//   No comment exists with the provided ID. Verify that you have used the correct
//   ID, and then try again.
//
//   * CommentIdRequiredException
//   The comment ID is missing or null. A comment ID is required.
//
//   * InvalidCommentIdException
//   The comment ID is not in a valid format. Make sure that you have provided
//   the full comment ID.
//
//   * CommentNotCreatedByCallerException
//   You cannot modify or delete this comment. Only comment authors can modify
//   or delete their comments.
//
//   * CommentDeletedException
//   This comment has already been deleted. You cannot edit or delete a deleted
//   comment.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateComment
func (c *CodeCommit) UpdateComment(input *UpdateCommentInput) (*UpdateCommentOutput, error) {
	req, out := c.UpdateCommentRequest(input)
	return out, req.Send()
}

// UpdateCommentWithContext is the same as UpdateComment with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateComment for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdateCommentWithContext(ctx aws.Context, input *UpdateCommentInput, opts ...request.Option) (*UpdateCommentOutput, error) {
	req, out := c.UpdateCommentRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateDefaultBranch = "UpdateDefaultBranch"

// UpdateDefaultBranchRequest generates a "aws/request.Request" representing the
// client's request for the UpdateDefaultBranch operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateDefaultBranch for more information on using the UpdateDefaultBranch
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateDefaultBranchRequest method.
//    req, resp := client.UpdateDefaultBranchRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateDefaultBranch
func (c *CodeCommit) UpdateDefaultBranchRequest(input *UpdateDefaultBranchInput) (req *request.Request, output *UpdateDefaultBranchOutput) {
	op := &request.Operation{
		Name:       opUpdateDefaultBranch,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateDefaultBranchInput{}
	}

	output = &UpdateDefaultBranchOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// UpdateDefaultBranch API operation for AWS CodeCommit.
//
// Sets or changes the default branch name for the specified repository.
//
// If you use this operation to change the default branch name to the current
// default branch name, a success message is returned even though the default
// branch did not change.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdateDefaultBranch for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * BranchNameRequiredException
//   A branch name is required, but was not specified.
//
//   * InvalidBranchNameException
//   The specified reference name is not valid.
//
//   * BranchDoesNotExistException
//   The specified branch does not exist.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateDefaultBranch
func (c *CodeCommit) UpdateDefaultBranch(input *UpdateDefaultBranchInput) (*UpdateDefaultBranchOutput, error) {
	req, out := c.UpdateDefaultBranchRequest(input)
	return out, req.Send()
}

// UpdateDefaultBranchWithContext is the same as UpdateDefaultBranch with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateDefaultBranch for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdateDefaultBranchWithContext(ctx aws.Context, input *UpdateDefaultBranchInput, opts ...request.Option) (*UpdateDefaultBranchOutput, error) {
	req, out := c.UpdateDefaultBranchRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdatePullRequestApprovalRuleContent = "UpdatePullRequestApprovalRuleContent"

// UpdatePullRequestApprovalRuleContentRequest generates a "aws/request.Request" representing the
// client's request for the UpdatePullRequestApprovalRuleContent operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdatePullRequestApprovalRuleContent for more information on using the UpdatePullRequestApprovalRuleContent
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdatePullRequestApprovalRuleContentRequest method.
//    req, resp := client.UpdatePullRequestApprovalRuleContentRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdatePullRequestApprovalRuleContent
func (c *CodeCommit) UpdatePullRequestApprovalRuleContentRequest(input *UpdatePullRequestApprovalRuleContentInput) (req *request.Request, output *UpdatePullRequestApprovalRuleContentOutput) {
	op := &request.Operation{
		Name:       opUpdatePullRequestApprovalRuleContent,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdatePullRequestApprovalRuleContentInput{}
	}

	output = &UpdatePullRequestApprovalRuleContentOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdatePullRequestApprovalRuleContent API operation for AWS CodeCommit.
//
// Updates the structure of an approval rule created specifically for a pull
// request. For example, you can change the number of required approvers and
// the approval pool for approvers.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdatePullRequestApprovalRuleContent for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * PullRequestAlreadyClosedException
//   The pull request status cannot be updated because it is already closed.
//
//   * ApprovalRuleNameRequiredException
//   An approval rule name is required, but was not specified.
//
//   * InvalidApprovalRuleNameException
//   The name for the approval rule is not valid.
//
//   * ApprovalRuleDoesNotExistException
//   The specified approval rule does not exist.
//
//   * InvalidRuleContentSha256Exception
//   The SHA-256 hash signature for the rule content is not valid.
//
//   * ApprovalRuleContentRequiredException
//   The content for the approval rule is empty. You must provide some content
//   for an approval rule. The content cannot be null.
//
//   * InvalidApprovalRuleContentException
//   The content for the approval rule is not valid.
//
//   * CannotModifyApprovalRuleFromTemplateException
//   The approval rule cannot be modified for the pull request because it was
//   created by an approval rule template and applied to the pull request automatically.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdatePullRequestApprovalRuleContent
func (c *CodeCommit) UpdatePullRequestApprovalRuleContent(input *UpdatePullRequestApprovalRuleContentInput) (*UpdatePullRequestApprovalRuleContentOutput, error) {
	req, out := c.UpdatePullRequestApprovalRuleContentRequest(input)
	return out, req.Send()
}

// UpdatePullRequestApprovalRuleContentWithContext is the same as UpdatePullRequestApprovalRuleContent with the addition of
// the ability to pass a context and additional request options.
//
// See UpdatePullRequestApprovalRuleContent for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdatePullRequestApprovalRuleContentWithContext(ctx aws.Context, input *UpdatePullRequestApprovalRuleContentInput, opts ...request.Option) (*UpdatePullRequestApprovalRuleContentOutput, error) {
	req, out := c.UpdatePullRequestApprovalRuleContentRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdatePullRequestApprovalState = "UpdatePullRequestApprovalState"

// UpdatePullRequestApprovalStateRequest generates a "aws/request.Request" representing the
// client's request for the UpdatePullRequestApprovalState operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdatePullRequestApprovalState for more information on using the UpdatePullRequestApprovalState
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdatePullRequestApprovalStateRequest method.
//    req, resp := client.UpdatePullRequestApprovalStateRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdatePullRequestApprovalState
func (c *CodeCommit) UpdatePullRequestApprovalStateRequest(input *UpdatePullRequestApprovalStateInput) (req *request.Request, output *UpdatePullRequestApprovalStateOutput) {
	op := &request.Operation{
		Name:       opUpdatePullRequestApprovalState,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdatePullRequestApprovalStateInput{}
	}

	output = &UpdatePullRequestApprovalStateOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// UpdatePullRequestApprovalState API operation for AWS CodeCommit.
//
// Updates the state of a user's approval on a pull request. The user is derived
// from the signed-in account when the request is made.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdatePullRequestApprovalState for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * InvalidRevisionIdException
//   The revision ID is not valid. Use GetPullRequest to determine the value.
//
//   * RevisionIdRequiredException
//   A revision ID is required, but was not provided.
//
//   * InvalidApprovalStateException
//   The state for the approval is not valid. Valid values include APPROVE and
//   REVOKE.
//
//   * ApprovalStateRequiredException
//   An approval state is required, but was not specified.
//
//   * PullRequestCannotBeApprovedByAuthorException
//   The approval cannot be applied because the user approving the pull request
//   matches the user who created the pull request. You cannot approve a pull
//   request that you created.
//
//   * RevisionNotCurrentException
//   The revision ID provided in the request does not match the current revision
//   ID. Use GetPullRequest to retrieve the current revision ID.
//
//   * PullRequestAlreadyClosedException
//   The pull request status cannot be updated because it is already closed.
//
//   * MaximumNumberOfApprovalsExceededException
//   The number of approvals required for the approval rule exceeds the maximum
//   number allowed.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdatePullRequestApprovalState
func (c *CodeCommit) UpdatePullRequestApprovalState(input *UpdatePullRequestApprovalStateInput) (*UpdatePullRequestApprovalStateOutput, error) {
	req, out := c.UpdatePullRequestApprovalStateRequest(input)
	return out, req.Send()
}

// UpdatePullRequestApprovalStateWithContext is the same as UpdatePullRequestApprovalState with the addition of
// the ability to pass a context and additional request options.
//
// See UpdatePullRequestApprovalState for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdatePullRequestApprovalStateWithContext(ctx aws.Context, input *UpdatePullRequestApprovalStateInput, opts ...request.Option) (*UpdatePullRequestApprovalStateOutput, error) {
	req, out := c.UpdatePullRequestApprovalStateRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdatePullRequestDescription = "UpdatePullRequestDescription"

// UpdatePullRequestDescriptionRequest generates a "aws/request.Request" representing the
// client's request for the UpdatePullRequestDescription operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdatePullRequestDescription for more information on using the UpdatePullRequestDescription
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdatePullRequestDescriptionRequest method.
//    req, resp := client.UpdatePullRequestDescriptionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdatePullRequestDescription
func (c *CodeCommit) UpdatePullRequestDescriptionRequest(input *UpdatePullRequestDescriptionInput) (req *request.Request, output *UpdatePullRequestDescriptionOutput) {
	op := &request.Operation{
		Name:       opUpdatePullRequestDescription,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdatePullRequestDescriptionInput{}
	}

	output = &UpdatePullRequestDescriptionOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdatePullRequestDescription API operation for AWS CodeCommit.
//
// Replaces the contents of the description of a pull request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdatePullRequestDescription for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * InvalidDescriptionException
//   The pull request description is not valid. Descriptions cannot be more than
//   1,000 characters.
//
//   * PullRequestAlreadyClosedException
//   The pull request status cannot be updated because it is already closed.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdatePullRequestDescription
func (c *CodeCommit) UpdatePullRequestDescription(input *UpdatePullRequestDescriptionInput) (*UpdatePullRequestDescriptionOutput, error) {
	req, out := c.UpdatePullRequestDescriptionRequest(input)
	return out, req.Send()
}

// UpdatePullRequestDescriptionWithContext is the same as UpdatePullRequestDescription with the addition of
// the ability to pass a context and additional request options.
//
// See UpdatePullRequestDescription for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdatePullRequestDescriptionWithContext(ctx aws.Context, input *UpdatePullRequestDescriptionInput, opts ...request.Option) (*UpdatePullRequestDescriptionOutput, error) {
	req, out := c.UpdatePullRequestDescriptionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdatePullRequestStatus = "UpdatePullRequestStatus"

// UpdatePullRequestStatusRequest generates a "aws/request.Request" representing the
// client's request for the UpdatePullRequestStatus operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdatePullRequestStatus for more information on using the UpdatePullRequestStatus
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdatePullRequestStatusRequest method.
//    req, resp := client.UpdatePullRequestStatusRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdatePullRequestStatus
func (c *CodeCommit) UpdatePullRequestStatusRequest(input *UpdatePullRequestStatusInput) (req *request.Request, output *UpdatePullRequestStatusOutput) {
	op := &request.Operation{
		Name:       opUpdatePullRequestStatus,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdatePullRequestStatusInput{}
	}

	output = &UpdatePullRequestStatusOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdatePullRequestStatus API operation for AWS CodeCommit.
//
// Updates the status of a pull request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdatePullRequestStatus for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * InvalidPullRequestStatusUpdateException
//   The pull request status update is not valid. The only valid update is from
//   OPEN to CLOSED.
//
//   * InvalidPullRequestStatusException
//   The pull request status is not valid. The only valid values are OPEN and
//   CLOSED.
//
//   * PullRequestStatusRequiredException
//   A pull request status is required, but none was provided.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdatePullRequestStatus
func (c *CodeCommit) UpdatePullRequestStatus(input *UpdatePullRequestStatusInput) (*UpdatePullRequestStatusOutput, error) {
	req, out := c.UpdatePullRequestStatusRequest(input)
	return out, req.Send()
}

// UpdatePullRequestStatusWithContext is the same as UpdatePullRequestStatus with the addition of
// the ability to pass a context and additional request options.
//
// See UpdatePullRequestStatus for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdatePullRequestStatusWithContext(ctx aws.Context, input *UpdatePullRequestStatusInput, opts ...request.Option) (*UpdatePullRequestStatusOutput, error) {
	req, out := c.UpdatePullRequestStatusRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdatePullRequestTitle = "UpdatePullRequestTitle"

// UpdatePullRequestTitleRequest generates a "aws/request.Request" representing the
// client's request for the UpdatePullRequestTitle operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdatePullRequestTitle for more information on using the UpdatePullRequestTitle
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdatePullRequestTitleRequest method.
//    req, resp := client.UpdatePullRequestTitleRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdatePullRequestTitle
func (c *CodeCommit) UpdatePullRequestTitleRequest(input *UpdatePullRequestTitleInput) (req *request.Request, output *UpdatePullRequestTitleOutput) {
	op := &request.Operation{
		Name:       opUpdatePullRequestTitle,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdatePullRequestTitleInput{}
	}

	output = &UpdatePullRequestTitleOutput{}
	req = c.newRequest(op, input, output)
	return
}

// UpdatePullRequestTitle API operation for AWS CodeCommit.
//
// Replaces the title of a pull request.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdatePullRequestTitle for usage and error information.
//
// Returned Error Types:
//   * PullRequestDoesNotExistException
//   The pull request ID could not be found. Make sure that you have specified
//   the correct repository name and pull request ID, and then try again.
//
//   * InvalidPullRequestIdException
//   The pull request ID is not valid. Make sure that you have provided the full
//   ID and that the pull request is in the specified repository, and then try
//   again.
//
//   * PullRequestIdRequiredException
//   A pull request ID is required, but none was provided.
//
//   * TitleRequiredException
//   A pull request title is required. It cannot be empty or null.
//
//   * InvalidTitleException
//   The title of the pull request is not valid. Pull request titles cannot exceed
//   100 characters in length.
//
//   * PullRequestAlreadyClosedException
//   The pull request status cannot be updated because it is already closed.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdatePullRequestTitle
func (c *CodeCommit) UpdatePullRequestTitle(input *UpdatePullRequestTitleInput) (*UpdatePullRequestTitleOutput, error) {
	req, out := c.UpdatePullRequestTitleRequest(input)
	return out, req.Send()
}

// UpdatePullRequestTitleWithContext is the same as UpdatePullRequestTitle with the addition of
// the ability to pass a context and additional request options.
//
// See UpdatePullRequestTitle for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdatePullRequestTitleWithContext(ctx aws.Context, input *UpdatePullRequestTitleInput, opts ...request.Option) (*UpdatePullRequestTitleOutput, error) {
	req, out := c.UpdatePullRequestTitleRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateRepositoryDescription = "UpdateRepositoryDescription"

// UpdateRepositoryDescriptionRequest generates a "aws/request.Request" representing the
// client's request for the UpdateRepositoryDescription operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateRepositoryDescription for more information on using the UpdateRepositoryDescription
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateRepositoryDescriptionRequest method.
//    req, resp := client.UpdateRepositoryDescriptionRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateRepositoryDescription
func (c *CodeCommit) UpdateRepositoryDescriptionRequest(input *UpdateRepositoryDescriptionInput) (req *request.Request, output *UpdateRepositoryDescriptionOutput) {
	op := &request.Operation{
		Name:       opUpdateRepositoryDescription,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateRepositoryDescriptionInput{}
	}

	output = &UpdateRepositoryDescriptionOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// UpdateRepositoryDescription API operation for AWS CodeCommit.
//
// Sets or changes the comment or description for a repository.
//
// The description field for a repository accepts all HTML characters and all
// valid Unicode characters. Applications that do not HTML-encode the description
// and display it in a webpage can expose users to potentially malicious code.
// Make sure that you HTML-encode the description field in any application that
// uses this API to display the repository description on a webpage.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdateRepositoryDescription for usage and error information.
//
// Returned Error Types:
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
//   * InvalidRepositoryDescriptionException
//   The specified repository description is not valid.
//
//   * EncryptionIntegrityChecksFailedException
//   An encryption integrity check failed.
//
//   * EncryptionKeyAccessDeniedException
//   An encryption key could not be accessed.
//
//   * EncryptionKeyDisabledException
//   The encryption key is disabled.
//
//   * EncryptionKeyNotFoundException
//   No encryption key was found.
//
//   * EncryptionKeyUnavailableException
//   The encryption key is not available.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateRepositoryDescription
func (c *CodeCommit) UpdateRepositoryDescription(input *UpdateRepositoryDescriptionInput) (*UpdateRepositoryDescriptionOutput, error) {
	req, out := c.UpdateRepositoryDescriptionRequest(input)
	return out, req.Send()
}

// UpdateRepositoryDescriptionWithContext is the same as UpdateRepositoryDescription with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateRepositoryDescription for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdateRepositoryDescriptionWithContext(ctx aws.Context, input *UpdateRepositoryDescriptionInput, opts ...request.Option) (*UpdateRepositoryDescriptionOutput, error) {
	req, out := c.UpdateRepositoryDescriptionRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

const opUpdateRepositoryName = "UpdateRepositoryName"

// UpdateRepositoryNameRequest generates a "aws/request.Request" representing the
// client's request for the UpdateRepositoryName operation. The "output" return
// value will be populated with the request's response once the request completes
// successfully.
//
// Use "Send" method on the returned Request to send the API call to the service.
// the "output" return value is not valid until after Send returns without error.
//
// See UpdateRepositoryName for more information on using the UpdateRepositoryName
// API call, and error handling.
//
// This method is useful when you want to inject custom logic or configuration
// into the SDK's request lifecycle. Such as custom headers, or retry logic.
//
//
//    // Example sending a request using the UpdateRepositoryNameRequest method.
//    req, resp := client.UpdateRepositoryNameRequest(params)
//
//    err := req.Send()
//    if err == nil { // resp is now filled
//        fmt.Println(resp)
//    }
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateRepositoryName
func (c *CodeCommit) UpdateRepositoryNameRequest(input *UpdateRepositoryNameInput) (req *request.Request, output *UpdateRepositoryNameOutput) {
	op := &request.Operation{
		Name:       opUpdateRepositoryName,
		HTTPMethod: "POST",
		HTTPPath:   "/",
	}

	if input == nil {
		input = &UpdateRepositoryNameInput{}
	}

	output = &UpdateRepositoryNameOutput{}
	req = c.newRequest(op, input, output)
	req.Handlers.Unmarshal.Swap(jsonrpc.UnmarshalHandler.Name, protocol.UnmarshalDiscardBodyHandler)
	return
}

// UpdateRepositoryName API operation for AWS CodeCommit.
//
// Renames a repository. The repository name must be unique across the calling
// AWS account. Repository names are limited to 100 alphanumeric, dash, and
// underscore characters, and cannot include certain characters. The suffix
// .git is prohibited. For more information about the limits on repository names,
// see Limits (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html)
// in the AWS CodeCommit User Guide.
//
// Returns awserr.Error for service API and SDK errors. Use runtime type assertions
// with awserr.Error's Code and Message methods to get detailed information about
// the error.
//
// See the AWS API reference guide for AWS CodeCommit's
// API operation UpdateRepositoryName for usage and error information.
//
// Returned Error Types:
//   * RepositoryDoesNotExistException
//   The specified repository does not exist.
//
//   * RepositoryNameExistsException
//   The specified repository name already exists.
//
//   * RepositoryNameRequiredException
//   A repository name is required, but was not specified.
//
//   * InvalidRepositoryNameException
//   A specified repository name is not valid.
//
//   This exception occurs only when a specified repository name is not valid.
//   Other exceptions occur when a required repository parameter is missing, or
//   when a specified repository does not exist.
//
// See also, https://docs.aws.amazon.com/goto/WebAPI/codecommit-2015-04-13/UpdateRepositoryName
func (c *CodeCommit) UpdateRepositoryName(input *UpdateRepositoryNameInput) (*UpdateRepositoryNameOutput, error) {
	req, out := c.UpdateRepositoryNameRequest(input)
	return out, req.Send()
}

// UpdateRepositoryNameWithContext is the same as UpdateRepositoryName with the addition of
// the ability to pass a context and additional request options.
//
// See UpdateRepositoryName for details on how to use this API operation.
//
// The context must be non-nil and will be used for request cancellation. If
// the context is nil a panic will occur. In the future the SDK may create
// sub-contexts for http.Requests. See https://golang.org/pkg/context/
// for more information on using Contexts.
func (c *CodeCommit) UpdateRepositoryNameWithContext(ctx aws.Context, input *UpdateRepositoryNameInput, opts ...request.Option) (*UpdateRepositoryNameOutput, error) {
	req, out := c.UpdateRepositoryNameRequest(input)
	req.SetContext(ctx)
	req.ApplyOptions(opts...)
	return out, req.Send()
}

// The specified Amazon Resource Name (ARN) does not exist in the AWS account.
type ActorDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ActorDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ActorDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorActorDoesNotExistException(v protocol.ResponseMetadata) error {
	return &ActorDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ActorDoesNotExistException) Code() string {
	return "ActorDoesNotExistException"
}

// Message returns the exception's message.
func (s *ActorDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ActorDoesNotExistException) OrigErr() error {
	return nil
}

func (s *ActorDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ActorDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ActorDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about a specific approval on a pull request.
type Approval struct {
	_ struct{} `type:"structure"`

	// The state of the approval, APPROVE or REVOKE. REVOKE states are not stored.
	ApprovalState *string `locationName:"approvalState" type:"string" enum:"ApprovalState"`

	// The Amazon Resource Name (ARN) of the user.
	UserArn *string `locationName:"userArn" type:"string"`
}

// String returns the string representation
func (s Approval) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Approval) GoString() string {
	return s.String()
}

// SetApprovalState sets the ApprovalState field's value.
func (s *Approval) SetApprovalState(v string) *Approval {
	s.ApprovalState = &v
	return s
}

// SetUserArn sets the UserArn field's value.
func (s *Approval) SetUserArn(v string) *Approval {
	s.UserArn = &v
	return s
}

// Returns information about an approval rule.
type ApprovalRule struct {
	_ struct{} `type:"structure"`

	// The content of the approval rule.
	ApprovalRuleContent *string `locationName:"approvalRuleContent" min:"1" type:"string"`

	// The system-generated ID of the approval rule.
	ApprovalRuleId *string `locationName:"approvalRuleId" type:"string"`

	// The name of the approval rule.
	ApprovalRuleName *string `locationName:"approvalRuleName" min:"1" type:"string"`

	// The date the approval rule was created, in timestamp format.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp"`

	// The date the approval rule was most recently changed, in timestamp format.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp"`

	// The Amazon Resource Name (ARN) of the user who made the most recent changes
	// to the approval rule.
	LastModifiedUser *string `locationName:"lastModifiedUser" type:"string"`

	// The approval rule template used to create the rule.
	OriginApprovalRuleTemplate *OriginApprovalRuleTemplate `locationName:"originApprovalRuleTemplate" type:"structure"`

	// The SHA-256 hash signature for the content of the approval rule.
	RuleContentSha256 *string `locationName:"ruleContentSha256" type:"string"`
}

// String returns the string representation
func (s ApprovalRule) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRule) GoString() string {
	return s.String()
}

// SetApprovalRuleContent sets the ApprovalRuleContent field's value.
func (s *ApprovalRule) SetApprovalRuleContent(v string) *ApprovalRule {
	s.ApprovalRuleContent = &v
	return s
}

// SetApprovalRuleId sets the ApprovalRuleId field's value.
func (s *ApprovalRule) SetApprovalRuleId(v string) *ApprovalRule {
	s.ApprovalRuleId = &v
	return s
}

// SetApprovalRuleName sets the ApprovalRuleName field's value.
func (s *ApprovalRule) SetApprovalRuleName(v string) *ApprovalRule {
	s.ApprovalRuleName = &v
	return s
}

// SetCreationDate sets the CreationDate field's value.
func (s *ApprovalRule) SetCreationDate(v time.Time) *ApprovalRule {
	s.CreationDate = &v
	return s
}

// SetLastModifiedDate sets the LastModifiedDate field's value.
func (s *ApprovalRule) SetLastModifiedDate(v time.Time) *ApprovalRule {
	s.LastModifiedDate = &v
	return s
}

// SetLastModifiedUser sets the LastModifiedUser field's value.
func (s *ApprovalRule) SetLastModifiedUser(v string) *ApprovalRule {
	s.LastModifiedUser = &v
	return s
}

// SetOriginApprovalRuleTemplate sets the OriginApprovalRuleTemplate field's value.
func (s *ApprovalRule) SetOriginApprovalRuleTemplate(v *OriginApprovalRuleTemplate) *ApprovalRule {
	s.OriginApprovalRuleTemplate = v
	return s
}

// SetRuleContentSha256 sets the RuleContentSha256 field's value.
func (s *ApprovalRule) SetRuleContentSha256(v string) *ApprovalRule {
	s.RuleContentSha256 = &v
	return s
}

// The content for the approval rule is empty. You must provide some content
// for an approval rule. The content cannot be null.
type ApprovalRuleContentRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleContentRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleContentRequiredException) GoString() string {
	return s.String()
}

func newErrorApprovalRuleContentRequiredException(v protocol.ResponseMetadata) error {
	return &ApprovalRuleContentRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ApprovalRuleContentRequiredException) Code() string {
	return "ApprovalRuleContentRequiredException"
}

// Message returns the exception's message.
func (s *ApprovalRuleContentRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ApprovalRuleContentRequiredException) OrigErr() error {
	return nil
}

func (s *ApprovalRuleContentRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ApprovalRuleContentRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ApprovalRuleContentRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified approval rule does not exist.
type ApprovalRuleDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorApprovalRuleDoesNotExistException(v protocol.ResponseMetadata) error {
	return &ApprovalRuleDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ApprovalRuleDoesNotExistException) Code() string {
	return "ApprovalRuleDoesNotExistException"
}

// Message returns the exception's message.
func (s *ApprovalRuleDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ApprovalRuleDoesNotExistException) OrigErr() error {
	return nil
}

func (s *ApprovalRuleDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ApprovalRuleDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ApprovalRuleDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about an event for an approval rule.
type ApprovalRuleEventMetadata struct {
	_ struct{} `type:"structure"`

	// The content of the approval rule.
	ApprovalRuleContent *string `locationName:"approvalRuleContent" min:"1" type:"string"`

	// The system-generated ID of the approval rule.
	ApprovalRuleId *string `locationName:"approvalRuleId" type:"string"`

	// The name of the approval rule.
	ApprovalRuleName *string `locationName:"approvalRuleName" min:"1" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleEventMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleEventMetadata) GoString() string {
	return s.String()
}

// SetApprovalRuleContent sets the ApprovalRuleContent field's value.
func (s *ApprovalRuleEventMetadata) SetApprovalRuleContent(v string) *ApprovalRuleEventMetadata {
	s.ApprovalRuleContent = &v
	return s
}

// SetApprovalRuleId sets the ApprovalRuleId field's value.
func (s *ApprovalRuleEventMetadata) SetApprovalRuleId(v string) *ApprovalRuleEventMetadata {
	s.ApprovalRuleId = &v
	return s
}

// SetApprovalRuleName sets the ApprovalRuleName field's value.
func (s *ApprovalRuleEventMetadata) SetApprovalRuleName(v string) *ApprovalRuleEventMetadata {
	s.ApprovalRuleName = &v
	return s
}

// An approval rule with that name already exists. Approval rule names must
// be unique within the scope of a pull request.
type ApprovalRuleNameAlreadyExistsException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleNameAlreadyExistsException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleNameAlreadyExistsException) GoString() string {
	return s.String()
}

func newErrorApprovalRuleNameAlreadyExistsException(v protocol.ResponseMetadata) error {
	return &ApprovalRuleNameAlreadyExistsException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ApprovalRuleNameAlreadyExistsException) Code() string {
	return "ApprovalRuleNameAlreadyExistsException"
}

// Message returns the exception's message.
func (s *ApprovalRuleNameAlreadyExistsException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ApprovalRuleNameAlreadyExistsException) OrigErr() error {
	return nil
}

func (s *ApprovalRuleNameAlreadyExistsException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ApprovalRuleNameAlreadyExistsException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ApprovalRuleNameAlreadyExistsException) RequestID() string {
	return s.RespMetadata.RequestID
}

// An approval rule name is required, but was not specified.
type ApprovalRuleNameRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleNameRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleNameRequiredException) GoString() string {
	return s.String()
}

func newErrorApprovalRuleNameRequiredException(v protocol.ResponseMetadata) error {
	return &ApprovalRuleNameRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ApprovalRuleNameRequiredException) Code() string {
	return "ApprovalRuleNameRequiredException"
}

// Message returns the exception's message.
func (s *ApprovalRuleNameRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ApprovalRuleNameRequiredException) OrigErr() error {
	return nil
}

func (s *ApprovalRuleNameRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ApprovalRuleNameRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ApprovalRuleNameRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about an override event for approval rules for a pull
// request.
type ApprovalRuleOverriddenEventMetadata struct {
	_ struct{} `type:"structure"`

	// The status of the override event.
	OverrideStatus *string `locationName:"overrideStatus" type:"string" enum:"OverrideStatus"`

	// The revision ID of the pull request when the override event occurred.
	RevisionId *string `locationName:"revisionId" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleOverriddenEventMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleOverriddenEventMetadata) GoString() string {
	return s.String()
}

// SetOverrideStatus sets the OverrideStatus field's value.
func (s *ApprovalRuleOverriddenEventMetadata) SetOverrideStatus(v string) *ApprovalRuleOverriddenEventMetadata {
	s.OverrideStatus = &v
	return s
}

// SetRevisionId sets the RevisionId field's value.
func (s *ApprovalRuleOverriddenEventMetadata) SetRevisionId(v string) *ApprovalRuleOverriddenEventMetadata {
	s.RevisionId = &v
	return s
}

// Returns information about an approval rule template.
type ApprovalRuleTemplate struct {
	_ struct{} `type:"structure"`

	// The content of the approval rule template.
	ApprovalRuleTemplateContent *string `locationName:"approvalRuleTemplateContent" min:"1" type:"string"`

	// The description of the approval rule template.
	ApprovalRuleTemplateDescription *string `locationName:"approvalRuleTemplateDescription" type:"string"`

	// The system-generated ID of the approval rule template.
	ApprovalRuleTemplateId *string `locationName:"approvalRuleTemplateId" type:"string"`

	// The name of the approval rule template.
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string"`

	// The date the approval rule template was created, in timestamp format.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp"`

	// The date the approval rule template was most recently changed, in timestamp
	// format.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp"`

	// The Amazon Resource Name (ARN) of the user who made the most recent changes
	// to the approval rule template.
	LastModifiedUser *string `locationName:"lastModifiedUser" type:"string"`

	// The SHA-256 hash signature for the content of the approval rule template.
	RuleContentSha256 *string `locationName:"ruleContentSha256" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleTemplate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleTemplate) GoString() string {
	return s.String()
}

// SetApprovalRuleTemplateContent sets the ApprovalRuleTemplateContent field's value.
func (s *ApprovalRuleTemplate) SetApprovalRuleTemplateContent(v string) *ApprovalRuleTemplate {
	s.ApprovalRuleTemplateContent = &v
	return s
}

// SetApprovalRuleTemplateDescription sets the ApprovalRuleTemplateDescription field's value.
func (s *ApprovalRuleTemplate) SetApprovalRuleTemplateDescription(v string) *ApprovalRuleTemplate {
	s.ApprovalRuleTemplateDescription = &v
	return s
}

// SetApprovalRuleTemplateId sets the ApprovalRuleTemplateId field's value.
func (s *ApprovalRuleTemplate) SetApprovalRuleTemplateId(v string) *ApprovalRuleTemplate {
	s.ApprovalRuleTemplateId = &v
	return s
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *ApprovalRuleTemplate) SetApprovalRuleTemplateName(v string) *ApprovalRuleTemplate {
	s.ApprovalRuleTemplateName = &v
	return s
}

// SetCreationDate sets the CreationDate field's value.
func (s *ApprovalRuleTemplate) SetCreationDate(v time.Time) *ApprovalRuleTemplate {
	s.CreationDate = &v
	return s
}

// SetLastModifiedDate sets the LastModifiedDate field's value.
func (s *ApprovalRuleTemplate) SetLastModifiedDate(v time.Time) *ApprovalRuleTemplate {
	s.LastModifiedDate = &v
	return s
}

// SetLastModifiedUser sets the LastModifiedUser field's value.
func (s *ApprovalRuleTemplate) SetLastModifiedUser(v string) *ApprovalRuleTemplate {
	s.LastModifiedUser = &v
	return s
}

// SetRuleContentSha256 sets the RuleContentSha256 field's value.
func (s *ApprovalRuleTemplate) SetRuleContentSha256(v string) *ApprovalRuleTemplate {
	s.RuleContentSha256 = &v
	return s
}

// The content for the approval rule template is empty. You must provide some
// content for an approval rule template. The content cannot be null.
type ApprovalRuleTemplateContentRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleTemplateContentRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleTemplateContentRequiredException) GoString() string {
	return s.String()
}

func newErrorApprovalRuleTemplateContentRequiredException(v protocol.ResponseMetadata) error {
	return &ApprovalRuleTemplateContentRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ApprovalRuleTemplateContentRequiredException) Code() string {
	return "ApprovalRuleTemplateContentRequiredException"
}

// Message returns the exception's message.
func (s *ApprovalRuleTemplateContentRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ApprovalRuleTemplateContentRequiredException) OrigErr() error {
	return nil
}

func (s *ApprovalRuleTemplateContentRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ApprovalRuleTemplateContentRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ApprovalRuleTemplateContentRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified approval rule template does not exist. Verify that the name
// is correct and that you are signed in to the AWS Region where the template
// was created, and then try again.
type ApprovalRuleTemplateDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleTemplateDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleTemplateDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorApprovalRuleTemplateDoesNotExistException(v protocol.ResponseMetadata) error {
	return &ApprovalRuleTemplateDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ApprovalRuleTemplateDoesNotExistException) Code() string {
	return "ApprovalRuleTemplateDoesNotExistException"
}

// Message returns the exception's message.
func (s *ApprovalRuleTemplateDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ApprovalRuleTemplateDoesNotExistException) OrigErr() error {
	return nil
}

func (s *ApprovalRuleTemplateDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ApprovalRuleTemplateDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ApprovalRuleTemplateDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The approval rule template is associated with one or more repositories. You
// cannot delete a template that is associated with a repository. Remove all
// associations, and then try again.
type ApprovalRuleTemplateInUseException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleTemplateInUseException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleTemplateInUseException) GoString() string {
	return s.String()
}

func newErrorApprovalRuleTemplateInUseException(v protocol.ResponseMetadata) error {
	return &ApprovalRuleTemplateInUseException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ApprovalRuleTemplateInUseException) Code() string {
	return "ApprovalRuleTemplateInUseException"
}

// Message returns the exception's message.
func (s *ApprovalRuleTemplateInUseException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ApprovalRuleTemplateInUseException) OrigErr() error {
	return nil
}

func (s *ApprovalRuleTemplateInUseException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ApprovalRuleTemplateInUseException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ApprovalRuleTemplateInUseException) RequestID() string {
	return s.RespMetadata.RequestID
}

// You cannot create an approval rule template with that name because a template
// with that name already exists in this AWS Region for your AWS account. Approval
// rule template names must be unique.
type ApprovalRuleTemplateNameAlreadyExistsException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleTemplateNameAlreadyExistsException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleTemplateNameAlreadyExistsException) GoString() string {
	return s.String()
}

func newErrorApprovalRuleTemplateNameAlreadyExistsException(v protocol.ResponseMetadata) error {
	return &ApprovalRuleTemplateNameAlreadyExistsException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ApprovalRuleTemplateNameAlreadyExistsException) Code() string {
	return "ApprovalRuleTemplateNameAlreadyExistsException"
}

// Message returns the exception's message.
func (s *ApprovalRuleTemplateNameAlreadyExistsException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ApprovalRuleTemplateNameAlreadyExistsException) OrigErr() error {
	return nil
}

func (s *ApprovalRuleTemplateNameAlreadyExistsException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ApprovalRuleTemplateNameAlreadyExistsException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ApprovalRuleTemplateNameAlreadyExistsException) RequestID() string {
	return s.RespMetadata.RequestID
}

// An approval rule template name is required, but was not specified.
type ApprovalRuleTemplateNameRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ApprovalRuleTemplateNameRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalRuleTemplateNameRequiredException) GoString() string {
	return s.String()
}

func newErrorApprovalRuleTemplateNameRequiredException(v protocol.ResponseMetadata) error {
	return &ApprovalRuleTemplateNameRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ApprovalRuleTemplateNameRequiredException) Code() string {
	return "ApprovalRuleTemplateNameRequiredException"
}

// Message returns the exception's message.
func (s *ApprovalRuleTemplateNameRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ApprovalRuleTemplateNameRequiredException) OrigErr() error {
	return nil
}

func (s *ApprovalRuleTemplateNameRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ApprovalRuleTemplateNameRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ApprovalRuleTemplateNameRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about a change in the approval state for a pull request.
type ApprovalStateChangedEventMetadata struct {
	_ struct{} `type:"structure"`

	// The approval status for the pull request.
	ApprovalStatus *string `locationName:"approvalStatus" type:"string" enum:"ApprovalState"`

	// The revision ID of the pull request when the approval state changed.
	RevisionId *string `locationName:"revisionId" type:"string"`
}

// String returns the string representation
func (s ApprovalStateChangedEventMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalStateChangedEventMetadata) GoString() string {
	return s.String()
}

// SetApprovalStatus sets the ApprovalStatus field's value.
func (s *ApprovalStateChangedEventMetadata) SetApprovalStatus(v string) *ApprovalStateChangedEventMetadata {
	s.ApprovalStatus = &v
	return s
}

// SetRevisionId sets the RevisionId field's value.
func (s *ApprovalStateChangedEventMetadata) SetRevisionId(v string) *ApprovalStateChangedEventMetadata {
	s.RevisionId = &v
	return s
}

// An approval state is required, but was not specified.
type ApprovalStateRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ApprovalStateRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ApprovalStateRequiredException) GoString() string {
	return s.String()
}

func newErrorApprovalStateRequiredException(v protocol.ResponseMetadata) error {
	return &ApprovalStateRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ApprovalStateRequiredException) Code() string {
	return "ApprovalStateRequiredException"
}

// Message returns the exception's message.
func (s *ApprovalStateRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ApprovalStateRequiredException) OrigErr() error {
	return nil
}

func (s *ApprovalStateRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ApprovalStateRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ApprovalStateRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

type AssociateApprovalRuleTemplateWithRepositoryInput struct {
	_ struct{} `type:"structure"`

	// The name for the approval rule template.
	//
	// ApprovalRuleTemplateName is a required field
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string" required:"true"`

	// The name of the repository that you want to associate with the template.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s AssociateApprovalRuleTemplateWithRepositoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AssociateApprovalRuleTemplateWithRepositoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *AssociateApprovalRuleTemplateWithRepositoryInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "AssociateApprovalRuleTemplateWithRepositoryInput"}
	if s.ApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateName"))
	}
	if s.ApprovalRuleTemplateName != nil && len(*s.ApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleTemplateName", 1))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *AssociateApprovalRuleTemplateWithRepositoryInput) SetApprovalRuleTemplateName(v string) *AssociateApprovalRuleTemplateWithRepositoryInput {
	s.ApprovalRuleTemplateName = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *AssociateApprovalRuleTemplateWithRepositoryInput) SetRepositoryName(v string) *AssociateApprovalRuleTemplateWithRepositoryInput {
	s.RepositoryName = &v
	return s
}

type AssociateApprovalRuleTemplateWithRepositoryOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s AssociateApprovalRuleTemplateWithRepositoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AssociateApprovalRuleTemplateWithRepositoryOutput) GoString() string {
	return s.String()
}

// The specified Amazon Resource Name (ARN) does not exist in the AWS account.
type AuthorDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s AuthorDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s AuthorDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorAuthorDoesNotExistException(v protocol.ResponseMetadata) error {
	return &AuthorDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *AuthorDoesNotExistException) Code() string {
	return "AuthorDoesNotExistException"
}

// Message returns the exception's message.
func (s *AuthorDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *AuthorDoesNotExistException) OrigErr() error {
	return nil
}

func (s *AuthorDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *AuthorDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *AuthorDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about errors in a BatchAssociateApprovalRuleTemplateWithRepositories
// operation.
type BatchAssociateApprovalRuleTemplateWithRepositoriesError struct {
	_ struct{} `type:"structure"`

	// An error code that specifies whether the repository name was not valid or
	// not found.
	ErrorCode *string `locationName:"errorCode" type:"string"`

	// An error message that provides details about why the repository name was
	// not found or not valid.
	ErrorMessage *string `locationName:"errorMessage" type:"string"`

	// The name of the repository where the association was not made.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s BatchAssociateApprovalRuleTemplateWithRepositoriesError) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAssociateApprovalRuleTemplateWithRepositoriesError) GoString() string {
	return s.String()
}

// SetErrorCode sets the ErrorCode field's value.
func (s *BatchAssociateApprovalRuleTemplateWithRepositoriesError) SetErrorCode(v string) *BatchAssociateApprovalRuleTemplateWithRepositoriesError {
	s.ErrorCode = &v
	return s
}

// SetErrorMessage sets the ErrorMessage field's value.
func (s *BatchAssociateApprovalRuleTemplateWithRepositoriesError) SetErrorMessage(v string) *BatchAssociateApprovalRuleTemplateWithRepositoriesError {
	s.ErrorMessage = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *BatchAssociateApprovalRuleTemplateWithRepositoriesError) SetRepositoryName(v string) *BatchAssociateApprovalRuleTemplateWithRepositoriesError {
	s.RepositoryName = &v
	return s
}

type BatchAssociateApprovalRuleTemplateWithRepositoriesInput struct {
	_ struct{} `type:"structure"`

	// The name of the template you want to associate with one or more repositories.
	//
	// ApprovalRuleTemplateName is a required field
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string" required:"true"`

	// The names of the repositories you want to associate with the template.
	//
	// The length constraint limit is for each string in the array. The array itself
	// can be empty.
	//
	// RepositoryNames is a required field
	RepositoryNames []*string `locationName:"repositoryNames" type:"list" required:"true"`
}

// String returns the string representation
func (s BatchAssociateApprovalRuleTemplateWithRepositoriesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAssociateApprovalRuleTemplateWithRepositoriesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchAssociateApprovalRuleTemplateWithRepositoriesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchAssociateApprovalRuleTemplateWithRepositoriesInput"}
	if s.ApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateName"))
	}
	if s.ApprovalRuleTemplateName != nil && len(*s.ApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleTemplateName", 1))
	}
	if s.RepositoryNames == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryNames"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *BatchAssociateApprovalRuleTemplateWithRepositoriesInput) SetApprovalRuleTemplateName(v string) *BatchAssociateApprovalRuleTemplateWithRepositoriesInput {
	s.ApprovalRuleTemplateName = &v
	return s
}

// SetRepositoryNames sets the RepositoryNames field's value.
func (s *BatchAssociateApprovalRuleTemplateWithRepositoriesInput) SetRepositoryNames(v []*string) *BatchAssociateApprovalRuleTemplateWithRepositoriesInput {
	s.RepositoryNames = v
	return s
}

type BatchAssociateApprovalRuleTemplateWithRepositoriesOutput struct {
	_ struct{} `type:"structure"`

	// A list of names of the repositories that have been associated with the template.
	//
	// AssociatedRepositoryNames is a required field
	AssociatedRepositoryNames []*string `locationName:"associatedRepositoryNames" type:"list" required:"true"`

	// A list of any errors that might have occurred while attempting to create
	// the association between the template and the repositories.
	//
	// Errors is a required field
	Errors []*BatchAssociateApprovalRuleTemplateWithRepositoriesError `locationName:"errors" type:"list" required:"true"`
}

// String returns the string representation
func (s BatchAssociateApprovalRuleTemplateWithRepositoriesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchAssociateApprovalRuleTemplateWithRepositoriesOutput) GoString() string {
	return s.String()
}

// SetAssociatedRepositoryNames sets the AssociatedRepositoryNames field's value.
func (s *BatchAssociateApprovalRuleTemplateWithRepositoriesOutput) SetAssociatedRepositoryNames(v []*string) *BatchAssociateApprovalRuleTemplateWithRepositoriesOutput {
	s.AssociatedRepositoryNames = v
	return s
}

// SetErrors sets the Errors field's value.
func (s *BatchAssociateApprovalRuleTemplateWithRepositoriesOutput) SetErrors(v []*BatchAssociateApprovalRuleTemplateWithRepositoriesError) *BatchAssociateApprovalRuleTemplateWithRepositoriesOutput {
	s.Errors = v
	return s
}

// Returns information about errors in a BatchDescribeMergeConflicts operation.
type BatchDescribeMergeConflictsError struct {
	_ struct{} `type:"structure"`

	// The name of the exception.
	//
	// ExceptionName is a required field
	ExceptionName *string `locationName:"exceptionName" type:"string" required:"true"`

	// The path to the file.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`

	// The message provided by the exception.
	//
	// Message is a required field
	Message *string `locationName:"message" type:"string" required:"true"`
}

// String returns the string representation
func (s BatchDescribeMergeConflictsError) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDescribeMergeConflictsError) GoString() string {
	return s.String()
}

// SetExceptionName sets the ExceptionName field's value.
func (s *BatchDescribeMergeConflictsError) SetExceptionName(v string) *BatchDescribeMergeConflictsError {
	s.ExceptionName = &v
	return s
}

// SetFilePath sets the FilePath field's value.
func (s *BatchDescribeMergeConflictsError) SetFilePath(v string) *BatchDescribeMergeConflictsError {
	s.FilePath = &v
	return s
}

// SetMessage sets the Message field's value.
func (s *BatchDescribeMergeConflictsError) SetMessage(v string) *BatchDescribeMergeConflictsError {
	s.Message = &v
	return s
}

type BatchDescribeMergeConflictsInput struct {
	_ struct{} `type:"structure"`

	// The level of conflict detail to use. If unspecified, the default FILE_LEVEL
	// is used, which returns a not-mergeable result if the same file has differences
	// in both branches. If LINE_LEVEL is specified, a conflict is considered not
	// mergeable if the same file in both branches has differences on the same line.
	ConflictDetailLevel *string `locationName:"conflictDetailLevel" type:"string" enum:"ConflictDetailLevelTypeEnum"`

	// Specifies which branch to use when resolving conflicts, or whether to attempt
	// automatically merging two versions of a file. The default is NONE, which
	// requires any conflicts to be resolved manually before the merge operation
	// is successful.
	ConflictResolutionStrategy *string `locationName:"conflictResolutionStrategy" type:"string" enum:"ConflictResolutionStrategyTypeEnum"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// DestinationCommitSpecifier is a required field
	DestinationCommitSpecifier *string `locationName:"destinationCommitSpecifier" type:"string" required:"true"`

	// The path of the target files used to describe the conflicts. If not specified,
	// the default is all conflict files.
	FilePaths []*string `locationName:"filePaths" type:"list"`

	// The maximum number of files to include in the output.
	MaxConflictFiles *int64 `locationName:"maxConflictFiles" type:"integer"`

	// The maximum number of merge hunks to include in the output.
	MaxMergeHunks *int64 `locationName:"maxMergeHunks" type:"integer"`

	// The merge option or strategy you want to use to merge the code.
	//
	// MergeOption is a required field
	MergeOption *string `locationName:"mergeOption" type:"string" required:"true" enum:"MergeOptionTypeEnum"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The name of the repository that contains the merge conflicts you want to
	// review.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// SourceCommitSpecifier is a required field
	SourceCommitSpecifier *string `locationName:"sourceCommitSpecifier" type:"string" required:"true"`
}

// String returns the string representation
func (s BatchDescribeMergeConflictsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDescribeMergeConflictsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchDescribeMergeConflictsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchDescribeMergeConflictsInput"}
	if s.DestinationCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("DestinationCommitSpecifier"))
	}
	if s.MergeOption == nil {
		invalidParams.Add(request.NewErrParamRequired("MergeOption"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.SourceCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("SourceCommitSpecifier"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetConflictDetailLevel sets the ConflictDetailLevel field's value.
func (s *BatchDescribeMergeConflictsInput) SetConflictDetailLevel(v string) *BatchDescribeMergeConflictsInput {
	s.ConflictDetailLevel = &v
	return s
}

// SetConflictResolutionStrategy sets the ConflictResolutionStrategy field's value.
func (s *BatchDescribeMergeConflictsInput) SetConflictResolutionStrategy(v string) *BatchDescribeMergeConflictsInput {
	s.ConflictResolutionStrategy = &v
	return s
}

// SetDestinationCommitSpecifier sets the DestinationCommitSpecifier field's value.
func (s *BatchDescribeMergeConflictsInput) SetDestinationCommitSpecifier(v string) *BatchDescribeMergeConflictsInput {
	s.DestinationCommitSpecifier = &v
	return s
}

// SetFilePaths sets the FilePaths field's value.
func (s *BatchDescribeMergeConflictsInput) SetFilePaths(v []*string) *BatchDescribeMergeConflictsInput {
	s.FilePaths = v
	return s
}

// SetMaxConflictFiles sets the MaxConflictFiles field's value.
func (s *BatchDescribeMergeConflictsInput) SetMaxConflictFiles(v int64) *BatchDescribeMergeConflictsInput {
	s.MaxConflictFiles = &v
	return s
}

// SetMaxMergeHunks sets the MaxMergeHunks field's value.
func (s *BatchDescribeMergeConflictsInput) SetMaxMergeHunks(v int64) *BatchDescribeMergeConflictsInput {
	s.MaxMergeHunks = &v
	return s
}

// SetMergeOption sets the MergeOption field's value.
func (s *BatchDescribeMergeConflictsInput) SetMergeOption(v string) *BatchDescribeMergeConflictsInput {
	s.MergeOption = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *BatchDescribeMergeConflictsInput) SetNextToken(v string) *BatchDescribeMergeConflictsInput {
	s.NextToken = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *BatchDescribeMergeConflictsInput) SetRepositoryName(v string) *BatchDescribeMergeConflictsInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitSpecifier sets the SourceCommitSpecifier field's value.
func (s *BatchDescribeMergeConflictsInput) SetSourceCommitSpecifier(v string) *BatchDescribeMergeConflictsInput {
	s.SourceCommitSpecifier = &v
	return s
}

type BatchDescribeMergeConflictsOutput struct {
	_ struct{} `type:"structure"`

	// The commit ID of the merge base.
	BaseCommitId *string `locationName:"baseCommitId" type:"string"`

	// A list of conflicts for each file, including the conflict metadata and the
	// hunks of the differences between the files.
	//
	// Conflicts is a required field
	Conflicts []*Conflict `locationName:"conflicts" type:"list" required:"true"`

	// The commit ID of the destination commit specifier that was used in the merge
	// evaluation.
	//
	// DestinationCommitId is a required field
	DestinationCommitId *string `locationName:"destinationCommitId" type:"string" required:"true"`

	// A list of any errors returned while describing the merge conflicts for each
	// file.
	Errors []*BatchDescribeMergeConflictsError `locationName:"errors" type:"list"`

	// An enumeration token that can be used in a request to return the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The commit ID of the source commit specifier that was used in the merge evaluation.
	//
	// SourceCommitId is a required field
	SourceCommitId *string `locationName:"sourceCommitId" type:"string" required:"true"`
}

// String returns the string representation
func (s BatchDescribeMergeConflictsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDescribeMergeConflictsOutput) GoString() string {
	return s.String()
}

// SetBaseCommitId sets the BaseCommitId field's value.
func (s *BatchDescribeMergeConflictsOutput) SetBaseCommitId(v string) *BatchDescribeMergeConflictsOutput {
	s.BaseCommitId = &v
	return s
}

// SetConflicts sets the Conflicts field's value.
func (s *BatchDescribeMergeConflictsOutput) SetConflicts(v []*Conflict) *BatchDescribeMergeConflictsOutput {
	s.Conflicts = v
	return s
}

// SetDestinationCommitId sets the DestinationCommitId field's value.
func (s *BatchDescribeMergeConflictsOutput) SetDestinationCommitId(v string) *BatchDescribeMergeConflictsOutput {
	s.DestinationCommitId = &v
	return s
}

// SetErrors sets the Errors field's value.
func (s *BatchDescribeMergeConflictsOutput) SetErrors(v []*BatchDescribeMergeConflictsError) *BatchDescribeMergeConflictsOutput {
	s.Errors = v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *BatchDescribeMergeConflictsOutput) SetNextToken(v string) *BatchDescribeMergeConflictsOutput {
	s.NextToken = &v
	return s
}

// SetSourceCommitId sets the SourceCommitId field's value.
func (s *BatchDescribeMergeConflictsOutput) SetSourceCommitId(v string) *BatchDescribeMergeConflictsOutput {
	s.SourceCommitId = &v
	return s
}

// Returns information about errors in a BatchDisassociateApprovalRuleTemplateFromRepositories
// operation.
type BatchDisassociateApprovalRuleTemplateFromRepositoriesError struct {
	_ struct{} `type:"structure"`

	// An error code that specifies whether the repository name was not valid or
	// not found.
	ErrorCode *string `locationName:"errorCode" type:"string"`

	// An error message that provides details about why the repository name was
	// either not found or not valid.
	ErrorMessage *string `locationName:"errorMessage" type:"string"`

	// The name of the repository where the association with the template was not
	// able to be removed.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s BatchDisassociateApprovalRuleTemplateFromRepositoriesError) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDisassociateApprovalRuleTemplateFromRepositoriesError) GoString() string {
	return s.String()
}

// SetErrorCode sets the ErrorCode field's value.
func (s *BatchDisassociateApprovalRuleTemplateFromRepositoriesError) SetErrorCode(v string) *BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
	s.ErrorCode = &v
	return s
}

// SetErrorMessage sets the ErrorMessage field's value.
func (s *BatchDisassociateApprovalRuleTemplateFromRepositoriesError) SetErrorMessage(v string) *BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
	s.ErrorMessage = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *BatchDisassociateApprovalRuleTemplateFromRepositoriesError) SetRepositoryName(v string) *BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
	s.RepositoryName = &v
	return s
}

type BatchDisassociateApprovalRuleTemplateFromRepositoriesInput struct {
	_ struct{} `type:"structure"`

	// The name of the template that you want to disassociate from one or more repositories.
	//
	// ApprovalRuleTemplateName is a required field
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string" required:"true"`

	// The repository names that you want to disassociate from the approval rule
	// template.
	//
	// The length constraint limit is for each string in the array. The array itself
	// can be empty.
	//
	// RepositoryNames is a required field
	RepositoryNames []*string `locationName:"repositoryNames" type:"list" required:"true"`
}

// String returns the string representation
func (s BatchDisassociateApprovalRuleTemplateFromRepositoriesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDisassociateApprovalRuleTemplateFromRepositoriesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchDisassociateApprovalRuleTemplateFromRepositoriesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchDisassociateApprovalRuleTemplateFromRepositoriesInput"}
	if s.ApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateName"))
	}
	if s.ApprovalRuleTemplateName != nil && len(*s.ApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleTemplateName", 1))
	}
	if s.RepositoryNames == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryNames"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *BatchDisassociateApprovalRuleTemplateFromRepositoriesInput) SetApprovalRuleTemplateName(v string) *BatchDisassociateApprovalRuleTemplateFromRepositoriesInput {
	s.ApprovalRuleTemplateName = &v
	return s
}

// SetRepositoryNames sets the RepositoryNames field's value.
func (s *BatchDisassociateApprovalRuleTemplateFromRepositoriesInput) SetRepositoryNames(v []*string) *BatchDisassociateApprovalRuleTemplateFromRepositoriesInput {
	s.RepositoryNames = v
	return s
}

type BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput struct {
	_ struct{} `type:"structure"`

	// A list of repository names that have had their association with the template
	// removed.
	//
	// DisassociatedRepositoryNames is a required field
	DisassociatedRepositoryNames []*string `locationName:"disassociatedRepositoryNames" type:"list" required:"true"`

	// A list of any errors that might have occurred while attempting to remove
	// the association between the template and the repositories.
	//
	// Errors is a required field
	Errors []*BatchDisassociateApprovalRuleTemplateFromRepositoriesError `locationName:"errors" type:"list" required:"true"`
}

// String returns the string representation
func (s BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput) GoString() string {
	return s.String()
}

// SetDisassociatedRepositoryNames sets the DisassociatedRepositoryNames field's value.
func (s *BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput) SetDisassociatedRepositoryNames(v []*string) *BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput {
	s.DisassociatedRepositoryNames = v
	return s
}

// SetErrors sets the Errors field's value.
func (s *BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput) SetErrors(v []*BatchDisassociateApprovalRuleTemplateFromRepositoriesError) *BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput {
	s.Errors = v
	return s
}

// Returns information about errors in a BatchGetCommits operation.
type BatchGetCommitsError struct {
	_ struct{} `type:"structure"`

	// A commit ID that either could not be found or was not in a valid format.
	CommitId *string `locationName:"commitId" type:"string"`

	// An error code that specifies whether the commit ID was not valid or not found.
	ErrorCode *string `locationName:"errorCode" type:"string"`

	// An error message that provides detail about why the commit ID either was
	// not found or was not valid.
	ErrorMessage *string `locationName:"errorMessage" type:"string"`
}

// String returns the string representation
func (s BatchGetCommitsError) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetCommitsError) GoString() string {
	return s.String()
}

// SetCommitId sets the CommitId field's value.
func (s *BatchGetCommitsError) SetCommitId(v string) *BatchGetCommitsError {
	s.CommitId = &v
	return s
}

// SetErrorCode sets the ErrorCode field's value.
func (s *BatchGetCommitsError) SetErrorCode(v string) *BatchGetCommitsError {
	s.ErrorCode = &v
	return s
}

// SetErrorMessage sets the ErrorMessage field's value.
func (s *BatchGetCommitsError) SetErrorMessage(v string) *BatchGetCommitsError {
	s.ErrorMessage = &v
	return s
}

type BatchGetCommitsInput struct {
	_ struct{} `type:"structure"`

	// The full commit IDs of the commits to get information about.
	//
	// You must supply the full SHA IDs of each commit. You cannot use shortened
	// SHA IDs.
	//
	// CommitIds is a required field
	CommitIds []*string `locationName:"commitIds" type:"list" required:"true"`

	// The name of the repository that contains the commits.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s BatchGetCommitsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetCommitsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetCommitsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchGetCommitsInput"}
	if s.CommitIds == nil {
		invalidParams.Add(request.NewErrParamRequired("CommitIds"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetCommitIds sets the CommitIds field's value.
func (s *BatchGetCommitsInput) SetCommitIds(v []*string) *BatchGetCommitsInput {
	s.CommitIds = v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *BatchGetCommitsInput) SetRepositoryName(v string) *BatchGetCommitsInput {
	s.RepositoryName = &v
	return s
}

type BatchGetCommitsOutput struct {
	_ struct{} `type:"structure"`

	// An array of commit data type objects, each of which contains information
	// about a specified commit.
	Commits []*Commit `locationName:"commits" type:"list"`

	// Returns any commit IDs for which information could not be found. For example,
	// if one of the commit IDs was a shortened SHA ID or that commit was not found
	// in the specified repository, the ID returns an error object with more information.
	Errors []*BatchGetCommitsError `locationName:"errors" type:"list"`
}

// String returns the string representation
func (s BatchGetCommitsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetCommitsOutput) GoString() string {
	return s.String()
}

// SetCommits sets the Commits field's value.
func (s *BatchGetCommitsOutput) SetCommits(v []*Commit) *BatchGetCommitsOutput {
	s.Commits = v
	return s
}

// SetErrors sets the Errors field's value.
func (s *BatchGetCommitsOutput) SetErrors(v []*BatchGetCommitsError) *BatchGetCommitsOutput {
	s.Errors = v
	return s
}

// Represents the input of a batch get repositories operation.
type BatchGetRepositoriesInput struct {
	_ struct{} `type:"structure"`

	// The names of the repositories to get information about.
	//
	// The length constraint limit is for each string in the array. The array itself
	// can be empty.
	//
	// RepositoryNames is a required field
	RepositoryNames []*string `locationName:"repositoryNames" type:"list" required:"true"`
}

// String returns the string representation
func (s BatchGetRepositoriesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetRepositoriesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *BatchGetRepositoriesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "BatchGetRepositoriesInput"}
	if s.RepositoryNames == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryNames"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetRepositoryNames sets the RepositoryNames field's value.
func (s *BatchGetRepositoriesInput) SetRepositoryNames(v []*string) *BatchGetRepositoriesInput {
	s.RepositoryNames = v
	return s
}

// Represents the output of a batch get repositories operation.
type BatchGetRepositoriesOutput struct {
	_ struct{} `type:"structure"`

	// A list of repositories returned by the batch get repositories operation.
	Repositories []*RepositoryMetadata `locationName:"repositories" type:"list"`

	// Returns a list of repository names for which information could not be found.
	RepositoriesNotFound []*string `locationName:"repositoriesNotFound" type:"list"`
}

// String returns the string representation
func (s BatchGetRepositoriesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BatchGetRepositoriesOutput) GoString() string {
	return s.String()
}

// SetRepositories sets the Repositories field's value.
func (s *BatchGetRepositoriesOutput) SetRepositories(v []*RepositoryMetadata) *BatchGetRepositoriesOutput {
	s.Repositories = v
	return s
}

// SetRepositoriesNotFound sets the RepositoriesNotFound field's value.
func (s *BatchGetRepositoriesOutput) SetRepositoriesNotFound(v []*string) *BatchGetRepositoriesOutput {
	s.RepositoriesNotFound = v
	return s
}

// The before commit ID and the after commit ID are the same, which is not valid.
// The before commit ID and the after commit ID must be different commit IDs.
type BeforeCommitIdAndAfterCommitIdAreSameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s BeforeCommitIdAndAfterCommitIdAreSameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BeforeCommitIdAndAfterCommitIdAreSameException) GoString() string {
	return s.String()
}

func newErrorBeforeCommitIdAndAfterCommitIdAreSameException(v protocol.ResponseMetadata) error {
	return &BeforeCommitIdAndAfterCommitIdAreSameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *BeforeCommitIdAndAfterCommitIdAreSameException) Code() string {
	return "BeforeCommitIdAndAfterCommitIdAreSameException"
}

// Message returns the exception's message.
func (s *BeforeCommitIdAndAfterCommitIdAreSameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *BeforeCommitIdAndAfterCommitIdAreSameException) OrigErr() error {
	return nil
}

func (s *BeforeCommitIdAndAfterCommitIdAreSameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *BeforeCommitIdAndAfterCommitIdAreSameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *BeforeCommitIdAndAfterCommitIdAreSameException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified blob does not exist.
type BlobIdDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s BlobIdDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BlobIdDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorBlobIdDoesNotExistException(v protocol.ResponseMetadata) error {
	return &BlobIdDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *BlobIdDoesNotExistException) Code() string {
	return "BlobIdDoesNotExistException"
}

// Message returns the exception's message.
func (s *BlobIdDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *BlobIdDoesNotExistException) OrigErr() error {
	return nil
}

func (s *BlobIdDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *BlobIdDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *BlobIdDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A blob ID is required, but was not specified.
type BlobIdRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s BlobIdRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BlobIdRequiredException) GoString() string {
	return s.String()
}

func newErrorBlobIdRequiredException(v protocol.ResponseMetadata) error {
	return &BlobIdRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *BlobIdRequiredException) Code() string {
	return "BlobIdRequiredException"
}

// Message returns the exception's message.
func (s *BlobIdRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *BlobIdRequiredException) OrigErr() error {
	return nil
}

func (s *BlobIdRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *BlobIdRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *BlobIdRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about a specific Git blob object.
type BlobMetadata struct {
	_ struct{} `type:"structure"`

	// The full ID of the blob.
	BlobId *string `locationName:"blobId" type:"string"`

	// The file mode permissions of the blob. File mode permission codes include:
	//
	//    * 100644 indicates read/write
	//
	//    * 100755 indicates read/write/execute
	//
	//    * 160000 indicates a submodule
	//
	//    * 120000 indicates a symlink
	Mode *string `locationName:"mode" type:"string"`

	// The path to the blob and associated file name, if any.
	Path *string `locationName:"path" type:"string"`
}

// String returns the string representation
func (s BlobMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BlobMetadata) GoString() string {
	return s.String()
}

// SetBlobId sets the BlobId field's value.
func (s *BlobMetadata) SetBlobId(v string) *BlobMetadata {
	s.BlobId = &v
	return s
}

// SetMode sets the Mode field's value.
func (s *BlobMetadata) SetMode(v string) *BlobMetadata {
	s.Mode = &v
	return s
}

// SetPath sets the Path field's value.
func (s *BlobMetadata) SetPath(v string) *BlobMetadata {
	s.Path = &v
	return s
}

// The specified branch does not exist.
type BranchDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s BranchDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BranchDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorBranchDoesNotExistException(v protocol.ResponseMetadata) error {
	return &BranchDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *BranchDoesNotExistException) Code() string {
	return "BranchDoesNotExistException"
}

// Message returns the exception's message.
func (s *BranchDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *BranchDoesNotExistException) OrigErr() error {
	return nil
}

func (s *BranchDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *BranchDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *BranchDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about a branch.
type BranchInfo struct {
	_ struct{} `type:"structure"`

	// The name of the branch.
	BranchName *string `locationName:"branchName" min:"1" type:"string"`

	// The ID of the last commit made to the branch.
	CommitId *string `locationName:"commitId" type:"string"`
}

// String returns the string representation
func (s BranchInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BranchInfo) GoString() string {
	return s.String()
}

// SetBranchName sets the BranchName field's value.
func (s *BranchInfo) SetBranchName(v string) *BranchInfo {
	s.BranchName = &v
	return s
}

// SetCommitId sets the CommitId field's value.
func (s *BranchInfo) SetCommitId(v string) *BranchInfo {
	s.CommitId = &v
	return s
}

// Cannot create the branch with the specified name because the commit conflicts
// with an existing branch with the same name. Branch names must be unique.
type BranchNameExistsException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s BranchNameExistsException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BranchNameExistsException) GoString() string {
	return s.String()
}

func newErrorBranchNameExistsException(v protocol.ResponseMetadata) error {
	return &BranchNameExistsException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *BranchNameExistsException) Code() string {
	return "BranchNameExistsException"
}

// Message returns the exception's message.
func (s *BranchNameExistsException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *BranchNameExistsException) OrigErr() error {
	return nil
}

func (s *BranchNameExistsException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *BranchNameExistsException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *BranchNameExistsException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified branch name is not valid because it is a tag name. Enter the
// name of a branch in the repository. For a list of valid branch names, use
// ListBranches.
type BranchNameIsTagNameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s BranchNameIsTagNameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BranchNameIsTagNameException) GoString() string {
	return s.String()
}

func newErrorBranchNameIsTagNameException(v protocol.ResponseMetadata) error {
	return &BranchNameIsTagNameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *BranchNameIsTagNameException) Code() string {
	return "BranchNameIsTagNameException"
}

// Message returns the exception's message.
func (s *BranchNameIsTagNameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *BranchNameIsTagNameException) OrigErr() error {
	return nil
}

func (s *BranchNameIsTagNameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *BranchNameIsTagNameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *BranchNameIsTagNameException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A branch name is required, but was not specified.
type BranchNameRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s BranchNameRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s BranchNameRequiredException) GoString() string {
	return s.String()
}

func newErrorBranchNameRequiredException(v protocol.ResponseMetadata) error {
	return &BranchNameRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *BranchNameRequiredException) Code() string {
	return "BranchNameRequiredException"
}

// Message returns the exception's message.
func (s *BranchNameRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *BranchNameRequiredException) OrigErr() error {
	return nil
}

func (s *BranchNameRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *BranchNameRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *BranchNameRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The approval rule cannot be deleted from the pull request because it was
// created by an approval rule template and applied to the pull request automatically.
type CannotDeleteApprovalRuleFromTemplateException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CannotDeleteApprovalRuleFromTemplateException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CannotDeleteApprovalRuleFromTemplateException) GoString() string {
	return s.String()
}

func newErrorCannotDeleteApprovalRuleFromTemplateException(v protocol.ResponseMetadata) error {
	return &CannotDeleteApprovalRuleFromTemplateException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CannotDeleteApprovalRuleFromTemplateException) Code() string {
	return "CannotDeleteApprovalRuleFromTemplateException"
}

// Message returns the exception's message.
func (s *CannotDeleteApprovalRuleFromTemplateException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CannotDeleteApprovalRuleFromTemplateException) OrigErr() error {
	return nil
}

func (s *CannotDeleteApprovalRuleFromTemplateException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CannotDeleteApprovalRuleFromTemplateException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CannotDeleteApprovalRuleFromTemplateException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The approval rule cannot be modified for the pull request because it was
// created by an approval rule template and applied to the pull request automatically.
type CannotModifyApprovalRuleFromTemplateException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CannotModifyApprovalRuleFromTemplateException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CannotModifyApprovalRuleFromTemplateException) GoString() string {
	return s.String()
}

func newErrorCannotModifyApprovalRuleFromTemplateException(v protocol.ResponseMetadata) error {
	return &CannotModifyApprovalRuleFromTemplateException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CannotModifyApprovalRuleFromTemplateException) Code() string {
	return "CannotModifyApprovalRuleFromTemplateException"
}

// Message returns the exception's message.
func (s *CannotModifyApprovalRuleFromTemplateException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CannotModifyApprovalRuleFromTemplateException) OrigErr() error {
	return nil
}

func (s *CannotModifyApprovalRuleFromTemplateException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CannotModifyApprovalRuleFromTemplateException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CannotModifyApprovalRuleFromTemplateException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A client request token is required. A client request token is an unique,
// client-generated idempotency token that, when provided in a request, ensures
// the request cannot be repeated with a changed parameter. If a request is
// received with the same parameters and a token is included, the request returns
// information about the initial request that used that token.
type ClientRequestTokenRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ClientRequestTokenRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ClientRequestTokenRequiredException) GoString() string {
	return s.String()
}

func newErrorClientRequestTokenRequiredException(v protocol.ResponseMetadata) error {
	return &ClientRequestTokenRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ClientRequestTokenRequiredException) Code() string {
	return "ClientRequestTokenRequiredException"
}

// Message returns the exception's message.
func (s *ClientRequestTokenRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ClientRequestTokenRequiredException) OrigErr() error {
	return nil
}

func (s *ClientRequestTokenRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ClientRequestTokenRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ClientRequestTokenRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about a specific comment.
type Comment struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the person who posted the comment.
	AuthorArn *string `locationName:"authorArn" type:"string"`

	// The emoji reactions to a comment, if any, submitted by the user whose credentials
	// are associated with the call to the API.
	CallerReactions []*string `locationName:"callerReactions" type:"list"`

	// A unique, client-generated idempotency token that, when provided in a request,
	// ensures the request cannot be repeated with a changed parameter. If a request
	// is received with the same parameters and a token is included, the request
	// returns information about the initial request that used that token.
	ClientRequestToken *string `locationName:"clientRequestToken" type:"string"`

	// The system-generated comment ID.
	CommentId *string `locationName:"commentId" type:"string"`

	// The content of the comment.
	Content *string `locationName:"content" type:"string"`

	// The date and time the comment was created, in timestamp format.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp"`

	// A Boolean value indicating whether the comment has been deleted.
	Deleted *bool `locationName:"deleted" type:"boolean"`

	// The ID of the comment for which this comment is a reply, if any.
	InReplyTo *string `locationName:"inReplyTo" type:"string"`

	// The date and time the comment was most recently modified, in timestamp format.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp"`

	// A string to integer map that represents the number of individual users who
	// have responded to a comment with the specified reactions.
	ReactionCounts map[string]*int64 `locationName:"reactionCounts" type:"map"`
}

// String returns the string representation
func (s Comment) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Comment) GoString() string {
	return s.String()
}

// SetAuthorArn sets the AuthorArn field's value.
func (s *Comment) SetAuthorArn(v string) *Comment {
	s.AuthorArn = &v
	return s
}

// SetCallerReactions sets the CallerReactions field's value.
func (s *Comment) SetCallerReactions(v []*string) *Comment {
	s.CallerReactions = v
	return s
}

// SetClientRequestToken sets the ClientRequestToken field's value.
func (s *Comment) SetClientRequestToken(v string) *Comment {
	s.ClientRequestToken = &v
	return s
}

// SetCommentId sets the CommentId field's value.
func (s *Comment) SetCommentId(v string) *Comment {
	s.CommentId = &v
	return s
}

// SetContent sets the Content field's value.
func (s *Comment) SetContent(v string) *Comment {
	s.Content = &v
	return s
}

// SetCreationDate sets the CreationDate field's value.
func (s *Comment) SetCreationDate(v time.Time) *Comment {
	s.CreationDate = &v
	return s
}

// SetDeleted sets the Deleted field's value.
func (s *Comment) SetDeleted(v bool) *Comment {
	s.Deleted = &v
	return s
}

// SetInReplyTo sets the InReplyTo field's value.
func (s *Comment) SetInReplyTo(v string) *Comment {
	s.InReplyTo = &v
	return s
}

// SetLastModifiedDate sets the LastModifiedDate field's value.
func (s *Comment) SetLastModifiedDate(v time.Time) *Comment {
	s.LastModifiedDate = &v
	return s
}

// SetReactionCounts sets the ReactionCounts field's value.
func (s *Comment) SetReactionCounts(v map[string]*int64) *Comment {
	s.ReactionCounts = v
	return s
}

// The comment is empty. You must provide some content for a comment. The content
// cannot be null.
type CommentContentRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommentContentRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommentContentRequiredException) GoString() string {
	return s.String()
}

func newErrorCommentContentRequiredException(v protocol.ResponseMetadata) error {
	return &CommentContentRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommentContentRequiredException) Code() string {
	return "CommentContentRequiredException"
}

// Message returns the exception's message.
func (s *CommentContentRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommentContentRequiredException) OrigErr() error {
	return nil
}

func (s *CommentContentRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommentContentRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommentContentRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The comment is too large. Comments are limited to 1,000 characters.
type CommentContentSizeLimitExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommentContentSizeLimitExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommentContentSizeLimitExceededException) GoString() string {
	return s.String()
}

func newErrorCommentContentSizeLimitExceededException(v protocol.ResponseMetadata) error {
	return &CommentContentSizeLimitExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommentContentSizeLimitExceededException) Code() string {
	return "CommentContentSizeLimitExceededException"
}

// Message returns the exception's message.
func (s *CommentContentSizeLimitExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommentContentSizeLimitExceededException) OrigErr() error {
	return nil
}

func (s *CommentContentSizeLimitExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommentContentSizeLimitExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommentContentSizeLimitExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// This comment has already been deleted. You cannot edit or delete a deleted
// comment.
type CommentDeletedException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommentDeletedException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommentDeletedException) GoString() string {
	return s.String()
}

func newErrorCommentDeletedException(v protocol.ResponseMetadata) error {
	return &CommentDeletedException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommentDeletedException) Code() string {
	return "CommentDeletedException"
}

// Message returns the exception's message.
func (s *CommentDeletedException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommentDeletedException) OrigErr() error {
	return nil
}

func (s *CommentDeletedException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommentDeletedException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommentDeletedException) RequestID() string {
	return s.RespMetadata.RequestID
}

// No comment exists with the provided ID. Verify that you have used the correct
// ID, and then try again.
type CommentDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommentDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommentDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorCommentDoesNotExistException(v protocol.ResponseMetadata) error {
	return &CommentDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommentDoesNotExistException) Code() string {
	return "CommentDoesNotExistException"
}

// Message returns the exception's message.
func (s *CommentDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommentDoesNotExistException) OrigErr() error {
	return nil
}

func (s *CommentDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommentDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommentDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The comment ID is missing or null. A comment ID is required.
type CommentIdRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommentIdRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommentIdRequiredException) GoString() string {
	return s.String()
}

func newErrorCommentIdRequiredException(v protocol.ResponseMetadata) error {
	return &CommentIdRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommentIdRequiredException) Code() string {
	return "CommentIdRequiredException"
}

// Message returns the exception's message.
func (s *CommentIdRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommentIdRequiredException) OrigErr() error {
	return nil
}

func (s *CommentIdRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommentIdRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommentIdRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// You cannot modify or delete this comment. Only comment authors can modify
// or delete their comments.
type CommentNotCreatedByCallerException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommentNotCreatedByCallerException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommentNotCreatedByCallerException) GoString() string {
	return s.String()
}

func newErrorCommentNotCreatedByCallerException(v protocol.ResponseMetadata) error {
	return &CommentNotCreatedByCallerException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommentNotCreatedByCallerException) Code() string {
	return "CommentNotCreatedByCallerException"
}

// Message returns the exception's message.
func (s *CommentNotCreatedByCallerException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommentNotCreatedByCallerException) OrigErr() error {
	return nil
}

func (s *CommentNotCreatedByCallerException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommentNotCreatedByCallerException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommentNotCreatedByCallerException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about comments on the comparison between two commits.
type CommentsForComparedCommit struct {
	_ struct{} `type:"structure"`

	// The full blob ID of the commit used to establish the after of the comparison.
	AfterBlobId *string `locationName:"afterBlobId" type:"string"`

	// The full commit ID of the commit used to establish the after of the comparison.
	AfterCommitId *string `locationName:"afterCommitId" type:"string"`

	// The full blob ID of the commit used to establish the before of the comparison.
	BeforeBlobId *string `locationName:"beforeBlobId" type:"string"`

	// The full commit ID of the commit used to establish the before of the comparison.
	BeforeCommitId *string `locationName:"beforeCommitId" type:"string"`

	// An array of comment objects. Each comment object contains information about
	// a comment on the comparison between commits.
	Comments []*Comment `locationName:"comments" type:"list"`

	// Location information about the comment on the comparison, including the file
	// name, line number, and whether the version of the file where the comment
	// was made is BEFORE or AFTER.
	Location *Location `locationName:"location" type:"structure"`

	// The name of the repository that contains the compared commits.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s CommentsForComparedCommit) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommentsForComparedCommit) GoString() string {
	return s.String()
}

// SetAfterBlobId sets the AfterBlobId field's value.
func (s *CommentsForComparedCommit) SetAfterBlobId(v string) *CommentsForComparedCommit {
	s.AfterBlobId = &v
	return s
}

// SetAfterCommitId sets the AfterCommitId field's value.
func (s *CommentsForComparedCommit) SetAfterCommitId(v string) *CommentsForComparedCommit {
	s.AfterCommitId = &v
	return s
}

// SetBeforeBlobId sets the BeforeBlobId field's value.
func (s *CommentsForComparedCommit) SetBeforeBlobId(v string) *CommentsForComparedCommit {
	s.BeforeBlobId = &v
	return s
}

// SetBeforeCommitId sets the BeforeCommitId field's value.
func (s *CommentsForComparedCommit) SetBeforeCommitId(v string) *CommentsForComparedCommit {
	s.BeforeCommitId = &v
	return s
}

// SetComments sets the Comments field's value.
func (s *CommentsForComparedCommit) SetComments(v []*Comment) *CommentsForComparedCommit {
	s.Comments = v
	return s
}

// SetLocation sets the Location field's value.
func (s *CommentsForComparedCommit) SetLocation(v *Location) *CommentsForComparedCommit {
	s.Location = v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *CommentsForComparedCommit) SetRepositoryName(v string) *CommentsForComparedCommit {
	s.RepositoryName = &v
	return s
}

// Returns information about comments on a pull request.
type CommentsForPullRequest struct {
	_ struct{} `type:"structure"`

	// The full blob ID of the file on which you want to comment on the source commit.
	AfterBlobId *string `locationName:"afterBlobId" type:"string"`

	// The full commit ID of the commit that was the tip of the source branch at
	// the time the comment was made.
	AfterCommitId *string `locationName:"afterCommitId" type:"string"`

	// The full blob ID of the file on which you want to comment on the destination
	// commit.
	BeforeBlobId *string `locationName:"beforeBlobId" type:"string"`

	// The full commit ID of the commit that was the tip of the destination branch
	// when the pull request was created. This commit is superceded by the after
	// commit in the source branch when and if you merge the source branch into
	// the destination branch.
	BeforeCommitId *string `locationName:"beforeCommitId" type:"string"`

	// An array of comment objects. Each comment object contains information about
	// a comment on the pull request.
	Comments []*Comment `locationName:"comments" type:"list"`

	// Location information about the comment on the pull request, including the
	// file name, line number, and whether the version of the file where the comment
	// was made is BEFORE (destination branch) or AFTER (source branch).
	Location *Location `locationName:"location" type:"structure"`

	// The system-generated ID of the pull request.
	PullRequestId *string `locationName:"pullRequestId" type:"string"`

	// The name of the repository that contains the pull request.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s CommentsForPullRequest) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommentsForPullRequest) GoString() string {
	return s.String()
}

// SetAfterBlobId sets the AfterBlobId field's value.
func (s *CommentsForPullRequest) SetAfterBlobId(v string) *CommentsForPullRequest {
	s.AfterBlobId = &v
	return s
}

// SetAfterCommitId sets the AfterCommitId field's value.
func (s *CommentsForPullRequest) SetAfterCommitId(v string) *CommentsForPullRequest {
	s.AfterCommitId = &v
	return s
}

// SetBeforeBlobId sets the BeforeBlobId field's value.
func (s *CommentsForPullRequest) SetBeforeBlobId(v string) *CommentsForPullRequest {
	s.BeforeBlobId = &v
	return s
}

// SetBeforeCommitId sets the BeforeCommitId field's value.
func (s *CommentsForPullRequest) SetBeforeCommitId(v string) *CommentsForPullRequest {
	s.BeforeCommitId = &v
	return s
}

// SetComments sets the Comments field's value.
func (s *CommentsForPullRequest) SetComments(v []*Comment) *CommentsForPullRequest {
	s.Comments = v
	return s
}

// SetLocation sets the Location field's value.
func (s *CommentsForPullRequest) SetLocation(v *Location) *CommentsForPullRequest {
	s.Location = v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *CommentsForPullRequest) SetPullRequestId(v string) *CommentsForPullRequest {
	s.PullRequestId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *CommentsForPullRequest) SetRepositoryName(v string) *CommentsForPullRequest {
	s.RepositoryName = &v
	return s
}

// Returns information about a specific commit.
type Commit struct {
	_ struct{} `type:"structure"`

	// Any other data associated with the specified commit.
	AdditionalData *string `locationName:"additionalData" type:"string"`

	// Information about the author of the specified commit. Information includes
	// the date in timestamp format with GMT offset, the name of the author, and
	// the email address for the author, as configured in Git.
	Author *UserInfo `locationName:"author" type:"structure"`

	// The full SHA ID of the specified commit.
	CommitId *string `locationName:"commitId" type:"string"`

	// Information about the person who committed the specified commit, also known
	// as the committer. Information includes the date in timestamp format with
	// GMT offset, the name of the committer, and the email address for the committer,
	// as configured in Git.
	//
	// For more information about the difference between an author and a committer
	// in Git, see Viewing the Commit History (http://git-scm.com/book/ch2-3.html)
	// in Pro Git by Scott Chacon and Ben Straub.
	Committer *UserInfo `locationName:"committer" type:"structure"`

	// The commit message associated with the specified commit.
	Message *string `locationName:"message" type:"string"`

	// A list of parent commits for the specified commit. Each parent commit ID
	// is the full commit ID.
	Parents []*string `locationName:"parents" type:"list"`

	// Tree information for the specified commit.
	TreeId *string `locationName:"treeId" type:"string"`
}

// String returns the string representation
func (s Commit) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Commit) GoString() string {
	return s.String()
}

// SetAdditionalData sets the AdditionalData field's value.
func (s *Commit) SetAdditionalData(v string) *Commit {
	s.AdditionalData = &v
	return s
}

// SetAuthor sets the Author field's value.
func (s *Commit) SetAuthor(v *UserInfo) *Commit {
	s.Author = v
	return s
}

// SetCommitId sets the CommitId field's value.
func (s *Commit) SetCommitId(v string) *Commit {
	s.CommitId = &v
	return s
}

// SetCommitter sets the Committer field's value.
func (s *Commit) SetCommitter(v *UserInfo) *Commit {
	s.Committer = v
	return s
}

// SetMessage sets the Message field's value.
func (s *Commit) SetMessage(v string) *Commit {
	s.Message = &v
	return s
}

// SetParents sets the Parents field's value.
func (s *Commit) SetParents(v []*string) *Commit {
	s.Parents = v
	return s
}

// SetTreeId sets the TreeId field's value.
func (s *Commit) SetTreeId(v string) *Commit {
	s.TreeId = &v
	return s
}

// The specified commit does not exist or no commit was specified, and the specified
// repository has no default branch.
type CommitDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommitDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommitDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorCommitDoesNotExistException(v protocol.ResponseMetadata) error {
	return &CommitDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommitDoesNotExistException) Code() string {
	return "CommitDoesNotExistException"
}

// Message returns the exception's message.
func (s *CommitDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommitDoesNotExistException) OrigErr() error {
	return nil
}

func (s *CommitDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommitDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommitDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified commit ID does not exist.
type CommitIdDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommitIdDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommitIdDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorCommitIdDoesNotExistException(v protocol.ResponseMetadata) error {
	return &CommitIdDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommitIdDoesNotExistException) Code() string {
	return "CommitIdDoesNotExistException"
}

// Message returns the exception's message.
func (s *CommitIdDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommitIdDoesNotExistException) OrigErr() error {
	return nil
}

func (s *CommitIdDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommitIdDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommitIdDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A commit ID was not specified.
type CommitIdRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommitIdRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommitIdRequiredException) GoString() string {
	return s.String()
}

func newErrorCommitIdRequiredException(v protocol.ResponseMetadata) error {
	return &CommitIdRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommitIdRequiredException) Code() string {
	return "CommitIdRequiredException"
}

// Message returns the exception's message.
func (s *CommitIdRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommitIdRequiredException) OrigErr() error {
	return nil
}

func (s *CommitIdRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommitIdRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommitIdRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The maximum number of allowed commit IDs in a batch request is 100. Verify
// that your batch requests contains no more than 100 commit IDs, and then try
// again.
type CommitIdsLimitExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommitIdsLimitExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommitIdsLimitExceededException) GoString() string {
	return s.String()
}

func newErrorCommitIdsLimitExceededException(v protocol.ResponseMetadata) error {
	return &CommitIdsLimitExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommitIdsLimitExceededException) Code() string {
	return "CommitIdsLimitExceededException"
}

// Message returns the exception's message.
func (s *CommitIdsLimitExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommitIdsLimitExceededException) OrigErr() error {
	return nil
}

func (s *CommitIdsLimitExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommitIdsLimitExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommitIdsLimitExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A list of commit IDs is required, but was either not specified or the list
// was empty.
type CommitIdsListRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommitIdsListRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommitIdsListRequiredException) GoString() string {
	return s.String()
}

func newErrorCommitIdsListRequiredException(v protocol.ResponseMetadata) error {
	return &CommitIdsListRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommitIdsListRequiredException) Code() string {
	return "CommitIdsListRequiredException"
}

// Message returns the exception's message.
func (s *CommitIdsListRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommitIdsListRequiredException) OrigErr() error {
	return nil
}

func (s *CommitIdsListRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommitIdsListRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommitIdsListRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The commit message is too long. Provide a shorter string.
type CommitMessageLengthExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommitMessageLengthExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommitMessageLengthExceededException) GoString() string {
	return s.String()
}

func newErrorCommitMessageLengthExceededException(v protocol.ResponseMetadata) error {
	return &CommitMessageLengthExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommitMessageLengthExceededException) Code() string {
	return "CommitMessageLengthExceededException"
}

// Message returns the exception's message.
func (s *CommitMessageLengthExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommitMessageLengthExceededException) OrigErr() error {
	return nil
}

func (s *CommitMessageLengthExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommitMessageLengthExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommitMessageLengthExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A commit was not specified.
type CommitRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s CommitRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CommitRequiredException) GoString() string {
	return s.String()
}

func newErrorCommitRequiredException(v protocol.ResponseMetadata) error {
	return &CommitRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *CommitRequiredException) Code() string {
	return "CommitRequiredException"
}

// Message returns the exception's message.
func (s *CommitRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *CommitRequiredException) OrigErr() error {
	return nil
}

func (s *CommitRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *CommitRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *CommitRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The merge cannot be completed because the target branch has been modified.
// Another user might have modified the target branch while the merge was in
// progress. Wait a few minutes, and then try again.
type ConcurrentReferenceUpdateException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ConcurrentReferenceUpdateException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ConcurrentReferenceUpdateException) GoString() string {
	return s.String()
}

func newErrorConcurrentReferenceUpdateException(v protocol.ResponseMetadata) error {
	return &ConcurrentReferenceUpdateException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ConcurrentReferenceUpdateException) Code() string {
	return "ConcurrentReferenceUpdateException"
}

// Message returns the exception's message.
func (s *ConcurrentReferenceUpdateException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ConcurrentReferenceUpdateException) OrigErr() error {
	return nil
}

func (s *ConcurrentReferenceUpdateException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ConcurrentReferenceUpdateException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ConcurrentReferenceUpdateException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about conflicts in a merge operation.
type Conflict struct {
	_ struct{} `type:"structure"`

	// Metadata about a conflict in a merge operation.
	ConflictMetadata *ConflictMetadata `locationName:"conflictMetadata" type:"structure"`

	// A list of hunks that contain the differences between files or lines causing
	// the conflict.
	MergeHunks []*MergeHunk `locationName:"mergeHunks" type:"list"`
}

// String returns the string representation
func (s Conflict) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Conflict) GoString() string {
	return s.String()
}

// SetConflictMetadata sets the ConflictMetadata field's value.
func (s *Conflict) SetConflictMetadata(v *ConflictMetadata) *Conflict {
	s.ConflictMetadata = v
	return s
}

// SetMergeHunks sets the MergeHunks field's value.
func (s *Conflict) SetMergeHunks(v []*MergeHunk) *Conflict {
	s.MergeHunks = v
	return s
}

// Information about the metadata for a conflict in a merge operation.
type ConflictMetadata struct {
	_ struct{} `type:"structure"`

	// A boolean value indicating whether there are conflicts in the content of
	// a file.
	ContentConflict *bool `locationName:"contentConflict" type:"boolean"`

	// A boolean value indicating whether there are conflicts in the file mode of
	// a file.
	FileModeConflict *bool `locationName:"fileModeConflict" type:"boolean"`

	// The file modes of the file in the source, destination, and base of the merge.
	FileModes *FileModes `locationName:"fileModes" type:"structure"`

	// The path of the file that contains conflicts.
	FilePath *string `locationName:"filePath" type:"string"`

	// The file sizes of the file in the source, destination, and base of the merge.
	FileSizes *FileSizes `locationName:"fileSizes" type:"structure"`

	// A boolean value (true or false) indicating whether the file is binary or
	// textual in the source, destination, and base of the merge.
	IsBinaryFile *IsBinaryFile `locationName:"isBinaryFile" type:"structure"`

	// Whether an add, modify, or delete operation caused the conflict between the
	// source and destination of the merge.
	MergeOperations *MergeOperations `locationName:"mergeOperations" type:"structure"`

	// The number of conflicts, including both hunk conflicts and metadata conflicts.
	NumberOfConflicts *int64 `locationName:"numberOfConflicts" type:"integer"`

	// A boolean value (true or false) indicating whether there are conflicts between
	// the branches in the object type of a file, folder, or submodule.
	ObjectTypeConflict *bool `locationName:"objectTypeConflict" type:"boolean"`

	// Information about any object type conflicts in a merge operation.
	ObjectTypes *ObjectTypes `locationName:"objectTypes" type:"structure"`
}

// String returns the string representation
func (s ConflictMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ConflictMetadata) GoString() string {
	return s.String()
}

// SetContentConflict sets the ContentConflict field's value.
func (s *ConflictMetadata) SetContentConflict(v bool) *ConflictMetadata {
	s.ContentConflict = &v
	return s
}

// SetFileModeConflict sets the FileModeConflict field's value.
func (s *ConflictMetadata) SetFileModeConflict(v bool) *ConflictMetadata {
	s.FileModeConflict = &v
	return s
}

// SetFileModes sets the FileModes field's value.
func (s *ConflictMetadata) SetFileModes(v *FileModes) *ConflictMetadata {
	s.FileModes = v
	return s
}

// SetFilePath sets the FilePath field's value.
func (s *ConflictMetadata) SetFilePath(v string) *ConflictMetadata {
	s.FilePath = &v
	return s
}

// SetFileSizes sets the FileSizes field's value.
func (s *ConflictMetadata) SetFileSizes(v *FileSizes) *ConflictMetadata {
	s.FileSizes = v
	return s
}

// SetIsBinaryFile sets the IsBinaryFile field's value.
func (s *ConflictMetadata) SetIsBinaryFile(v *IsBinaryFile) *ConflictMetadata {
	s.IsBinaryFile = v
	return s
}

// SetMergeOperations sets the MergeOperations field's value.
func (s *ConflictMetadata) SetMergeOperations(v *MergeOperations) *ConflictMetadata {
	s.MergeOperations = v
	return s
}

// SetNumberOfConflicts sets the NumberOfConflicts field's value.
func (s *ConflictMetadata) SetNumberOfConflicts(v int64) *ConflictMetadata {
	s.NumberOfConflicts = &v
	return s
}

// SetObjectTypeConflict sets the ObjectTypeConflict field's value.
func (s *ConflictMetadata) SetObjectTypeConflict(v bool) *ConflictMetadata {
	s.ObjectTypeConflict = &v
	return s
}

// SetObjectTypes sets the ObjectTypes field's value.
func (s *ConflictMetadata) SetObjectTypes(v *ObjectTypes) *ConflictMetadata {
	s.ObjectTypes = v
	return s
}

// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use
// when resolving conflicts during a merge.
type ConflictResolution struct {
	_ struct{} `type:"structure"`

	// Files to be deleted as part of the merge conflict resolution.
	DeleteFiles []*DeleteFileEntry `locationName:"deleteFiles" type:"list"`

	// Files to have content replaced as part of the merge conflict resolution.
	ReplaceContents []*ReplaceContentEntry `locationName:"replaceContents" type:"list"`

	// File modes that are set as part of the merge conflict resolution.
	SetFileModes []*SetFileModeEntry `locationName:"setFileModes" type:"list"`
}

// String returns the string representation
func (s ConflictResolution) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ConflictResolution) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ConflictResolution) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "ConflictResolution"}
	if s.DeleteFiles != nil {
		for i, v := range s.DeleteFiles {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "DeleteFiles", i), err.(request.ErrInvalidParams))
			}
		}
	}
	if s.ReplaceContents != nil {
		for i, v := range s.ReplaceContents {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "ReplaceContents", i), err.(request.ErrInvalidParams))
			}
		}
	}
	if s.SetFileModes != nil {
		for i, v := range s.SetFileModes {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "SetFileModes", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetDeleteFiles sets the DeleteFiles field's value.
func (s *ConflictResolution) SetDeleteFiles(v []*DeleteFileEntry) *ConflictResolution {
	s.DeleteFiles = v
	return s
}

// SetReplaceContents sets the ReplaceContents field's value.
func (s *ConflictResolution) SetReplaceContents(v []*ReplaceContentEntry) *ConflictResolution {
	s.ReplaceContents = v
	return s
}

// SetSetFileModes sets the SetFileModes field's value.
func (s *ConflictResolution) SetSetFileModes(v []*SetFileModeEntry) *ConflictResolution {
	s.SetFileModes = v
	return s
}

type CreateApprovalRuleTemplateInput struct {
	_ struct{} `type:"structure"`

	// The content of the approval rule that is created on pull requests in associated
	// repositories. If you specify one or more destination references (branches),
	// approval rules are created in an associated repository only if their destination
	// references (branches) match those specified in the template.
	//
	// When you create the content of the approval rule template, you can specify
	// approvers in an approval pool in one of two ways:
	//
	//    * CodeCommitApprovers: This option only requires an AWS account and a
	//    resource. It can be used for both IAM users and federated access users
	//    whose name matches the provided resource name. This is a very powerful
	//    option that offers a great deal of flexibility. For example, if you specify
	//    the AWS account 123456789012 and Mary_Major, all of the following are
	//    counted as approvals coming from that user: An IAM user in the account
	//    (arn:aws:iam::123456789012:user/Mary_Major) A federated user identified
	//    in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
	//    This option does not recognize an active session of someone assuming the
	//    role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major)
	//    unless you include a wildcard (*Mary_Major).
	//
	//    * Fully qualified ARN: This option allows you to specify the fully qualified
	//    Amazon Resource Name (ARN) of the IAM user or role.
	//
	// For more information about IAM ARNs, wildcards, and formats, see IAM Identifiers
	// (https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html)
	// in the IAM User Guide.
	//
	// ApprovalRuleTemplateContent is a required field
	ApprovalRuleTemplateContent *string `locationName:"approvalRuleTemplateContent" min:"1" type:"string" required:"true"`

	// The description of the approval rule template. Consider providing a description
	// that explains what this template does and when it might be appropriate to
	// associate it with repositories.
	ApprovalRuleTemplateDescription *string `locationName:"approvalRuleTemplateDescription" type:"string"`

	// The name of the approval rule template. Provide descriptive names, because
	// this name is applied to the approval rules created automatically in associated
	// repositories.
	//
	// ApprovalRuleTemplateName is a required field
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateApprovalRuleTemplateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateApprovalRuleTemplateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateApprovalRuleTemplateInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateApprovalRuleTemplateInput"}
	if s.ApprovalRuleTemplateContent == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateContent"))
	}
	if s.ApprovalRuleTemplateContent != nil && len(*s.ApprovalRuleTemplateContent) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleTemplateContent", 1))
	}
	if s.ApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateName"))
	}
	if s.ApprovalRuleTemplateName != nil && len(*s.ApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleTemplateName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleTemplateContent sets the ApprovalRuleTemplateContent field's value.
func (s *CreateApprovalRuleTemplateInput) SetApprovalRuleTemplateContent(v string) *CreateApprovalRuleTemplateInput {
	s.ApprovalRuleTemplateContent = &v
	return s
}

// SetApprovalRuleTemplateDescription sets the ApprovalRuleTemplateDescription field's value.
func (s *CreateApprovalRuleTemplateInput) SetApprovalRuleTemplateDescription(v string) *CreateApprovalRuleTemplateInput {
	s.ApprovalRuleTemplateDescription = &v
	return s
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *CreateApprovalRuleTemplateInput) SetApprovalRuleTemplateName(v string) *CreateApprovalRuleTemplateInput {
	s.ApprovalRuleTemplateName = &v
	return s
}

type CreateApprovalRuleTemplateOutput struct {
	_ struct{} `type:"structure"`

	// The content and structure of the created approval rule template.
	//
	// ApprovalRuleTemplate is a required field
	ApprovalRuleTemplate *ApprovalRuleTemplate `locationName:"approvalRuleTemplate" type:"structure" required:"true"`
}

// String returns the string representation
func (s CreateApprovalRuleTemplateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateApprovalRuleTemplateOutput) GoString() string {
	return s.String()
}

// SetApprovalRuleTemplate sets the ApprovalRuleTemplate field's value.
func (s *CreateApprovalRuleTemplateOutput) SetApprovalRuleTemplate(v *ApprovalRuleTemplate) *CreateApprovalRuleTemplateOutput {
	s.ApprovalRuleTemplate = v
	return s
}

// Represents the input of a create branch operation.
type CreateBranchInput struct {
	_ struct{} `type:"structure"`

	// The name of the new branch to create.
	//
	// BranchName is a required field
	BranchName *string `locationName:"branchName" min:"1" type:"string" required:"true"`

	// The ID of the commit to point the new branch to.
	//
	// CommitId is a required field
	CommitId *string `locationName:"commitId" type:"string" required:"true"`

	// The name of the repository in which you want to create the new branch.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateBranchInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBranchInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateBranchInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateBranchInput"}
	if s.BranchName == nil {
		invalidParams.Add(request.NewErrParamRequired("BranchName"))
	}
	if s.BranchName != nil && len(*s.BranchName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("BranchName", 1))
	}
	if s.CommitId == nil {
		invalidParams.Add(request.NewErrParamRequired("CommitId"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetBranchName sets the BranchName field's value.
func (s *CreateBranchInput) SetBranchName(v string) *CreateBranchInput {
	s.BranchName = &v
	return s
}

// SetCommitId sets the CommitId field's value.
func (s *CreateBranchInput) SetCommitId(v string) *CreateBranchInput {
	s.CommitId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *CreateBranchInput) SetRepositoryName(v string) *CreateBranchInput {
	s.RepositoryName = &v
	return s
}

type CreateBranchOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s CreateBranchOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateBranchOutput) GoString() string {
	return s.String()
}

type CreateCommitInput struct {
	_ struct{} `type:"structure"`

	// The name of the author who created the commit. This information is used as
	// both the author and committer for the commit.
	AuthorName *string `locationName:"authorName" type:"string"`

	// The name of the branch where you create the commit.
	//
	// BranchName is a required field
	BranchName *string `locationName:"branchName" min:"1" type:"string" required:"true"`

	// The commit message you want to include in the commit. Commit messages are
	// limited to 256 KB. If no message is specified, a default message is used.
	CommitMessage *string `locationName:"commitMessage" type:"string"`

	// The files to delete in this commit. These files still exist in earlier commits.
	DeleteFiles []*DeleteFileEntry `locationName:"deleteFiles" type:"list"`

	// The email address of the person who created the commit.
	Email *string `locationName:"email" type:"string"`

	// If the commit contains deletions, whether to keep a folder or folder structure
	// if the changes leave the folders empty. If true, a ..gitkeep file is created
	// for empty folders. The default is false.
	KeepEmptyFolders *bool `locationName:"keepEmptyFolders" type:"boolean"`

	// The ID of the commit that is the parent of the commit you create. Not required
	// if this is an empty repository.
	ParentCommitId *string `locationName:"parentCommitId" type:"string"`

	// The files to add or update in this commit.
	PutFiles []*PutFileEntry `locationName:"putFiles" type:"list"`

	// The name of the repository where you create the commit.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The file modes to update for files in this commit.
	SetFileModes []*SetFileModeEntry `locationName:"setFileModes" type:"list"`
}

// String returns the string representation
func (s CreateCommitInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateCommitInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateCommitInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateCommitInput"}
	if s.BranchName == nil {
		invalidParams.Add(request.NewErrParamRequired("BranchName"))
	}
	if s.BranchName != nil && len(*s.BranchName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("BranchName", 1))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.DeleteFiles != nil {
		for i, v := range s.DeleteFiles {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "DeleteFiles", i), err.(request.ErrInvalidParams))
			}
		}
	}
	if s.PutFiles != nil {
		for i, v := range s.PutFiles {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "PutFiles", i), err.(request.ErrInvalidParams))
			}
		}
	}
	if s.SetFileModes != nil {
		for i, v := range s.SetFileModes {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "SetFileModes", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAuthorName sets the AuthorName field's value.
func (s *CreateCommitInput) SetAuthorName(v string) *CreateCommitInput {
	s.AuthorName = &v
	return s
}

// SetBranchName sets the BranchName field's value.
func (s *CreateCommitInput) SetBranchName(v string) *CreateCommitInput {
	s.BranchName = &v
	return s
}

// SetCommitMessage sets the CommitMessage field's value.
func (s *CreateCommitInput) SetCommitMessage(v string) *CreateCommitInput {
	s.CommitMessage = &v
	return s
}

// SetDeleteFiles sets the DeleteFiles field's value.
func (s *CreateCommitInput) SetDeleteFiles(v []*DeleteFileEntry) *CreateCommitInput {
	s.DeleteFiles = v
	return s
}

// SetEmail sets the Email field's value.
func (s *CreateCommitInput) SetEmail(v string) *CreateCommitInput {
	s.Email = &v
	return s
}

// SetKeepEmptyFolders sets the KeepEmptyFolders field's value.
func (s *CreateCommitInput) SetKeepEmptyFolders(v bool) *CreateCommitInput {
	s.KeepEmptyFolders = &v
	return s
}

// SetParentCommitId sets the ParentCommitId field's value.
func (s *CreateCommitInput) SetParentCommitId(v string) *CreateCommitInput {
	s.ParentCommitId = &v
	return s
}

// SetPutFiles sets the PutFiles field's value.
func (s *CreateCommitInput) SetPutFiles(v []*PutFileEntry) *CreateCommitInput {
	s.PutFiles = v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *CreateCommitInput) SetRepositoryName(v string) *CreateCommitInput {
	s.RepositoryName = &v
	return s
}

// SetSetFileModes sets the SetFileModes field's value.
func (s *CreateCommitInput) SetSetFileModes(v []*SetFileModeEntry) *CreateCommitInput {
	s.SetFileModes = v
	return s
}

type CreateCommitOutput struct {
	_ struct{} `type:"structure"`

	// The full commit ID of the commit that contains your committed file changes.
	CommitId *string `locationName:"commitId" type:"string"`

	// The files added as part of the committed file changes.
	FilesAdded []*FileMetadata `locationName:"filesAdded" type:"list"`

	// The files deleted as part of the committed file changes.
	FilesDeleted []*FileMetadata `locationName:"filesDeleted" type:"list"`

	// The files updated as part of the commited file changes.
	FilesUpdated []*FileMetadata `locationName:"filesUpdated" type:"list"`

	// The full SHA-1 pointer of the tree information for the commit that contains
	// the commited file changes.
	TreeId *string `locationName:"treeId" type:"string"`
}

// String returns the string representation
func (s CreateCommitOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateCommitOutput) GoString() string {
	return s.String()
}

// SetCommitId sets the CommitId field's value.
func (s *CreateCommitOutput) SetCommitId(v string) *CreateCommitOutput {
	s.CommitId = &v
	return s
}

// SetFilesAdded sets the FilesAdded field's value.
func (s *CreateCommitOutput) SetFilesAdded(v []*FileMetadata) *CreateCommitOutput {
	s.FilesAdded = v
	return s
}

// SetFilesDeleted sets the FilesDeleted field's value.
func (s *CreateCommitOutput) SetFilesDeleted(v []*FileMetadata) *CreateCommitOutput {
	s.FilesDeleted = v
	return s
}

// SetFilesUpdated sets the FilesUpdated field's value.
func (s *CreateCommitOutput) SetFilesUpdated(v []*FileMetadata) *CreateCommitOutput {
	s.FilesUpdated = v
	return s
}

// SetTreeId sets the TreeId field's value.
func (s *CreateCommitOutput) SetTreeId(v string) *CreateCommitOutput {
	s.TreeId = &v
	return s
}

type CreatePullRequestApprovalRuleInput struct {
	_ struct{} `type:"structure"`

	// The content of the approval rule, including the number of approvals needed
	// and the structure of an approval pool defined for approvals, if any. For
	// more information about approval pools, see the AWS CodeCommit User Guide.
	//
	// When you create the content of the approval rule, you can specify approvers
	// in an approval pool in one of two ways:
	//
	//    * CodeCommitApprovers: This option only requires an AWS account and a
	//    resource. It can be used for both IAM users and federated access users
	//    whose name matches the provided resource name. This is a very powerful
	//    option that offers a great deal of flexibility. For example, if you specify
	//    the AWS account 123456789012 and Mary_Major, all of the following would
	//    be counted as approvals coming from that user: An IAM user in the account
	//    (arn:aws:iam::123456789012:user/Mary_Major) A federated user identified
	//    in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
	//    This option does not recognize an active session of someone assuming the
	//    role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major)
	//    unless you include a wildcard (*Mary_Major).
	//
	//    * Fully qualified ARN: This option allows you to specify the fully qualified
	//    Amazon Resource Name (ARN) of the IAM user or role.
	//
	// For more information about IAM ARNs, wildcards, and formats, see IAM Identifiers
	// (https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html)
	// in the IAM User Guide.
	//
	// ApprovalRuleContent is a required field
	ApprovalRuleContent *string `locationName:"approvalRuleContent" min:"1" type:"string" required:"true"`

	// The name for the approval rule.
	//
	// ApprovalRuleName is a required field
	ApprovalRuleName *string `locationName:"approvalRuleName" min:"1" type:"string" required:"true"`

	// The system-generated ID of the pull request for which you want to create
	// the approval rule.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`
}

// String returns the string representation
func (s CreatePullRequestApprovalRuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePullRequestApprovalRuleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreatePullRequestApprovalRuleInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreatePullRequestApprovalRuleInput"}
	if s.ApprovalRuleContent == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleContent"))
	}
	if s.ApprovalRuleContent != nil && len(*s.ApprovalRuleContent) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleContent", 1))
	}
	if s.ApprovalRuleName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleName"))
	}
	if s.ApprovalRuleName != nil && len(*s.ApprovalRuleName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleName", 1))
	}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleContent sets the ApprovalRuleContent field's value.
func (s *CreatePullRequestApprovalRuleInput) SetApprovalRuleContent(v string) *CreatePullRequestApprovalRuleInput {
	s.ApprovalRuleContent = &v
	return s
}

// SetApprovalRuleName sets the ApprovalRuleName field's value.
func (s *CreatePullRequestApprovalRuleInput) SetApprovalRuleName(v string) *CreatePullRequestApprovalRuleInput {
	s.ApprovalRuleName = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *CreatePullRequestApprovalRuleInput) SetPullRequestId(v string) *CreatePullRequestApprovalRuleInput {
	s.PullRequestId = &v
	return s
}

type CreatePullRequestApprovalRuleOutput struct {
	_ struct{} `type:"structure"`

	// Information about the created approval rule.
	//
	// ApprovalRule is a required field
	ApprovalRule *ApprovalRule `locationName:"approvalRule" type:"structure" required:"true"`
}

// String returns the string representation
func (s CreatePullRequestApprovalRuleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePullRequestApprovalRuleOutput) GoString() string {
	return s.String()
}

// SetApprovalRule sets the ApprovalRule field's value.
func (s *CreatePullRequestApprovalRuleOutput) SetApprovalRule(v *ApprovalRule) *CreatePullRequestApprovalRuleOutput {
	s.ApprovalRule = v
	return s
}

type CreatePullRequestInput struct {
	_ struct{} `type:"structure"`

	// A unique, client-generated idempotency token that, when provided in a request,
	// ensures the request cannot be repeated with a changed parameter. If a request
	// is received with the same parameters and a token is included, the request
	// returns information about the initial request that used that token.
	//
	// The AWS SDKs prepopulate client request tokens. If you are using an AWS SDK,
	// an idempotency token is created for you.
	ClientRequestToken *string `locationName:"clientRequestToken" type:"string" idempotencyToken:"true"`

	// A description of the pull request.
	Description *string `locationName:"description" type:"string"`

	// The targets for the pull request, including the source of the code to be
	// reviewed (the source branch) and the destination where the creator of the
	// pull request intends the code to be merged after the pull request is closed
	// (the destination branch).
	//
	// Targets is a required field
	Targets []*Target `locationName:"targets" type:"list" required:"true"`

	// The title of the pull request. This title is used to identify the pull request
	// to other users in the repository.
	//
	// Title is a required field
	Title *string `locationName:"title" type:"string" required:"true"`
}

// String returns the string representation
func (s CreatePullRequestInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePullRequestInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreatePullRequestInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreatePullRequestInput"}
	if s.Targets == nil {
		invalidParams.Add(request.NewErrParamRequired("Targets"))
	}
	if s.Title == nil {
		invalidParams.Add(request.NewErrParamRequired("Title"))
	}
	if s.Targets != nil {
		for i, v := range s.Targets {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Targets", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetClientRequestToken sets the ClientRequestToken field's value.
func (s *CreatePullRequestInput) SetClientRequestToken(v string) *CreatePullRequestInput {
	s.ClientRequestToken = &v
	return s
}

// SetDescription sets the Description field's value.
func (s *CreatePullRequestInput) SetDescription(v string) *CreatePullRequestInput {
	s.Description = &v
	return s
}

// SetTargets sets the Targets field's value.
func (s *CreatePullRequestInput) SetTargets(v []*Target) *CreatePullRequestInput {
	s.Targets = v
	return s
}

// SetTitle sets the Title field's value.
func (s *CreatePullRequestInput) SetTitle(v string) *CreatePullRequestInput {
	s.Title = &v
	return s
}

type CreatePullRequestOutput struct {
	_ struct{} `type:"structure"`

	// Information about the newly created pull request.
	//
	// PullRequest is a required field
	PullRequest *PullRequest `locationName:"pullRequest" type:"structure" required:"true"`
}

// String returns the string representation
func (s CreatePullRequestOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreatePullRequestOutput) GoString() string {
	return s.String()
}

// SetPullRequest sets the PullRequest field's value.
func (s *CreatePullRequestOutput) SetPullRequest(v *PullRequest) *CreatePullRequestOutput {
	s.PullRequest = v
	return s
}

// Represents the input of a create repository operation.
type CreateRepositoryInput struct {
	_ struct{} `type:"structure"`

	// A comment or description about the new repository.
	//
	// The description field for a repository accepts all HTML characters and all
	// valid Unicode characters. Applications that do not HTML-encode the description
	// and display it in a webpage can expose users to potentially malicious code.
	// Make sure that you HTML-encode the description field in any application that
	// uses this API to display the repository description on a webpage.
	RepositoryDescription *string `locationName:"repositoryDescription" type:"string"`

	// The name of the new repository to be created.
	//
	// The repository name must be unique across the calling AWS account. Repository
	// names are limited to 100 alphanumeric, dash, and underscore characters, and
	// cannot include certain characters. For more information about the limits
	// on repository names, see Limits (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html)
	// in the AWS CodeCommit User Guide. The suffix .git is prohibited.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// One or more tag key-value pairs to use when tagging this repository.
	Tags map[string]*string `locationName:"tags" type:"map"`
}

// String returns the string representation
func (s CreateRepositoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateRepositoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateRepositoryInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateRepositoryInput"}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetRepositoryDescription sets the RepositoryDescription field's value.
func (s *CreateRepositoryInput) SetRepositoryDescription(v string) *CreateRepositoryInput {
	s.RepositoryDescription = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *CreateRepositoryInput) SetRepositoryName(v string) *CreateRepositoryInput {
	s.RepositoryName = &v
	return s
}

// SetTags sets the Tags field's value.
func (s *CreateRepositoryInput) SetTags(v map[string]*string) *CreateRepositoryInput {
	s.Tags = v
	return s
}

// Represents the output of a create repository operation.
type CreateRepositoryOutput struct {
	_ struct{} `type:"structure"`

	// Information about the newly created repository.
	RepositoryMetadata *RepositoryMetadata `locationName:"repositoryMetadata" type:"structure"`
}

// String returns the string representation
func (s CreateRepositoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateRepositoryOutput) GoString() string {
	return s.String()
}

// SetRepositoryMetadata sets the RepositoryMetadata field's value.
func (s *CreateRepositoryOutput) SetRepositoryMetadata(v *RepositoryMetadata) *CreateRepositoryOutput {
	s.RepositoryMetadata = v
	return s
}

type CreateUnreferencedMergeCommitInput struct {
	_ struct{} `type:"structure"`

	// The name of the author who created the unreferenced commit. This information
	// is used as both the author and committer for the commit.
	AuthorName *string `locationName:"authorName" type:"string"`

	// The commit message for the unreferenced commit.
	CommitMessage *string `locationName:"commitMessage" type:"string"`

	// The level of conflict detail to use. If unspecified, the default FILE_LEVEL
	// is used, which returns a not-mergeable result if the same file has differences
	// in both branches. If LINE_LEVEL is specified, a conflict is considered not
	// mergeable if the same file in both branches has differences on the same line.
	ConflictDetailLevel *string `locationName:"conflictDetailLevel" type:"string" enum:"ConflictDetailLevelTypeEnum"`

	// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use
	// when resolving conflicts during a merge.
	ConflictResolution *ConflictResolution `locationName:"conflictResolution" type:"structure"`

	// Specifies which branch to use when resolving conflicts, or whether to attempt
	// automatically merging two versions of a file. The default is NONE, which
	// requires any conflicts to be resolved manually before the merge operation
	// is successful.
	ConflictResolutionStrategy *string `locationName:"conflictResolutionStrategy" type:"string" enum:"ConflictResolutionStrategyTypeEnum"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// DestinationCommitSpecifier is a required field
	DestinationCommitSpecifier *string `locationName:"destinationCommitSpecifier" type:"string" required:"true"`

	// The email address for the person who created the unreferenced commit.
	Email *string `locationName:"email" type:"string"`

	// If the commit contains deletions, whether to keep a folder or folder structure
	// if the changes leave the folders empty. If this is specified as true, a .gitkeep
	// file is created for empty folders. The default is false.
	KeepEmptyFolders *bool `locationName:"keepEmptyFolders" type:"boolean"`

	// The merge option or strategy you want to use to merge the code.
	//
	// MergeOption is a required field
	MergeOption *string `locationName:"mergeOption" type:"string" required:"true" enum:"MergeOptionTypeEnum"`

	// The name of the repository where you want to create the unreferenced merge
	// commit.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// SourceCommitSpecifier is a required field
	SourceCommitSpecifier *string `locationName:"sourceCommitSpecifier" type:"string" required:"true"`
}

// String returns the string representation
func (s CreateUnreferencedMergeCommitInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateUnreferencedMergeCommitInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *CreateUnreferencedMergeCommitInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "CreateUnreferencedMergeCommitInput"}
	if s.DestinationCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("DestinationCommitSpecifier"))
	}
	if s.MergeOption == nil {
		invalidParams.Add(request.NewErrParamRequired("MergeOption"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.SourceCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("SourceCommitSpecifier"))
	}
	if s.ConflictResolution != nil {
		if err := s.ConflictResolution.Validate(); err != nil {
			invalidParams.AddNested("ConflictResolution", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAuthorName sets the AuthorName field's value.
func (s *CreateUnreferencedMergeCommitInput) SetAuthorName(v string) *CreateUnreferencedMergeCommitInput {
	s.AuthorName = &v
	return s
}

// SetCommitMessage sets the CommitMessage field's value.
func (s *CreateUnreferencedMergeCommitInput) SetCommitMessage(v string) *CreateUnreferencedMergeCommitInput {
	s.CommitMessage = &v
	return s
}

// SetConflictDetailLevel sets the ConflictDetailLevel field's value.
func (s *CreateUnreferencedMergeCommitInput) SetConflictDetailLevel(v string) *CreateUnreferencedMergeCommitInput {
	s.ConflictDetailLevel = &v
	return s
}

// SetConflictResolution sets the ConflictResolution field's value.
func (s *CreateUnreferencedMergeCommitInput) SetConflictResolution(v *ConflictResolution) *CreateUnreferencedMergeCommitInput {
	s.ConflictResolution = v
	return s
}

// SetConflictResolutionStrategy sets the ConflictResolutionStrategy field's value.
func (s *CreateUnreferencedMergeCommitInput) SetConflictResolutionStrategy(v string) *CreateUnreferencedMergeCommitInput {
	s.ConflictResolutionStrategy = &v
	return s
}

// SetDestinationCommitSpecifier sets the DestinationCommitSpecifier field's value.
func (s *CreateUnreferencedMergeCommitInput) SetDestinationCommitSpecifier(v string) *CreateUnreferencedMergeCommitInput {
	s.DestinationCommitSpecifier = &v
	return s
}

// SetEmail sets the Email field's value.
func (s *CreateUnreferencedMergeCommitInput) SetEmail(v string) *CreateUnreferencedMergeCommitInput {
	s.Email = &v
	return s
}

// SetKeepEmptyFolders sets the KeepEmptyFolders field's value.
func (s *CreateUnreferencedMergeCommitInput) SetKeepEmptyFolders(v bool) *CreateUnreferencedMergeCommitInput {
	s.KeepEmptyFolders = &v
	return s
}

// SetMergeOption sets the MergeOption field's value.
func (s *CreateUnreferencedMergeCommitInput) SetMergeOption(v string) *CreateUnreferencedMergeCommitInput {
	s.MergeOption = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *CreateUnreferencedMergeCommitInput) SetRepositoryName(v string) *CreateUnreferencedMergeCommitInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitSpecifier sets the SourceCommitSpecifier field's value.
func (s *CreateUnreferencedMergeCommitInput) SetSourceCommitSpecifier(v string) *CreateUnreferencedMergeCommitInput {
	s.SourceCommitSpecifier = &v
	return s
}

type CreateUnreferencedMergeCommitOutput struct {
	_ struct{} `type:"structure"`

	// The full commit ID of the commit that contains your merge results.
	CommitId *string `locationName:"commitId" type:"string"`

	// The full SHA-1 pointer of the tree information for the commit that contains
	// the merge results.
	TreeId *string `locationName:"treeId" type:"string"`
}

// String returns the string representation
func (s CreateUnreferencedMergeCommitOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s CreateUnreferencedMergeCommitOutput) GoString() string {
	return s.String()
}

// SetCommitId sets the CommitId field's value.
func (s *CreateUnreferencedMergeCommitOutput) SetCommitId(v string) *CreateUnreferencedMergeCommitOutput {
	s.CommitId = &v
	return s
}

// SetTreeId sets the TreeId field's value.
func (s *CreateUnreferencedMergeCommitOutput) SetTreeId(v string) *CreateUnreferencedMergeCommitOutput {
	s.TreeId = &v
	return s
}

// The specified branch is the default branch for the repository, and cannot
// be deleted. To delete this branch, you must first set another branch as the
// default branch.
type DefaultBranchCannotBeDeletedException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s DefaultBranchCannotBeDeletedException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DefaultBranchCannotBeDeletedException) GoString() string {
	return s.String()
}

func newErrorDefaultBranchCannotBeDeletedException(v protocol.ResponseMetadata) error {
	return &DefaultBranchCannotBeDeletedException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *DefaultBranchCannotBeDeletedException) Code() string {
	return "DefaultBranchCannotBeDeletedException"
}

// Message returns the exception's message.
func (s *DefaultBranchCannotBeDeletedException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *DefaultBranchCannotBeDeletedException) OrigErr() error {
	return nil
}

func (s *DefaultBranchCannotBeDeletedException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *DefaultBranchCannotBeDeletedException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *DefaultBranchCannotBeDeletedException) RequestID() string {
	return s.RespMetadata.RequestID
}

type DeleteApprovalRuleTemplateInput struct {
	_ struct{} `type:"structure"`

	// The name of the approval rule template to delete.
	//
	// ApprovalRuleTemplateName is a required field
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteApprovalRuleTemplateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteApprovalRuleTemplateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteApprovalRuleTemplateInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeleteApprovalRuleTemplateInput"}
	if s.ApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateName"))
	}
	if s.ApprovalRuleTemplateName != nil && len(*s.ApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleTemplateName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *DeleteApprovalRuleTemplateInput) SetApprovalRuleTemplateName(v string) *DeleteApprovalRuleTemplateInput {
	s.ApprovalRuleTemplateName = &v
	return s
}

type DeleteApprovalRuleTemplateOutput struct {
	_ struct{} `type:"structure"`

	// The system-generated ID of the deleted approval rule template. If the template
	// has been previously deleted, the only response is a 200 OK.
	//
	// ApprovalRuleTemplateId is a required field
	ApprovalRuleTemplateId *string `locationName:"approvalRuleTemplateId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteApprovalRuleTemplateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteApprovalRuleTemplateOutput) GoString() string {
	return s.String()
}

// SetApprovalRuleTemplateId sets the ApprovalRuleTemplateId field's value.
func (s *DeleteApprovalRuleTemplateOutput) SetApprovalRuleTemplateId(v string) *DeleteApprovalRuleTemplateOutput {
	s.ApprovalRuleTemplateId = &v
	return s
}

// Represents the input of a delete branch operation.
type DeleteBranchInput struct {
	_ struct{} `type:"structure"`

	// The name of the branch to delete.
	//
	// BranchName is a required field
	BranchName *string `locationName:"branchName" min:"1" type:"string" required:"true"`

	// The name of the repository that contains the branch to be deleted.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteBranchInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBranchInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteBranchInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeleteBranchInput"}
	if s.BranchName == nil {
		invalidParams.Add(request.NewErrParamRequired("BranchName"))
	}
	if s.BranchName != nil && len(*s.BranchName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("BranchName", 1))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetBranchName sets the BranchName field's value.
func (s *DeleteBranchInput) SetBranchName(v string) *DeleteBranchInput {
	s.BranchName = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *DeleteBranchInput) SetRepositoryName(v string) *DeleteBranchInput {
	s.RepositoryName = &v
	return s
}

// Represents the output of a delete branch operation.
type DeleteBranchOutput struct {
	_ struct{} `type:"structure"`

	// Information about the branch deleted by the operation, including the branch
	// name and the commit ID that was the tip of the branch.
	DeletedBranch *BranchInfo `locationName:"deletedBranch" type:"structure"`
}

// String returns the string representation
func (s DeleteBranchOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteBranchOutput) GoString() string {
	return s.String()
}

// SetDeletedBranch sets the DeletedBranch field's value.
func (s *DeleteBranchOutput) SetDeletedBranch(v *BranchInfo) *DeleteBranchOutput {
	s.DeletedBranch = v
	return s
}

type DeleteCommentContentInput struct {
	_ struct{} `type:"structure"`

	// The unique, system-generated ID of the comment. To get this ID, use GetCommentsForComparedCommit
	// or GetCommentsForPullRequest.
	//
	// CommentId is a required field
	CommentId *string `locationName:"commentId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteCommentContentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteCommentContentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteCommentContentInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeleteCommentContentInput"}
	if s.CommentId == nil {
		invalidParams.Add(request.NewErrParamRequired("CommentId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetCommentId sets the CommentId field's value.
func (s *DeleteCommentContentInput) SetCommentId(v string) *DeleteCommentContentInput {
	s.CommentId = &v
	return s
}

type DeleteCommentContentOutput struct {
	_ struct{} `type:"structure"`

	// Information about the comment you just deleted.
	Comment *Comment `locationName:"comment" type:"structure"`
}

// String returns the string representation
func (s DeleteCommentContentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteCommentContentOutput) GoString() string {
	return s.String()
}

// SetComment sets the Comment field's value.
func (s *DeleteCommentContentOutput) SetComment(v *Comment) *DeleteCommentContentOutput {
	s.Comment = v
	return s
}

// A file that is deleted as part of a commit.
type DeleteFileEntry struct {
	_ struct{} `type:"structure"`

	// The full path of the file to be deleted, including the name of the file.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteFileEntry) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFileEntry) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteFileEntry) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeleteFileEntry"}
	if s.FilePath == nil {
		invalidParams.Add(request.NewErrParamRequired("FilePath"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetFilePath sets the FilePath field's value.
func (s *DeleteFileEntry) SetFilePath(v string) *DeleteFileEntry {
	s.FilePath = &v
	return s
}

type DeleteFileInput struct {
	_ struct{} `type:"structure"`

	// The name of the branch where the commit that deletes the file is made.
	//
	// BranchName is a required field
	BranchName *string `locationName:"branchName" min:"1" type:"string" required:"true"`

	// The commit message you want to include as part of deleting the file. Commit
	// messages are limited to 256 KB. If no message is specified, a default message
	// is used.
	CommitMessage *string `locationName:"commitMessage" type:"string"`

	// The email address for the commit that deletes the file. If no email address
	// is specified, the email address is left blank.
	Email *string `locationName:"email" type:"string"`

	// The fully qualified path to the file that to be deleted, including the full
	// name and extension of that file. For example, /examples/file.md is a fully
	// qualified path to a file named file.md in a folder named examples.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`

	// If a file is the only object in the folder or directory, specifies whether
	// to delete the folder or directory that contains the file. By default, empty
	// folders are deleted. This includes empty folders that are part of the directory
	// structure. For example, if the path to a file is dir1/dir2/dir3/dir4, and
	// dir2 and dir3 are empty, deleting the last file in dir4 also deletes the
	// empty folders dir4, dir3, and dir2.
	KeepEmptyFolders *bool `locationName:"keepEmptyFolders" type:"boolean"`

	// The name of the author of the commit that deletes the file. If no name is
	// specified, the user's ARN is used as the author name and committer name.
	Name *string `locationName:"name" type:"string"`

	// The ID of the commit that is the tip of the branch where you want to create
	// the commit that deletes the file. This must be the HEAD commit for the branch.
	// The commit that deletes the file is created from this commit ID.
	//
	// ParentCommitId is a required field
	ParentCommitId *string `locationName:"parentCommitId" type:"string" required:"true"`

	// The name of the repository that contains the file to delete.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteFileInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFileInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteFileInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeleteFileInput"}
	if s.BranchName == nil {
		invalidParams.Add(request.NewErrParamRequired("BranchName"))
	}
	if s.BranchName != nil && len(*s.BranchName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("BranchName", 1))
	}
	if s.FilePath == nil {
		invalidParams.Add(request.NewErrParamRequired("FilePath"))
	}
	if s.ParentCommitId == nil {
		invalidParams.Add(request.NewErrParamRequired("ParentCommitId"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetBranchName sets the BranchName field's value.
func (s *DeleteFileInput) SetBranchName(v string) *DeleteFileInput {
	s.BranchName = &v
	return s
}

// SetCommitMessage sets the CommitMessage field's value.
func (s *DeleteFileInput) SetCommitMessage(v string) *DeleteFileInput {
	s.CommitMessage = &v
	return s
}

// SetEmail sets the Email field's value.
func (s *DeleteFileInput) SetEmail(v string) *DeleteFileInput {
	s.Email = &v
	return s
}

// SetFilePath sets the FilePath field's value.
func (s *DeleteFileInput) SetFilePath(v string) *DeleteFileInput {
	s.FilePath = &v
	return s
}

// SetKeepEmptyFolders sets the KeepEmptyFolders field's value.
func (s *DeleteFileInput) SetKeepEmptyFolders(v bool) *DeleteFileInput {
	s.KeepEmptyFolders = &v
	return s
}

// SetName sets the Name field's value.
func (s *DeleteFileInput) SetName(v string) *DeleteFileInput {
	s.Name = &v
	return s
}

// SetParentCommitId sets the ParentCommitId field's value.
func (s *DeleteFileInput) SetParentCommitId(v string) *DeleteFileInput {
	s.ParentCommitId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *DeleteFileInput) SetRepositoryName(v string) *DeleteFileInput {
	s.RepositoryName = &v
	return s
}

type DeleteFileOutput struct {
	_ struct{} `type:"structure"`

	// The blob ID removed from the tree as part of deleting the file.
	//
	// BlobId is a required field
	BlobId *string `locationName:"blobId" type:"string" required:"true"`

	// The full commit ID of the commit that contains the change that deletes the
	// file.
	//
	// CommitId is a required field
	CommitId *string `locationName:"commitId" type:"string" required:"true"`

	// The fully qualified path to the file to be deleted, including the full name
	// and extension of that file.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`

	// The full SHA-1 pointer of the tree information for the commit that contains
	// the delete file change.
	//
	// TreeId is a required field
	TreeId *string `locationName:"treeId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteFileOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteFileOutput) GoString() string {
	return s.String()
}

// SetBlobId sets the BlobId field's value.
func (s *DeleteFileOutput) SetBlobId(v string) *DeleteFileOutput {
	s.BlobId = &v
	return s
}

// SetCommitId sets the CommitId field's value.
func (s *DeleteFileOutput) SetCommitId(v string) *DeleteFileOutput {
	s.CommitId = &v
	return s
}

// SetFilePath sets the FilePath field's value.
func (s *DeleteFileOutput) SetFilePath(v string) *DeleteFileOutput {
	s.FilePath = &v
	return s
}

// SetTreeId sets the TreeId field's value.
func (s *DeleteFileOutput) SetTreeId(v string) *DeleteFileOutput {
	s.TreeId = &v
	return s
}

type DeletePullRequestApprovalRuleInput struct {
	_ struct{} `type:"structure"`

	// The name of the approval rule you want to delete.
	//
	// ApprovalRuleName is a required field
	ApprovalRuleName *string `locationName:"approvalRuleName" min:"1" type:"string" required:"true"`

	// The system-generated ID of the pull request that contains the approval rule
	// you want to delete.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeletePullRequestApprovalRuleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeletePullRequestApprovalRuleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeletePullRequestApprovalRuleInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeletePullRequestApprovalRuleInput"}
	if s.ApprovalRuleName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleName"))
	}
	if s.ApprovalRuleName != nil && len(*s.ApprovalRuleName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleName", 1))
	}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleName sets the ApprovalRuleName field's value.
func (s *DeletePullRequestApprovalRuleInput) SetApprovalRuleName(v string) *DeletePullRequestApprovalRuleInput {
	s.ApprovalRuleName = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *DeletePullRequestApprovalRuleInput) SetPullRequestId(v string) *DeletePullRequestApprovalRuleInput {
	s.PullRequestId = &v
	return s
}

type DeletePullRequestApprovalRuleOutput struct {
	_ struct{} `type:"structure"`

	// The ID of the deleted approval rule.
	//
	// If the approval rule was deleted in an earlier API call, the response is
	// 200 OK without content.
	//
	// ApprovalRuleId is a required field
	ApprovalRuleId *string `locationName:"approvalRuleId" type:"string" required:"true"`
}

// String returns the string representation
func (s DeletePullRequestApprovalRuleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeletePullRequestApprovalRuleOutput) GoString() string {
	return s.String()
}

// SetApprovalRuleId sets the ApprovalRuleId field's value.
func (s *DeletePullRequestApprovalRuleOutput) SetApprovalRuleId(v string) *DeletePullRequestApprovalRuleOutput {
	s.ApprovalRuleId = &v
	return s
}

// Represents the input of a delete repository operation.
type DeleteRepositoryInput struct {
	_ struct{} `type:"structure"`

	// The name of the repository to delete.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DeleteRepositoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRepositoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DeleteRepositoryInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DeleteRepositoryInput"}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *DeleteRepositoryInput) SetRepositoryName(v string) *DeleteRepositoryInput {
	s.RepositoryName = &v
	return s
}

// Represents the output of a delete repository operation.
type DeleteRepositoryOutput struct {
	_ struct{} `type:"structure"`

	// The ID of the repository that was deleted.
	RepositoryId *string `locationName:"repositoryId" type:"string"`
}

// String returns the string representation
func (s DeleteRepositoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DeleteRepositoryOutput) GoString() string {
	return s.String()
}

// SetRepositoryId sets the RepositoryId field's value.
func (s *DeleteRepositoryOutput) SetRepositoryId(v string) *DeleteRepositoryOutput {
	s.RepositoryId = &v
	return s
}

type DescribeMergeConflictsInput struct {
	_ struct{} `type:"structure"`

	// The level of conflict detail to use. If unspecified, the default FILE_LEVEL
	// is used, which returns a not-mergeable result if the same file has differences
	// in both branches. If LINE_LEVEL is specified, a conflict is considered not
	// mergeable if the same file in both branches has differences on the same line.
	ConflictDetailLevel *string `locationName:"conflictDetailLevel" type:"string" enum:"ConflictDetailLevelTypeEnum"`

	// Specifies which branch to use when resolving conflicts, or whether to attempt
	// automatically merging two versions of a file. The default is NONE, which
	// requires any conflicts to be resolved manually before the merge operation
	// is successful.
	ConflictResolutionStrategy *string `locationName:"conflictResolutionStrategy" type:"string" enum:"ConflictResolutionStrategyTypeEnum"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// DestinationCommitSpecifier is a required field
	DestinationCommitSpecifier *string `locationName:"destinationCommitSpecifier" type:"string" required:"true"`

	// The path of the target files used to describe the conflicts.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`

	// The maximum number of merge hunks to include in the output.
	MaxMergeHunks *int64 `locationName:"maxMergeHunks" type:"integer"`

	// The merge option or strategy you want to use to merge the code.
	//
	// MergeOption is a required field
	MergeOption *string `locationName:"mergeOption" type:"string" required:"true" enum:"MergeOptionTypeEnum"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The name of the repository where you want to get information about a merge
	// conflict.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// SourceCommitSpecifier is a required field
	SourceCommitSpecifier *string `locationName:"sourceCommitSpecifier" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeMergeConflictsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMergeConflictsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribeMergeConflictsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DescribeMergeConflictsInput"}
	if s.DestinationCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("DestinationCommitSpecifier"))
	}
	if s.FilePath == nil {
		invalidParams.Add(request.NewErrParamRequired("FilePath"))
	}
	if s.MergeOption == nil {
		invalidParams.Add(request.NewErrParamRequired("MergeOption"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.SourceCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("SourceCommitSpecifier"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetConflictDetailLevel sets the ConflictDetailLevel field's value.
func (s *DescribeMergeConflictsInput) SetConflictDetailLevel(v string) *DescribeMergeConflictsInput {
	s.ConflictDetailLevel = &v
	return s
}

// SetConflictResolutionStrategy sets the ConflictResolutionStrategy field's value.
func (s *DescribeMergeConflictsInput) SetConflictResolutionStrategy(v string) *DescribeMergeConflictsInput {
	s.ConflictResolutionStrategy = &v
	return s
}

// SetDestinationCommitSpecifier sets the DestinationCommitSpecifier field's value.
func (s *DescribeMergeConflictsInput) SetDestinationCommitSpecifier(v string) *DescribeMergeConflictsInput {
	s.DestinationCommitSpecifier = &v
	return s
}

// SetFilePath sets the FilePath field's value.
func (s *DescribeMergeConflictsInput) SetFilePath(v string) *DescribeMergeConflictsInput {
	s.FilePath = &v
	return s
}

// SetMaxMergeHunks sets the MaxMergeHunks field's value.
func (s *DescribeMergeConflictsInput) SetMaxMergeHunks(v int64) *DescribeMergeConflictsInput {
	s.MaxMergeHunks = &v
	return s
}

// SetMergeOption sets the MergeOption field's value.
func (s *DescribeMergeConflictsInput) SetMergeOption(v string) *DescribeMergeConflictsInput {
	s.MergeOption = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *DescribeMergeConflictsInput) SetNextToken(v string) *DescribeMergeConflictsInput {
	s.NextToken = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *DescribeMergeConflictsInput) SetRepositoryName(v string) *DescribeMergeConflictsInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitSpecifier sets the SourceCommitSpecifier field's value.
func (s *DescribeMergeConflictsInput) SetSourceCommitSpecifier(v string) *DescribeMergeConflictsInput {
	s.SourceCommitSpecifier = &v
	return s
}

type DescribeMergeConflictsOutput struct {
	_ struct{} `type:"structure"`

	// The commit ID of the merge base.
	BaseCommitId *string `locationName:"baseCommitId" type:"string"`

	// Contains metadata about the conflicts found in the merge.
	//
	// ConflictMetadata is a required field
	ConflictMetadata *ConflictMetadata `locationName:"conflictMetadata" type:"structure" required:"true"`

	// The commit ID of the destination commit specifier that was used in the merge
	// evaluation.
	//
	// DestinationCommitId is a required field
	DestinationCommitId *string `locationName:"destinationCommitId" type:"string" required:"true"`

	// A list of merge hunks of the differences between the files or lines.
	//
	// MergeHunks is a required field
	MergeHunks []*MergeHunk `locationName:"mergeHunks" type:"list" required:"true"`

	// An enumeration token that can be used in a request to return the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The commit ID of the source commit specifier that was used in the merge evaluation.
	//
	// SourceCommitId is a required field
	SourceCommitId *string `locationName:"sourceCommitId" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribeMergeConflictsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribeMergeConflictsOutput) GoString() string {
	return s.String()
}

// SetBaseCommitId sets the BaseCommitId field's value.
func (s *DescribeMergeConflictsOutput) SetBaseCommitId(v string) *DescribeMergeConflictsOutput {
	s.BaseCommitId = &v
	return s
}

// SetConflictMetadata sets the ConflictMetadata field's value.
func (s *DescribeMergeConflictsOutput) SetConflictMetadata(v *ConflictMetadata) *DescribeMergeConflictsOutput {
	s.ConflictMetadata = v
	return s
}

// SetDestinationCommitId sets the DestinationCommitId field's value.
func (s *DescribeMergeConflictsOutput) SetDestinationCommitId(v string) *DescribeMergeConflictsOutput {
	s.DestinationCommitId = &v
	return s
}

// SetMergeHunks sets the MergeHunks field's value.
func (s *DescribeMergeConflictsOutput) SetMergeHunks(v []*MergeHunk) *DescribeMergeConflictsOutput {
	s.MergeHunks = v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *DescribeMergeConflictsOutput) SetNextToken(v string) *DescribeMergeConflictsOutput {
	s.NextToken = &v
	return s
}

// SetSourceCommitId sets the SourceCommitId field's value.
func (s *DescribeMergeConflictsOutput) SetSourceCommitId(v string) *DescribeMergeConflictsOutput {
	s.SourceCommitId = &v
	return s
}

type DescribePullRequestEventsInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the user whose actions resulted in the
	// event. Examples include updating the pull request with more commits or changing
	// the status of a pull request.
	ActorArn *string `locationName:"actorArn" type:"string"`

	// A non-zero, non-negative integer used to limit the number of returned results.
	// The default is 100 events, which is also the maximum number of events that
	// can be returned in a result.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// Optional. The pull request event type about which you want to return information.
	PullRequestEventType *string `locationName:"pullRequestEventType" type:"string" enum:"PullRequestEventType"`

	// The system-generated ID of the pull request. To get this ID, use ListPullRequests.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`
}

// String returns the string representation
func (s DescribePullRequestEventsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribePullRequestEventsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DescribePullRequestEventsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DescribePullRequestEventsInput"}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetActorArn sets the ActorArn field's value.
func (s *DescribePullRequestEventsInput) SetActorArn(v string) *DescribePullRequestEventsInput {
	s.ActorArn = &v
	return s
}

// SetMaxResults sets the MaxResults field's value.
func (s *DescribePullRequestEventsInput) SetMaxResults(v int64) *DescribePullRequestEventsInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *DescribePullRequestEventsInput) SetNextToken(v string) *DescribePullRequestEventsInput {
	s.NextToken = &v
	return s
}

// SetPullRequestEventType sets the PullRequestEventType field's value.
func (s *DescribePullRequestEventsInput) SetPullRequestEventType(v string) *DescribePullRequestEventsInput {
	s.PullRequestEventType = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *DescribePullRequestEventsInput) SetPullRequestId(v string) *DescribePullRequestEventsInput {
	s.PullRequestId = &v
	return s
}

type DescribePullRequestEventsOutput struct {
	_ struct{} `type:"structure"`

	// An enumeration token that can be used in a request to return the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// Information about the pull request events.
	//
	// PullRequestEvents is a required field
	PullRequestEvents []*PullRequestEvent `locationName:"pullRequestEvents" type:"list" required:"true"`
}

// String returns the string representation
func (s DescribePullRequestEventsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DescribePullRequestEventsOutput) GoString() string {
	return s.String()
}

// SetNextToken sets the NextToken field's value.
func (s *DescribePullRequestEventsOutput) SetNextToken(v string) *DescribePullRequestEventsOutput {
	s.NextToken = &v
	return s
}

// SetPullRequestEvents sets the PullRequestEvents field's value.
func (s *DescribePullRequestEventsOutput) SetPullRequestEvents(v []*PullRequestEvent) *DescribePullRequestEventsOutput {
	s.PullRequestEvents = v
	return s
}

// Returns information about a set of differences for a commit specifier.
type Difference struct {
	_ struct{} `type:"structure"`

	// Information about an afterBlob data type object, including the ID, the file
	// mode permission code, and the path.
	AfterBlob *BlobMetadata `locationName:"afterBlob" type:"structure"`

	// Information about a beforeBlob data type object, including the ID, the file
	// mode permission code, and the path.
	BeforeBlob *BlobMetadata `locationName:"beforeBlob" type:"structure"`

	// Whether the change type of the difference is an addition (A), deletion (D),
	// or modification (M).
	ChangeType *string `locationName:"changeType" type:"string" enum:"ChangeTypeEnum"`
}

// String returns the string representation
func (s Difference) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Difference) GoString() string {
	return s.String()
}

// SetAfterBlob sets the AfterBlob field's value.
func (s *Difference) SetAfterBlob(v *BlobMetadata) *Difference {
	s.AfterBlob = v
	return s
}

// SetBeforeBlob sets the BeforeBlob field's value.
func (s *Difference) SetBeforeBlob(v *BlobMetadata) *Difference {
	s.BeforeBlob = v
	return s
}

// SetChangeType sets the ChangeType field's value.
func (s *Difference) SetChangeType(v string) *Difference {
	s.ChangeType = &v
	return s
}

// A file cannot be added to the repository because the specified path name
// has the same name as a file that already exists in this repository. Either
// provide a different name for the file, or specify a different path for the
// file.
type DirectoryNameConflictsWithFileNameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s DirectoryNameConflictsWithFileNameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DirectoryNameConflictsWithFileNameException) GoString() string {
	return s.String()
}

func newErrorDirectoryNameConflictsWithFileNameException(v protocol.ResponseMetadata) error {
	return &DirectoryNameConflictsWithFileNameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *DirectoryNameConflictsWithFileNameException) Code() string {
	return "DirectoryNameConflictsWithFileNameException"
}

// Message returns the exception's message.
func (s *DirectoryNameConflictsWithFileNameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *DirectoryNameConflictsWithFileNameException) OrigErr() error {
	return nil
}

func (s *DirectoryNameConflictsWithFileNameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *DirectoryNameConflictsWithFileNameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *DirectoryNameConflictsWithFileNameException) RequestID() string {
	return s.RespMetadata.RequestID
}

type DisassociateApprovalRuleTemplateFromRepositoryInput struct {
	_ struct{} `type:"structure"`

	// The name of the approval rule template to disassociate from a specified repository.
	//
	// ApprovalRuleTemplateName is a required field
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string" required:"true"`

	// The name of the repository you want to disassociate from the template.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s DisassociateApprovalRuleTemplateFromRepositoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DisassociateApprovalRuleTemplateFromRepositoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *DisassociateApprovalRuleTemplateFromRepositoryInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "DisassociateApprovalRuleTemplateFromRepositoryInput"}
	if s.ApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateName"))
	}
	if s.ApprovalRuleTemplateName != nil && len(*s.ApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleTemplateName", 1))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *DisassociateApprovalRuleTemplateFromRepositoryInput) SetApprovalRuleTemplateName(v string) *DisassociateApprovalRuleTemplateFromRepositoryInput {
	s.ApprovalRuleTemplateName = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *DisassociateApprovalRuleTemplateFromRepositoryInput) SetRepositoryName(v string) *DisassociateApprovalRuleTemplateFromRepositoryInput {
	s.RepositoryName = &v
	return s
}

type DisassociateApprovalRuleTemplateFromRepositoryOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s DisassociateApprovalRuleTemplateFromRepositoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s DisassociateApprovalRuleTemplateFromRepositoryOutput) GoString() string {
	return s.String()
}

// An encryption integrity check failed.
type EncryptionIntegrityChecksFailedException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s EncryptionIntegrityChecksFailedException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EncryptionIntegrityChecksFailedException) GoString() string {
	return s.String()
}

func newErrorEncryptionIntegrityChecksFailedException(v protocol.ResponseMetadata) error {
	return &EncryptionIntegrityChecksFailedException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *EncryptionIntegrityChecksFailedException) Code() string {
	return "EncryptionIntegrityChecksFailedException"
}

// Message returns the exception's message.
func (s *EncryptionIntegrityChecksFailedException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *EncryptionIntegrityChecksFailedException) OrigErr() error {
	return nil
}

func (s *EncryptionIntegrityChecksFailedException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *EncryptionIntegrityChecksFailedException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *EncryptionIntegrityChecksFailedException) RequestID() string {
	return s.RespMetadata.RequestID
}

// An encryption key could not be accessed.
type EncryptionKeyAccessDeniedException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s EncryptionKeyAccessDeniedException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EncryptionKeyAccessDeniedException) GoString() string {
	return s.String()
}

func newErrorEncryptionKeyAccessDeniedException(v protocol.ResponseMetadata) error {
	return &EncryptionKeyAccessDeniedException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *EncryptionKeyAccessDeniedException) Code() string {
	return "EncryptionKeyAccessDeniedException"
}

// Message returns the exception's message.
func (s *EncryptionKeyAccessDeniedException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *EncryptionKeyAccessDeniedException) OrigErr() error {
	return nil
}

func (s *EncryptionKeyAccessDeniedException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *EncryptionKeyAccessDeniedException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *EncryptionKeyAccessDeniedException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The encryption key is disabled.
type EncryptionKeyDisabledException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s EncryptionKeyDisabledException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EncryptionKeyDisabledException) GoString() string {
	return s.String()
}

func newErrorEncryptionKeyDisabledException(v protocol.ResponseMetadata) error {
	return &EncryptionKeyDisabledException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *EncryptionKeyDisabledException) Code() string {
	return "EncryptionKeyDisabledException"
}

// Message returns the exception's message.
func (s *EncryptionKeyDisabledException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *EncryptionKeyDisabledException) OrigErr() error {
	return nil
}

func (s *EncryptionKeyDisabledException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *EncryptionKeyDisabledException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *EncryptionKeyDisabledException) RequestID() string {
	return s.RespMetadata.RequestID
}

// No encryption key was found.
type EncryptionKeyNotFoundException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s EncryptionKeyNotFoundException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EncryptionKeyNotFoundException) GoString() string {
	return s.String()
}

func newErrorEncryptionKeyNotFoundException(v protocol.ResponseMetadata) error {
	return &EncryptionKeyNotFoundException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *EncryptionKeyNotFoundException) Code() string {
	return "EncryptionKeyNotFoundException"
}

// Message returns the exception's message.
func (s *EncryptionKeyNotFoundException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *EncryptionKeyNotFoundException) OrigErr() error {
	return nil
}

func (s *EncryptionKeyNotFoundException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *EncryptionKeyNotFoundException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *EncryptionKeyNotFoundException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The encryption key is not available.
type EncryptionKeyUnavailableException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s EncryptionKeyUnavailableException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EncryptionKeyUnavailableException) GoString() string {
	return s.String()
}

func newErrorEncryptionKeyUnavailableException(v protocol.ResponseMetadata) error {
	return &EncryptionKeyUnavailableException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *EncryptionKeyUnavailableException) Code() string {
	return "EncryptionKeyUnavailableException"
}

// Message returns the exception's message.
func (s *EncryptionKeyUnavailableException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *EncryptionKeyUnavailableException) OrigErr() error {
	return nil
}

func (s *EncryptionKeyUnavailableException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *EncryptionKeyUnavailableException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *EncryptionKeyUnavailableException) RequestID() string {
	return s.RespMetadata.RequestID
}

type EvaluatePullRequestApprovalRulesInput struct {
	_ struct{} `type:"structure"`

	// The system-generated ID of the pull request you want to evaluate.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The system-generated ID for the pull request revision. To retrieve the most
	// recent revision ID for a pull request, use GetPullRequest.
	//
	// RevisionId is a required field
	RevisionId *string `locationName:"revisionId" type:"string" required:"true"`
}

// String returns the string representation
func (s EvaluatePullRequestApprovalRulesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EvaluatePullRequestApprovalRulesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *EvaluatePullRequestApprovalRulesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "EvaluatePullRequestApprovalRulesInput"}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.RevisionId == nil {
		invalidParams.Add(request.NewErrParamRequired("RevisionId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *EvaluatePullRequestApprovalRulesInput) SetPullRequestId(v string) *EvaluatePullRequestApprovalRulesInput {
	s.PullRequestId = &v
	return s
}

// SetRevisionId sets the RevisionId field's value.
func (s *EvaluatePullRequestApprovalRulesInput) SetRevisionId(v string) *EvaluatePullRequestApprovalRulesInput {
	s.RevisionId = &v
	return s
}

type EvaluatePullRequestApprovalRulesOutput struct {
	_ struct{} `type:"structure"`

	// The result of the evaluation, including the names of the rules whose conditions
	// have been met (if any), the names of the rules whose conditions have not
	// been met (if any), whether the pull request is in the approved state, and
	// whether the pull request approval rule has been set aside by an override.
	//
	// Evaluation is a required field
	Evaluation *Evaluation `locationName:"evaluation" type:"structure" required:"true"`
}

// String returns the string representation
func (s EvaluatePullRequestApprovalRulesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s EvaluatePullRequestApprovalRulesOutput) GoString() string {
	return s.String()
}

// SetEvaluation sets the Evaluation field's value.
func (s *EvaluatePullRequestApprovalRulesOutput) SetEvaluation(v *Evaluation) *EvaluatePullRequestApprovalRulesOutput {
	s.Evaluation = v
	return s
}

// Returns information about the approval rules applied to a pull request and
// whether conditions have been met.
type Evaluation struct {
	_ struct{} `type:"structure"`

	// The names of the approval rules that have not had their conditions met.
	ApprovalRulesNotSatisfied []*string `locationName:"approvalRulesNotSatisfied" type:"list"`

	// The names of the approval rules that have had their conditions met.
	ApprovalRulesSatisfied []*string `locationName:"approvalRulesSatisfied" type:"list"`

	// Whether the state of the pull request is approved.
	Approved *bool `locationName:"approved" type:"boolean"`

	// Whether the approval rule requirements for the pull request have been overridden
	// and no longer need to be met.
	Overridden *bool `locationName:"overridden" type:"boolean"`
}

// String returns the string representation
func (s Evaluation) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Evaluation) GoString() string {
	return s.String()
}

// SetApprovalRulesNotSatisfied sets the ApprovalRulesNotSatisfied field's value.
func (s *Evaluation) SetApprovalRulesNotSatisfied(v []*string) *Evaluation {
	s.ApprovalRulesNotSatisfied = v
	return s
}

// SetApprovalRulesSatisfied sets the ApprovalRulesSatisfied field's value.
func (s *Evaluation) SetApprovalRulesSatisfied(v []*string) *Evaluation {
	s.ApprovalRulesSatisfied = v
	return s
}

// SetApproved sets the Approved field's value.
func (s *Evaluation) SetApproved(v bool) *Evaluation {
	s.Approved = &v
	return s
}

// SetOverridden sets the Overridden field's value.
func (s *Evaluation) SetOverridden(v bool) *Evaluation {
	s.Overridden = &v
	return s
}

// Returns information about a file in a repository.
type File struct {
	_ struct{} `type:"structure"`

	// The fully qualified path to the file in the repository.
	AbsolutePath *string `locationName:"absolutePath" type:"string"`

	// The blob ID that contains the file information.
	BlobId *string `locationName:"blobId" type:"string"`

	// The extrapolated file mode permissions for the file. Valid values include
	// EXECUTABLE and NORMAL.
	FileMode *string `locationName:"fileMode" type:"string" enum:"FileModeTypeEnum"`

	// The relative path of the file from the folder where the query originated.
	RelativePath *string `locationName:"relativePath" type:"string"`
}

// String returns the string representation
func (s File) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s File) GoString() string {
	return s.String()
}

// SetAbsolutePath sets the AbsolutePath field's value.
func (s *File) SetAbsolutePath(v string) *File {
	s.AbsolutePath = &v
	return s
}

// SetBlobId sets the BlobId field's value.
func (s *File) SetBlobId(v string) *File {
	s.BlobId = &v
	return s
}

// SetFileMode sets the FileMode field's value.
func (s *File) SetFileMode(v string) *File {
	s.FileMode = &v
	return s
}

// SetRelativePath sets the RelativePath field's value.
func (s *File) SetRelativePath(v string) *File {
	s.RelativePath = &v
	return s
}

// The commit cannot be created because both a source file and file content
// have been specified for the same file. You cannot provide both. Either specify
// a source file or provide the file content directly.
type FileContentAndSourceFileSpecifiedException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s FileContentAndSourceFileSpecifiedException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileContentAndSourceFileSpecifiedException) GoString() string {
	return s.String()
}

func newErrorFileContentAndSourceFileSpecifiedException(v protocol.ResponseMetadata) error {
	return &FileContentAndSourceFileSpecifiedException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *FileContentAndSourceFileSpecifiedException) Code() string {
	return "FileContentAndSourceFileSpecifiedException"
}

// Message returns the exception's message.
func (s *FileContentAndSourceFileSpecifiedException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *FileContentAndSourceFileSpecifiedException) OrigErr() error {
	return nil
}

func (s *FileContentAndSourceFileSpecifiedException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *FileContentAndSourceFileSpecifiedException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *FileContentAndSourceFileSpecifiedException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The file cannot be added because it is empty. Empty files cannot be added
// to the repository with this API.
type FileContentRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s FileContentRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileContentRequiredException) GoString() string {
	return s.String()
}

func newErrorFileContentRequiredException(v protocol.ResponseMetadata) error {
	return &FileContentRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *FileContentRequiredException) Code() string {
	return "FileContentRequiredException"
}

// Message returns the exception's message.
func (s *FileContentRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *FileContentRequiredException) OrigErr() error {
	return nil
}

func (s *FileContentRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *FileContentRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *FileContentRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The file cannot be added because it is too large. The maximum file size is
// 6 MB, and the combined file content change size is 7 MB. Consider making
// these changes using a Git client.
type FileContentSizeLimitExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s FileContentSizeLimitExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileContentSizeLimitExceededException) GoString() string {
	return s.String()
}

func newErrorFileContentSizeLimitExceededException(v protocol.ResponseMetadata) error {
	return &FileContentSizeLimitExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *FileContentSizeLimitExceededException) Code() string {
	return "FileContentSizeLimitExceededException"
}

// Message returns the exception's message.
func (s *FileContentSizeLimitExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *FileContentSizeLimitExceededException) OrigErr() error {
	return nil
}

func (s *FileContentSizeLimitExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *FileContentSizeLimitExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *FileContentSizeLimitExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified file does not exist. Verify that you have used the correct
// file name, full path, and extension.
type FileDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s FileDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorFileDoesNotExistException(v protocol.ResponseMetadata) error {
	return &FileDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *FileDoesNotExistException) Code() string {
	return "FileDoesNotExistException"
}

// Message returns the exception's message.
func (s *FileDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *FileDoesNotExistException) OrigErr() error {
	return nil
}

func (s *FileDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *FileDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *FileDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The commit cannot be created because no files have been specified as added,
// updated, or changed (PutFile or DeleteFile) for the commit.
type FileEntryRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s FileEntryRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileEntryRequiredException) GoString() string {
	return s.String()
}

func newErrorFileEntryRequiredException(v protocol.ResponseMetadata) error {
	return &FileEntryRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *FileEntryRequiredException) Code() string {
	return "FileEntryRequiredException"
}

// Message returns the exception's message.
func (s *FileEntryRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *FileEntryRequiredException) OrigErr() error {
	return nil
}

func (s *FileEntryRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *FileEntryRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *FileEntryRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A file to be added, updated, or deleted as part of a commit.
type FileMetadata struct {
	_ struct{} `type:"structure"`

	// The full path to the file to be added or updated, including the name of the
	// file.
	AbsolutePath *string `locationName:"absolutePath" type:"string"`

	// The blob ID that contains the file information.
	BlobId *string `locationName:"blobId" type:"string"`

	// The extrapolated file mode permissions for the file. Valid values include
	// EXECUTABLE and NORMAL.
	FileMode *string `locationName:"fileMode" type:"string" enum:"FileModeTypeEnum"`
}

// String returns the string representation
func (s FileMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileMetadata) GoString() string {
	return s.String()
}

// SetAbsolutePath sets the AbsolutePath field's value.
func (s *FileMetadata) SetAbsolutePath(v string) *FileMetadata {
	s.AbsolutePath = &v
	return s
}

// SetBlobId sets the BlobId field's value.
func (s *FileMetadata) SetBlobId(v string) *FileMetadata {
	s.BlobId = &v
	return s
}

// SetFileMode sets the FileMode field's value.
func (s *FileMetadata) SetFileMode(v string) *FileMetadata {
	s.FileMode = &v
	return s
}

// The commit cannot be created because no file mode has been specified. A file
// mode is required to update mode permissions for a file.
type FileModeRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s FileModeRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileModeRequiredException) GoString() string {
	return s.String()
}

func newErrorFileModeRequiredException(v protocol.ResponseMetadata) error {
	return &FileModeRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *FileModeRequiredException) Code() string {
	return "FileModeRequiredException"
}

// Message returns the exception's message.
func (s *FileModeRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *FileModeRequiredException) OrigErr() error {
	return nil
}

func (s *FileModeRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *FileModeRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *FileModeRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about file modes in a merge or pull request.
type FileModes struct {
	_ struct{} `type:"structure"`

	// The file mode of a file in the base of a merge or pull request.
	Base *string `locationName:"base" type:"string" enum:"FileModeTypeEnum"`

	// The file mode of a file in the destination of a merge or pull request.
	Destination *string `locationName:"destination" type:"string" enum:"FileModeTypeEnum"`

	// The file mode of a file in the source of a merge or pull request.
	Source *string `locationName:"source" type:"string" enum:"FileModeTypeEnum"`
}

// String returns the string representation
func (s FileModes) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileModes) GoString() string {
	return s.String()
}

// SetBase sets the Base field's value.
func (s *FileModes) SetBase(v string) *FileModes {
	s.Base = &v
	return s
}

// SetDestination sets the Destination field's value.
func (s *FileModes) SetDestination(v string) *FileModes {
	s.Destination = &v
	return s
}

// SetSource sets the Source field's value.
func (s *FileModes) SetSource(v string) *FileModes {
	s.Source = &v
	return s
}

// A file cannot be added to the repository because the specified file name
// has the same name as a directory in this repository. Either provide another
// name for the file, or add the file in a directory that does not match the
// file name.
type FileNameConflictsWithDirectoryNameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s FileNameConflictsWithDirectoryNameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileNameConflictsWithDirectoryNameException) GoString() string {
	return s.String()
}

func newErrorFileNameConflictsWithDirectoryNameException(v protocol.ResponseMetadata) error {
	return &FileNameConflictsWithDirectoryNameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *FileNameConflictsWithDirectoryNameException) Code() string {
	return "FileNameConflictsWithDirectoryNameException"
}

// Message returns the exception's message.
func (s *FileNameConflictsWithDirectoryNameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *FileNameConflictsWithDirectoryNameException) OrigErr() error {
	return nil
}

func (s *FileNameConflictsWithDirectoryNameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *FileNameConflictsWithDirectoryNameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *FileNameConflictsWithDirectoryNameException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The commit cannot be created because a specified file path points to a submodule.
// Verify that the destination files have valid file paths that do not point
// to a submodule.
type FilePathConflictsWithSubmodulePathException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s FilePathConflictsWithSubmodulePathException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FilePathConflictsWithSubmodulePathException) GoString() string {
	return s.String()
}

func newErrorFilePathConflictsWithSubmodulePathException(v protocol.ResponseMetadata) error {
	return &FilePathConflictsWithSubmodulePathException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *FilePathConflictsWithSubmodulePathException) Code() string {
	return "FilePathConflictsWithSubmodulePathException"
}

// Message returns the exception's message.
func (s *FilePathConflictsWithSubmodulePathException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *FilePathConflictsWithSubmodulePathException) OrigErr() error {
	return nil
}

func (s *FilePathConflictsWithSubmodulePathException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *FilePathConflictsWithSubmodulePathException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *FilePathConflictsWithSubmodulePathException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about the size of files in a merge or pull request.
type FileSizes struct {
	_ struct{} `type:"structure"`

	// The size of a file in the base of a merge or pull request.
	Base *int64 `locationName:"base" type:"long"`

	// The size of a file in the destination of a merge or pull request.
	Destination *int64 `locationName:"destination" type:"long"`

	// The size of a file in the source of a merge or pull request.
	Source *int64 `locationName:"source" type:"long"`
}

// String returns the string representation
func (s FileSizes) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileSizes) GoString() string {
	return s.String()
}

// SetBase sets the Base field's value.
func (s *FileSizes) SetBase(v int64) *FileSizes {
	s.Base = &v
	return s
}

// SetDestination sets the Destination field's value.
func (s *FileSizes) SetDestination(v int64) *FileSizes {
	s.Destination = &v
	return s
}

// SetSource sets the Source field's value.
func (s *FileSizes) SetSource(v int64) *FileSizes {
	s.Source = &v
	return s
}

// The specified file exceeds the file size limit for AWS CodeCommit. For more
// information about limits in AWS CodeCommit, see AWS CodeCommit User Guide
// (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
type FileTooLargeException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s FileTooLargeException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FileTooLargeException) GoString() string {
	return s.String()
}

func newErrorFileTooLargeException(v protocol.ResponseMetadata) error {
	return &FileTooLargeException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *FileTooLargeException) Code() string {
	return "FileTooLargeException"
}

// Message returns the exception's message.
func (s *FileTooLargeException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *FileTooLargeException) OrigErr() error {
	return nil
}

func (s *FileTooLargeException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *FileTooLargeException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *FileTooLargeException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about a folder in a repository.
type Folder struct {
	_ struct{} `type:"structure"`

	// The fully qualified path of the folder in the repository.
	AbsolutePath *string `locationName:"absolutePath" type:"string"`

	// The relative path of the specified folder from the folder where the query
	// originated.
	RelativePath *string `locationName:"relativePath" type:"string"`

	// The full SHA-1 pointer of the tree information for the commit that contains
	// the folder.
	TreeId *string `locationName:"treeId" type:"string"`
}

// String returns the string representation
func (s Folder) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Folder) GoString() string {
	return s.String()
}

// SetAbsolutePath sets the AbsolutePath field's value.
func (s *Folder) SetAbsolutePath(v string) *Folder {
	s.AbsolutePath = &v
	return s
}

// SetRelativePath sets the RelativePath field's value.
func (s *Folder) SetRelativePath(v string) *Folder {
	s.RelativePath = &v
	return s
}

// SetTreeId sets the TreeId field's value.
func (s *Folder) SetTreeId(v string) *Folder {
	s.TreeId = &v
	return s
}

// The commit cannot be created because at least one of the overall changes
// in the commit results in a folder whose contents exceed the limit of 6 MB.
// Either reduce the number and size of your changes, or split the changes across
// multiple folders.
type FolderContentSizeLimitExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s FolderContentSizeLimitExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FolderContentSizeLimitExceededException) GoString() string {
	return s.String()
}

func newErrorFolderContentSizeLimitExceededException(v protocol.ResponseMetadata) error {
	return &FolderContentSizeLimitExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *FolderContentSizeLimitExceededException) Code() string {
	return "FolderContentSizeLimitExceededException"
}

// Message returns the exception's message.
func (s *FolderContentSizeLimitExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *FolderContentSizeLimitExceededException) OrigErr() error {
	return nil
}

func (s *FolderContentSizeLimitExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *FolderContentSizeLimitExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *FolderContentSizeLimitExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified folder does not exist. Either the folder name is not correct,
// or you did not enter the full path to the folder.
type FolderDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s FolderDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s FolderDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorFolderDoesNotExistException(v protocol.ResponseMetadata) error {
	return &FolderDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *FolderDoesNotExistException) Code() string {
	return "FolderDoesNotExistException"
}

// Message returns the exception's message.
func (s *FolderDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *FolderDoesNotExistException) OrigErr() error {
	return nil
}

func (s *FolderDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *FolderDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *FolderDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

type GetApprovalRuleTemplateInput struct {
	_ struct{} `type:"structure"`

	// The name of the approval rule template for which you want to get information.
	//
	// ApprovalRuleTemplateName is a required field
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetApprovalRuleTemplateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetApprovalRuleTemplateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetApprovalRuleTemplateInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetApprovalRuleTemplateInput"}
	if s.ApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateName"))
	}
	if s.ApprovalRuleTemplateName != nil && len(*s.ApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleTemplateName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *GetApprovalRuleTemplateInput) SetApprovalRuleTemplateName(v string) *GetApprovalRuleTemplateInput {
	s.ApprovalRuleTemplateName = &v
	return s
}

type GetApprovalRuleTemplateOutput struct {
	_ struct{} `type:"structure"`

	// The content and structure of the approval rule template.
	//
	// ApprovalRuleTemplate is a required field
	ApprovalRuleTemplate *ApprovalRuleTemplate `locationName:"approvalRuleTemplate" type:"structure" required:"true"`
}

// String returns the string representation
func (s GetApprovalRuleTemplateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetApprovalRuleTemplateOutput) GoString() string {
	return s.String()
}

// SetApprovalRuleTemplate sets the ApprovalRuleTemplate field's value.
func (s *GetApprovalRuleTemplateOutput) SetApprovalRuleTemplate(v *ApprovalRuleTemplate) *GetApprovalRuleTemplateOutput {
	s.ApprovalRuleTemplate = v
	return s
}

// Represents the input of a get blob operation.
type GetBlobInput struct {
	_ struct{} `type:"structure"`

	// The ID of the blob, which is its SHA-1 pointer.
	//
	// BlobId is a required field
	BlobId *string `locationName:"blobId" type:"string" required:"true"`

	// The name of the repository that contains the blob.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetBlobInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBlobInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBlobInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetBlobInput"}
	if s.BlobId == nil {
		invalidParams.Add(request.NewErrParamRequired("BlobId"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetBlobId sets the BlobId field's value.
func (s *GetBlobInput) SetBlobId(v string) *GetBlobInput {
	s.BlobId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetBlobInput) SetRepositoryName(v string) *GetBlobInput {
	s.RepositoryName = &v
	return s
}

// Represents the output of a get blob operation.
type GetBlobOutput struct {
	_ struct{} `type:"structure"`

	// The content of the blob, usually a file.
	//
	// Content is automatically base64 encoded/decoded by the SDK.
	//
	// Content is a required field
	Content []byte `locationName:"content" type:"blob" required:"true"`
}

// String returns the string representation
func (s GetBlobOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBlobOutput) GoString() string {
	return s.String()
}

// SetContent sets the Content field's value.
func (s *GetBlobOutput) SetContent(v []byte) *GetBlobOutput {
	s.Content = v
	return s
}

// Represents the input of a get branch operation.
type GetBranchInput struct {
	_ struct{} `type:"structure"`

	// The name of the branch for which you want to retrieve information.
	BranchName *string `locationName:"branchName" min:"1" type:"string"`

	// The name of the repository that contains the branch for which you want to
	// retrieve information.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s GetBranchInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBranchInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetBranchInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetBranchInput"}
	if s.BranchName != nil && len(*s.BranchName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("BranchName", 1))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetBranchName sets the BranchName field's value.
func (s *GetBranchInput) SetBranchName(v string) *GetBranchInput {
	s.BranchName = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetBranchInput) SetRepositoryName(v string) *GetBranchInput {
	s.RepositoryName = &v
	return s
}

// Represents the output of a get branch operation.
type GetBranchOutput struct {
	_ struct{} `type:"structure"`

	// The name of the branch.
	Branch *BranchInfo `locationName:"branch" type:"structure"`
}

// String returns the string representation
func (s GetBranchOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetBranchOutput) GoString() string {
	return s.String()
}

// SetBranch sets the Branch field's value.
func (s *GetBranchOutput) SetBranch(v *BranchInfo) *GetBranchOutput {
	s.Branch = v
	return s
}

type GetCommentInput struct {
	_ struct{} `type:"structure"`

	// The unique, system-generated ID of the comment. To get this ID, use GetCommentsForComparedCommit
	// or GetCommentsForPullRequest.
	//
	// CommentId is a required field
	CommentId *string `locationName:"commentId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetCommentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCommentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetCommentInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetCommentInput"}
	if s.CommentId == nil {
		invalidParams.Add(request.NewErrParamRequired("CommentId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetCommentId sets the CommentId field's value.
func (s *GetCommentInput) SetCommentId(v string) *GetCommentInput {
	s.CommentId = &v
	return s
}

type GetCommentOutput struct {
	_ struct{} `type:"structure"`

	// The contents of the comment.
	Comment *Comment `locationName:"comment" type:"structure"`
}

// String returns the string representation
func (s GetCommentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCommentOutput) GoString() string {
	return s.String()
}

// SetComment sets the Comment field's value.
func (s *GetCommentOutput) SetComment(v *Comment) *GetCommentOutput {
	s.Comment = v
	return s
}

type GetCommentReactionsInput struct {
	_ struct{} `type:"structure"`

	// The ID of the comment for which you want to get reactions information.
	//
	// CommentId is a required field
	CommentId *string `locationName:"commentId" type:"string" required:"true"`

	// A non-zero, non-negative integer used to limit the number of returned results.
	// The default is the same as the allowed maximum, 1,000.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// Optional. The Amazon Resource Name (ARN) of the user or identity for which
	// you want to get reaction information.
	ReactionUserArn *string `locationName:"reactionUserArn" type:"string"`
}

// String returns the string representation
func (s GetCommentReactionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCommentReactionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetCommentReactionsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetCommentReactionsInput"}
	if s.CommentId == nil {
		invalidParams.Add(request.NewErrParamRequired("CommentId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetCommentId sets the CommentId field's value.
func (s *GetCommentReactionsInput) SetCommentId(v string) *GetCommentReactionsInput {
	s.CommentId = &v
	return s
}

// SetMaxResults sets the MaxResults field's value.
func (s *GetCommentReactionsInput) SetMaxResults(v int64) *GetCommentReactionsInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *GetCommentReactionsInput) SetNextToken(v string) *GetCommentReactionsInput {
	s.NextToken = &v
	return s
}

// SetReactionUserArn sets the ReactionUserArn field's value.
func (s *GetCommentReactionsInput) SetReactionUserArn(v string) *GetCommentReactionsInput {
	s.ReactionUserArn = &v
	return s
}

type GetCommentReactionsOutput struct {
	_ struct{} `type:"structure"`

	// An enumeration token that can be used in a request to return the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// An array of reactions to the specified comment.
	//
	// ReactionsForComment is a required field
	ReactionsForComment []*ReactionForComment `locationName:"reactionsForComment" type:"list" required:"true"`
}

// String returns the string representation
func (s GetCommentReactionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCommentReactionsOutput) GoString() string {
	return s.String()
}

// SetNextToken sets the NextToken field's value.
func (s *GetCommentReactionsOutput) SetNextToken(v string) *GetCommentReactionsOutput {
	s.NextToken = &v
	return s
}

// SetReactionsForComment sets the ReactionsForComment field's value.
func (s *GetCommentReactionsOutput) SetReactionsForComment(v []*ReactionForComment) *GetCommentReactionsOutput {
	s.ReactionsForComment = v
	return s
}

type GetCommentsForComparedCommitInput struct {
	_ struct{} `type:"structure"`

	// To establish the directionality of the comparison, the full commit ID of
	// the after commit.
	//
	// AfterCommitId is a required field
	AfterCommitId *string `locationName:"afterCommitId" type:"string" required:"true"`

	// To establish the directionality of the comparison, the full commit ID of
	// the before commit.
	BeforeCommitId *string `locationName:"beforeCommitId" type:"string"`

	// A non-zero, non-negative integer used to limit the number of returned results.
	// The default is 100 comments, but you can configure up to 500.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// An enumeration token that when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The name of the repository where you want to compare commits.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetCommentsForComparedCommitInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCommentsForComparedCommitInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetCommentsForComparedCommitInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetCommentsForComparedCommitInput"}
	if s.AfterCommitId == nil {
		invalidParams.Add(request.NewErrParamRequired("AfterCommitId"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAfterCommitId sets the AfterCommitId field's value.
func (s *GetCommentsForComparedCommitInput) SetAfterCommitId(v string) *GetCommentsForComparedCommitInput {
	s.AfterCommitId = &v
	return s
}

// SetBeforeCommitId sets the BeforeCommitId field's value.
func (s *GetCommentsForComparedCommitInput) SetBeforeCommitId(v string) *GetCommentsForComparedCommitInput {
	s.BeforeCommitId = &v
	return s
}

// SetMaxResults sets the MaxResults field's value.
func (s *GetCommentsForComparedCommitInput) SetMaxResults(v int64) *GetCommentsForComparedCommitInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *GetCommentsForComparedCommitInput) SetNextToken(v string) *GetCommentsForComparedCommitInput {
	s.NextToken = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetCommentsForComparedCommitInput) SetRepositoryName(v string) *GetCommentsForComparedCommitInput {
	s.RepositoryName = &v
	return s
}

type GetCommentsForComparedCommitOutput struct {
	_ struct{} `type:"structure"`

	// A list of comment objects on the compared commit.
	CommentsForComparedCommitData []*CommentsForComparedCommit `locationName:"commentsForComparedCommitData" type:"list"`

	// An enumeration token that can be used in a request to return the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetCommentsForComparedCommitOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCommentsForComparedCommitOutput) GoString() string {
	return s.String()
}

// SetCommentsForComparedCommitData sets the CommentsForComparedCommitData field's value.
func (s *GetCommentsForComparedCommitOutput) SetCommentsForComparedCommitData(v []*CommentsForComparedCommit) *GetCommentsForComparedCommitOutput {
	s.CommentsForComparedCommitData = v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *GetCommentsForComparedCommitOutput) SetNextToken(v string) *GetCommentsForComparedCommitOutput {
	s.NextToken = &v
	return s
}

type GetCommentsForPullRequestInput struct {
	_ struct{} `type:"structure"`

	// The full commit ID of the commit in the source branch that was the tip of
	// the branch at the time the comment was made.
	AfterCommitId *string `locationName:"afterCommitId" type:"string"`

	// The full commit ID of the commit in the destination branch that was the tip
	// of the branch at the time the pull request was created.
	BeforeCommitId *string `locationName:"beforeCommitId" type:"string"`

	// A non-zero, non-negative integer used to limit the number of returned results.
	// The default is 100 comments. You can return up to 500 comments with a single
	// request.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The system-generated ID of the pull request. To get this ID, use ListPullRequests.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The name of the repository that contains the pull request.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s GetCommentsForPullRequestInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCommentsForPullRequestInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetCommentsForPullRequestInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetCommentsForPullRequestInput"}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAfterCommitId sets the AfterCommitId field's value.
func (s *GetCommentsForPullRequestInput) SetAfterCommitId(v string) *GetCommentsForPullRequestInput {
	s.AfterCommitId = &v
	return s
}

// SetBeforeCommitId sets the BeforeCommitId field's value.
func (s *GetCommentsForPullRequestInput) SetBeforeCommitId(v string) *GetCommentsForPullRequestInput {
	s.BeforeCommitId = &v
	return s
}

// SetMaxResults sets the MaxResults field's value.
func (s *GetCommentsForPullRequestInput) SetMaxResults(v int64) *GetCommentsForPullRequestInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *GetCommentsForPullRequestInput) SetNextToken(v string) *GetCommentsForPullRequestInput {
	s.NextToken = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *GetCommentsForPullRequestInput) SetPullRequestId(v string) *GetCommentsForPullRequestInput {
	s.PullRequestId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetCommentsForPullRequestInput) SetRepositoryName(v string) *GetCommentsForPullRequestInput {
	s.RepositoryName = &v
	return s
}

type GetCommentsForPullRequestOutput struct {
	_ struct{} `type:"structure"`

	// An array of comment objects on the pull request.
	CommentsForPullRequestData []*CommentsForPullRequest `locationName:"commentsForPullRequestData" type:"list"`

	// An enumeration token that can be used in a request to return the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s GetCommentsForPullRequestOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCommentsForPullRequestOutput) GoString() string {
	return s.String()
}

// SetCommentsForPullRequestData sets the CommentsForPullRequestData field's value.
func (s *GetCommentsForPullRequestOutput) SetCommentsForPullRequestData(v []*CommentsForPullRequest) *GetCommentsForPullRequestOutput {
	s.CommentsForPullRequestData = v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *GetCommentsForPullRequestOutput) SetNextToken(v string) *GetCommentsForPullRequestOutput {
	s.NextToken = &v
	return s
}

// Represents the input of a get commit operation.
type GetCommitInput struct {
	_ struct{} `type:"structure"`

	// The commit ID. Commit IDs are the full SHA ID of the commit.
	//
	// CommitId is a required field
	CommitId *string `locationName:"commitId" type:"string" required:"true"`

	// The name of the repository to which the commit was made.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetCommitInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCommitInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetCommitInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetCommitInput"}
	if s.CommitId == nil {
		invalidParams.Add(request.NewErrParamRequired("CommitId"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetCommitId sets the CommitId field's value.
func (s *GetCommitInput) SetCommitId(v string) *GetCommitInput {
	s.CommitId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetCommitInput) SetRepositoryName(v string) *GetCommitInput {
	s.RepositoryName = &v
	return s
}

// Represents the output of a get commit operation.
type GetCommitOutput struct {
	_ struct{} `type:"structure"`

	// A commit data type object that contains information about the specified commit.
	//
	// Commit is a required field
	Commit *Commit `locationName:"commit" type:"structure" required:"true"`
}

// String returns the string representation
func (s GetCommitOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetCommitOutput) GoString() string {
	return s.String()
}

// SetCommit sets the Commit field's value.
func (s *GetCommitOutput) SetCommit(v *Commit) *GetCommitOutput {
	s.Commit = v
	return s
}

type GetDifferencesInput struct {
	_ struct{} `type:"structure"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit.
	//
	// AfterCommitSpecifier is a required field
	AfterCommitSpecifier *string `locationName:"afterCommitSpecifier" type:"string" required:"true"`

	// The file path in which to check differences. Limits the results to this path.
	// Can also be used to specify the changed name of a directory or folder, if
	// it has changed. If not specified, differences are shown for all paths.
	AfterPath *string `locationName:"afterPath" type:"string"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, the full commit ID). Optional. If not specified, all
	// changes before the afterCommitSpecifier value are shown. If you do not use
	// beforeCommitSpecifier in your request, consider limiting the results with
	// maxResults.
	BeforeCommitSpecifier *string `locationName:"beforeCommitSpecifier" type:"string"`

	// The file path in which to check for differences. Limits the results to this
	// path. Can also be used to specify the previous name of a directory or folder.
	// If beforePath and afterPath are not specified, differences are shown for
	// all paths.
	BeforePath *string `locationName:"beforePath" type:"string"`

	// A non-zero, non-negative integer used to limit the number of returned results.
	MaxResults *int64 `type:"integer"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `type:"string"`

	// The name of the repository where you want to get differences.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetDifferencesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDifferencesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetDifferencesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetDifferencesInput"}
	if s.AfterCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("AfterCommitSpecifier"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAfterCommitSpecifier sets the AfterCommitSpecifier field's value.
func (s *GetDifferencesInput) SetAfterCommitSpecifier(v string) *GetDifferencesInput {
	s.AfterCommitSpecifier = &v
	return s
}

// SetAfterPath sets the AfterPath field's value.
func (s *GetDifferencesInput) SetAfterPath(v string) *GetDifferencesInput {
	s.AfterPath = &v
	return s
}

// SetBeforeCommitSpecifier sets the BeforeCommitSpecifier field's value.
func (s *GetDifferencesInput) SetBeforeCommitSpecifier(v string) *GetDifferencesInput {
	s.BeforeCommitSpecifier = &v
	return s
}

// SetBeforePath sets the BeforePath field's value.
func (s *GetDifferencesInput) SetBeforePath(v string) *GetDifferencesInput {
	s.BeforePath = &v
	return s
}

// SetMaxResults sets the MaxResults field's value.
func (s *GetDifferencesInput) SetMaxResults(v int64) *GetDifferencesInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *GetDifferencesInput) SetNextToken(v string) *GetDifferencesInput {
	s.NextToken = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetDifferencesInput) SetRepositoryName(v string) *GetDifferencesInput {
	s.RepositoryName = &v
	return s
}

type GetDifferencesOutput struct {
	_ struct{} `type:"structure"`

	// A data type object that contains information about the differences, including
	// whether the difference is added, modified, or deleted (A, D, M).
	Differences []*Difference `locationName:"differences" type:"list"`

	// An enumeration token that can be used in a request to return the next batch
	// of the results.
	NextToken *string `type:"string"`
}

// String returns the string representation
func (s GetDifferencesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetDifferencesOutput) GoString() string {
	return s.String()
}

// SetDifferences sets the Differences field's value.
func (s *GetDifferencesOutput) SetDifferences(v []*Difference) *GetDifferencesOutput {
	s.Differences = v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *GetDifferencesOutput) SetNextToken(v string) *GetDifferencesOutput {
	s.NextToken = &v
	return s
}

type GetFileInput struct {
	_ struct{} `type:"structure"`

	// The fully quaified reference that identifies the commit that contains the
	// file. For example, you can specify a full commit ID, a tag, a branch name,
	// or a reference such as refs/heads/master. If none is provided, the head commit
	// is used.
	CommitSpecifier *string `locationName:"commitSpecifier" type:"string"`

	// The fully qualified path to the file, including the full name and extension
	// of the file. For example, /examples/file.md is the fully qualified path to
	// a file named file.md in a folder named examples.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`

	// The name of the repository that contains the file.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetFileInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetFileInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetFileInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetFileInput"}
	if s.FilePath == nil {
		invalidParams.Add(request.NewErrParamRequired("FilePath"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetCommitSpecifier sets the CommitSpecifier field's value.
func (s *GetFileInput) SetCommitSpecifier(v string) *GetFileInput {
	s.CommitSpecifier = &v
	return s
}

// SetFilePath sets the FilePath field's value.
func (s *GetFileInput) SetFilePath(v string) *GetFileInput {
	s.FilePath = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetFileInput) SetRepositoryName(v string) *GetFileInput {
	s.RepositoryName = &v
	return s
}

type GetFileOutput struct {
	_ struct{} `type:"structure"`

	// The blob ID of the object that represents the file content.
	//
	// BlobId is a required field
	BlobId *string `locationName:"blobId" type:"string" required:"true"`

	// The full commit ID of the commit that contains the content returned by GetFile.
	//
	// CommitId is a required field
	CommitId *string `locationName:"commitId" type:"string" required:"true"`

	// The base-64 encoded binary data object that represents the content of the
	// file.
	//
	// FileContent is automatically base64 encoded/decoded by the SDK.
	//
	// FileContent is a required field
	FileContent []byte `locationName:"fileContent" type:"blob" required:"true"`

	// The extrapolated file mode permissions of the blob. Valid values include
	// strings such as EXECUTABLE and not numeric values.
	//
	// The file mode permissions returned by this API are not the standard file
	// mode permission values, such as 100644, but rather extrapolated values. See
	// the supported return values.
	//
	// FileMode is a required field
	FileMode *string `locationName:"fileMode" type:"string" required:"true" enum:"FileModeTypeEnum"`

	// The fully qualified path to the specified file. Returns the name and extension
	// of the file.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`

	// The size of the contents of the file, in bytes.
	//
	// FileSize is a required field
	FileSize *int64 `locationName:"fileSize" type:"long" required:"true"`
}

// String returns the string representation
func (s GetFileOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetFileOutput) GoString() string {
	return s.String()
}

// SetBlobId sets the BlobId field's value.
func (s *GetFileOutput) SetBlobId(v string) *GetFileOutput {
	s.BlobId = &v
	return s
}

// SetCommitId sets the CommitId field's value.
func (s *GetFileOutput) SetCommitId(v string) *GetFileOutput {
	s.CommitId = &v
	return s
}

// SetFileContent sets the FileContent field's value.
func (s *GetFileOutput) SetFileContent(v []byte) *GetFileOutput {
	s.FileContent = v
	return s
}

// SetFileMode sets the FileMode field's value.
func (s *GetFileOutput) SetFileMode(v string) *GetFileOutput {
	s.FileMode = &v
	return s
}

// SetFilePath sets the FilePath field's value.
func (s *GetFileOutput) SetFilePath(v string) *GetFileOutput {
	s.FilePath = &v
	return s
}

// SetFileSize sets the FileSize field's value.
func (s *GetFileOutput) SetFileSize(v int64) *GetFileOutput {
	s.FileSize = &v
	return s
}

type GetFolderInput struct {
	_ struct{} `type:"structure"`

	// A fully qualified reference used to identify a commit that contains the version
	// of the folder's content to return. A fully qualified reference can be a commit
	// ID, branch name, tag, or reference such as HEAD. If no specifier is provided,
	// the folder content is returned as it exists in the HEAD commit.
	CommitSpecifier *string `locationName:"commitSpecifier" type:"string"`

	// The fully qualified path to the folder whose contents are returned, including
	// the folder name. For example, /examples is a fully-qualified path to a folder
	// named examples that was created off of the root directory (/) of a repository.
	//
	// FolderPath is a required field
	FolderPath *string `locationName:"folderPath" type:"string" required:"true"`

	// The name of the repository.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetFolderInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetFolderInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetFolderInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetFolderInput"}
	if s.FolderPath == nil {
		invalidParams.Add(request.NewErrParamRequired("FolderPath"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetCommitSpecifier sets the CommitSpecifier field's value.
func (s *GetFolderInput) SetCommitSpecifier(v string) *GetFolderInput {
	s.CommitSpecifier = &v
	return s
}

// SetFolderPath sets the FolderPath field's value.
func (s *GetFolderInput) SetFolderPath(v string) *GetFolderInput {
	s.FolderPath = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetFolderInput) SetRepositoryName(v string) *GetFolderInput {
	s.RepositoryName = &v
	return s
}

type GetFolderOutput struct {
	_ struct{} `type:"structure"`

	// The full commit ID used as a reference for the returned version of the folder
	// content.
	//
	// CommitId is a required field
	CommitId *string `locationName:"commitId" type:"string" required:"true"`

	// The list of files in the specified folder, if any.
	Files []*File `locationName:"files" type:"list"`

	// The fully qualified path of the folder whose contents are returned.
	//
	// FolderPath is a required field
	FolderPath *string `locationName:"folderPath" type:"string" required:"true"`

	// The list of folders that exist under the specified folder, if any.
	SubFolders []*Folder `locationName:"subFolders" type:"list"`

	// The list of submodules in the specified folder, if any.
	SubModules []*SubModule `locationName:"subModules" type:"list"`

	// The list of symbolic links to other files and folders in the specified folder,
	// if any.
	SymbolicLinks []*SymbolicLink `locationName:"symbolicLinks" type:"list"`

	// The full SHA-1 pointer of the tree information for the commit that contains
	// the folder.
	TreeId *string `locationName:"treeId" type:"string"`
}

// String returns the string representation
func (s GetFolderOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetFolderOutput) GoString() string {
	return s.String()
}

// SetCommitId sets the CommitId field's value.
func (s *GetFolderOutput) SetCommitId(v string) *GetFolderOutput {
	s.CommitId = &v
	return s
}

// SetFiles sets the Files field's value.
func (s *GetFolderOutput) SetFiles(v []*File) *GetFolderOutput {
	s.Files = v
	return s
}

// SetFolderPath sets the FolderPath field's value.
func (s *GetFolderOutput) SetFolderPath(v string) *GetFolderOutput {
	s.FolderPath = &v
	return s
}

// SetSubFolders sets the SubFolders field's value.
func (s *GetFolderOutput) SetSubFolders(v []*Folder) *GetFolderOutput {
	s.SubFolders = v
	return s
}

// SetSubModules sets the SubModules field's value.
func (s *GetFolderOutput) SetSubModules(v []*SubModule) *GetFolderOutput {
	s.SubModules = v
	return s
}

// SetSymbolicLinks sets the SymbolicLinks field's value.
func (s *GetFolderOutput) SetSymbolicLinks(v []*SymbolicLink) *GetFolderOutput {
	s.SymbolicLinks = v
	return s
}

// SetTreeId sets the TreeId field's value.
func (s *GetFolderOutput) SetTreeId(v string) *GetFolderOutput {
	s.TreeId = &v
	return s
}

type GetMergeCommitInput struct {
	_ struct{} `type:"structure"`

	// The level of conflict detail to use. If unspecified, the default FILE_LEVEL
	// is used, which returns a not-mergeable result if the same file has differences
	// in both branches. If LINE_LEVEL is specified, a conflict is considered not
	// mergeable if the same file in both branches has differences on the same line.
	ConflictDetailLevel *string `locationName:"conflictDetailLevel" type:"string" enum:"ConflictDetailLevelTypeEnum"`

	// Specifies which branch to use when resolving conflicts, or whether to attempt
	// automatically merging two versions of a file. The default is NONE, which
	// requires any conflicts to be resolved manually before the merge operation
	// is successful.
	ConflictResolutionStrategy *string `locationName:"conflictResolutionStrategy" type:"string" enum:"ConflictResolutionStrategyTypeEnum"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// DestinationCommitSpecifier is a required field
	DestinationCommitSpecifier *string `locationName:"destinationCommitSpecifier" type:"string" required:"true"`

	// The name of the repository that contains the merge commit about which you
	// want to get information.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// SourceCommitSpecifier is a required field
	SourceCommitSpecifier *string `locationName:"sourceCommitSpecifier" type:"string" required:"true"`
}

// String returns the string representation
func (s GetMergeCommitInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetMergeCommitInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetMergeCommitInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetMergeCommitInput"}
	if s.DestinationCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("DestinationCommitSpecifier"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.SourceCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("SourceCommitSpecifier"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetConflictDetailLevel sets the ConflictDetailLevel field's value.
func (s *GetMergeCommitInput) SetConflictDetailLevel(v string) *GetMergeCommitInput {
	s.ConflictDetailLevel = &v
	return s
}

// SetConflictResolutionStrategy sets the ConflictResolutionStrategy field's value.
func (s *GetMergeCommitInput) SetConflictResolutionStrategy(v string) *GetMergeCommitInput {
	s.ConflictResolutionStrategy = &v
	return s
}

// SetDestinationCommitSpecifier sets the DestinationCommitSpecifier field's value.
func (s *GetMergeCommitInput) SetDestinationCommitSpecifier(v string) *GetMergeCommitInput {
	s.DestinationCommitSpecifier = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetMergeCommitInput) SetRepositoryName(v string) *GetMergeCommitInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitSpecifier sets the SourceCommitSpecifier field's value.
func (s *GetMergeCommitInput) SetSourceCommitSpecifier(v string) *GetMergeCommitInput {
	s.SourceCommitSpecifier = &v
	return s
}

type GetMergeCommitOutput struct {
	_ struct{} `type:"structure"`

	// The commit ID of the merge base.
	BaseCommitId *string `locationName:"baseCommitId" type:"string"`

	// The commit ID of the destination commit specifier that was used in the merge
	// evaluation.
	DestinationCommitId *string `locationName:"destinationCommitId" type:"string"`

	// The commit ID for the merge commit created when the source branch was merged
	// into the destination branch. If the fast-forward merge strategy was used,
	// there is no merge commit.
	MergedCommitId *string `locationName:"mergedCommitId" type:"string"`

	// The commit ID of the source commit specifier that was used in the merge evaluation.
	SourceCommitId *string `locationName:"sourceCommitId" type:"string"`
}

// String returns the string representation
func (s GetMergeCommitOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetMergeCommitOutput) GoString() string {
	return s.String()
}

// SetBaseCommitId sets the BaseCommitId field's value.
func (s *GetMergeCommitOutput) SetBaseCommitId(v string) *GetMergeCommitOutput {
	s.BaseCommitId = &v
	return s
}

// SetDestinationCommitId sets the DestinationCommitId field's value.
func (s *GetMergeCommitOutput) SetDestinationCommitId(v string) *GetMergeCommitOutput {
	s.DestinationCommitId = &v
	return s
}

// SetMergedCommitId sets the MergedCommitId field's value.
func (s *GetMergeCommitOutput) SetMergedCommitId(v string) *GetMergeCommitOutput {
	s.MergedCommitId = &v
	return s
}

// SetSourceCommitId sets the SourceCommitId field's value.
func (s *GetMergeCommitOutput) SetSourceCommitId(v string) *GetMergeCommitOutput {
	s.SourceCommitId = &v
	return s
}

type GetMergeConflictsInput struct {
	_ struct{} `type:"structure"`

	// The level of conflict detail to use. If unspecified, the default FILE_LEVEL
	// is used, which returns a not-mergeable result if the same file has differences
	// in both branches. If LINE_LEVEL is specified, a conflict is considered not
	// mergeable if the same file in both branches has differences on the same line.
	ConflictDetailLevel *string `locationName:"conflictDetailLevel" type:"string" enum:"ConflictDetailLevelTypeEnum"`

	// Specifies which branch to use when resolving conflicts, or whether to attempt
	// automatically merging two versions of a file. The default is NONE, which
	// requires any conflicts to be resolved manually before the merge operation
	// is successful.
	ConflictResolutionStrategy *string `locationName:"conflictResolutionStrategy" type:"string" enum:"ConflictResolutionStrategyTypeEnum"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// DestinationCommitSpecifier is a required field
	DestinationCommitSpecifier *string `locationName:"destinationCommitSpecifier" type:"string" required:"true"`

	// The maximum number of files to include in the output.
	MaxConflictFiles *int64 `locationName:"maxConflictFiles" type:"integer"`

	// The merge option or strategy you want to use to merge the code.
	//
	// MergeOption is a required field
	MergeOption *string `locationName:"mergeOption" type:"string" required:"true" enum:"MergeOptionTypeEnum"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The name of the repository where the pull request was created.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// SourceCommitSpecifier is a required field
	SourceCommitSpecifier *string `locationName:"sourceCommitSpecifier" type:"string" required:"true"`
}

// String returns the string representation
func (s GetMergeConflictsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetMergeConflictsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetMergeConflictsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetMergeConflictsInput"}
	if s.DestinationCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("DestinationCommitSpecifier"))
	}
	if s.MergeOption == nil {
		invalidParams.Add(request.NewErrParamRequired("MergeOption"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.SourceCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("SourceCommitSpecifier"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetConflictDetailLevel sets the ConflictDetailLevel field's value.
func (s *GetMergeConflictsInput) SetConflictDetailLevel(v string) *GetMergeConflictsInput {
	s.ConflictDetailLevel = &v
	return s
}

// SetConflictResolutionStrategy sets the ConflictResolutionStrategy field's value.
func (s *GetMergeConflictsInput) SetConflictResolutionStrategy(v string) *GetMergeConflictsInput {
	s.ConflictResolutionStrategy = &v
	return s
}

// SetDestinationCommitSpecifier sets the DestinationCommitSpecifier field's value.
func (s *GetMergeConflictsInput) SetDestinationCommitSpecifier(v string) *GetMergeConflictsInput {
	s.DestinationCommitSpecifier = &v
	return s
}

// SetMaxConflictFiles sets the MaxConflictFiles field's value.
func (s *GetMergeConflictsInput) SetMaxConflictFiles(v int64) *GetMergeConflictsInput {
	s.MaxConflictFiles = &v
	return s
}

// SetMergeOption sets the MergeOption field's value.
func (s *GetMergeConflictsInput) SetMergeOption(v string) *GetMergeConflictsInput {
	s.MergeOption = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *GetMergeConflictsInput) SetNextToken(v string) *GetMergeConflictsInput {
	s.NextToken = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetMergeConflictsInput) SetRepositoryName(v string) *GetMergeConflictsInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitSpecifier sets the SourceCommitSpecifier field's value.
func (s *GetMergeConflictsInput) SetSourceCommitSpecifier(v string) *GetMergeConflictsInput {
	s.SourceCommitSpecifier = &v
	return s
}

type GetMergeConflictsOutput struct {
	_ struct{} `type:"structure"`

	// The commit ID of the merge base.
	BaseCommitId *string `locationName:"baseCommitId" type:"string"`

	// A list of metadata for any conflicting files. If the specified merge strategy
	// is FAST_FORWARD_MERGE, this list is always empty.
	//
	// ConflictMetadataList is a required field
	ConflictMetadataList []*ConflictMetadata `locationName:"conflictMetadataList" type:"list" required:"true"`

	// The commit ID of the destination commit specifier that was used in the merge
	// evaluation.
	//
	// DestinationCommitId is a required field
	DestinationCommitId *string `locationName:"destinationCommitId" type:"string" required:"true"`

	// A Boolean value that indicates whether the code is mergeable by the specified
	// merge option.
	//
	// Mergeable is a required field
	Mergeable *bool `locationName:"mergeable" type:"boolean" required:"true"`

	// An enumeration token that can be used in a request to return the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The commit ID of the source commit specifier that was used in the merge evaluation.
	//
	// SourceCommitId is a required field
	SourceCommitId *string `locationName:"sourceCommitId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetMergeConflictsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetMergeConflictsOutput) GoString() string {
	return s.String()
}

// SetBaseCommitId sets the BaseCommitId field's value.
func (s *GetMergeConflictsOutput) SetBaseCommitId(v string) *GetMergeConflictsOutput {
	s.BaseCommitId = &v
	return s
}

// SetConflictMetadataList sets the ConflictMetadataList field's value.
func (s *GetMergeConflictsOutput) SetConflictMetadataList(v []*ConflictMetadata) *GetMergeConflictsOutput {
	s.ConflictMetadataList = v
	return s
}

// SetDestinationCommitId sets the DestinationCommitId field's value.
func (s *GetMergeConflictsOutput) SetDestinationCommitId(v string) *GetMergeConflictsOutput {
	s.DestinationCommitId = &v
	return s
}

// SetMergeable sets the Mergeable field's value.
func (s *GetMergeConflictsOutput) SetMergeable(v bool) *GetMergeConflictsOutput {
	s.Mergeable = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *GetMergeConflictsOutput) SetNextToken(v string) *GetMergeConflictsOutput {
	s.NextToken = &v
	return s
}

// SetSourceCommitId sets the SourceCommitId field's value.
func (s *GetMergeConflictsOutput) SetSourceCommitId(v string) *GetMergeConflictsOutput {
	s.SourceCommitId = &v
	return s
}

type GetMergeOptionsInput struct {
	_ struct{} `type:"structure"`

	// The level of conflict detail to use. If unspecified, the default FILE_LEVEL
	// is used, which returns a not-mergeable result if the same file has differences
	// in both branches. If LINE_LEVEL is specified, a conflict is considered not
	// mergeable if the same file in both branches has differences on the same line.
	ConflictDetailLevel *string `locationName:"conflictDetailLevel" type:"string" enum:"ConflictDetailLevelTypeEnum"`

	// Specifies which branch to use when resolving conflicts, or whether to attempt
	// automatically merging two versions of a file. The default is NONE, which
	// requires any conflicts to be resolved manually before the merge operation
	// is successful.
	ConflictResolutionStrategy *string `locationName:"conflictResolutionStrategy" type:"string" enum:"ConflictResolutionStrategyTypeEnum"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// DestinationCommitSpecifier is a required field
	DestinationCommitSpecifier *string `locationName:"destinationCommitSpecifier" type:"string" required:"true"`

	// The name of the repository that contains the commits about which you want
	// to get merge options.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// SourceCommitSpecifier is a required field
	SourceCommitSpecifier *string `locationName:"sourceCommitSpecifier" type:"string" required:"true"`
}

// String returns the string representation
func (s GetMergeOptionsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetMergeOptionsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetMergeOptionsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetMergeOptionsInput"}
	if s.DestinationCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("DestinationCommitSpecifier"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.SourceCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("SourceCommitSpecifier"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetConflictDetailLevel sets the ConflictDetailLevel field's value.
func (s *GetMergeOptionsInput) SetConflictDetailLevel(v string) *GetMergeOptionsInput {
	s.ConflictDetailLevel = &v
	return s
}

// SetConflictResolutionStrategy sets the ConflictResolutionStrategy field's value.
func (s *GetMergeOptionsInput) SetConflictResolutionStrategy(v string) *GetMergeOptionsInput {
	s.ConflictResolutionStrategy = &v
	return s
}

// SetDestinationCommitSpecifier sets the DestinationCommitSpecifier field's value.
func (s *GetMergeOptionsInput) SetDestinationCommitSpecifier(v string) *GetMergeOptionsInput {
	s.DestinationCommitSpecifier = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetMergeOptionsInput) SetRepositoryName(v string) *GetMergeOptionsInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitSpecifier sets the SourceCommitSpecifier field's value.
func (s *GetMergeOptionsInput) SetSourceCommitSpecifier(v string) *GetMergeOptionsInput {
	s.SourceCommitSpecifier = &v
	return s
}

type GetMergeOptionsOutput struct {
	_ struct{} `type:"structure"`

	// The commit ID of the merge base.
	//
	// BaseCommitId is a required field
	BaseCommitId *string `locationName:"baseCommitId" type:"string" required:"true"`

	// The commit ID of the destination commit specifier that was used in the merge
	// evaluation.
	//
	// DestinationCommitId is a required field
	DestinationCommitId *string `locationName:"destinationCommitId" type:"string" required:"true"`

	// The merge option or strategy used to merge the code.
	//
	// MergeOptions is a required field
	MergeOptions []*string `locationName:"mergeOptions" type:"list" required:"true"`

	// The commit ID of the source commit specifier that was used in the merge evaluation.
	//
	// SourceCommitId is a required field
	SourceCommitId *string `locationName:"sourceCommitId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetMergeOptionsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetMergeOptionsOutput) GoString() string {
	return s.String()
}

// SetBaseCommitId sets the BaseCommitId field's value.
func (s *GetMergeOptionsOutput) SetBaseCommitId(v string) *GetMergeOptionsOutput {
	s.BaseCommitId = &v
	return s
}

// SetDestinationCommitId sets the DestinationCommitId field's value.
func (s *GetMergeOptionsOutput) SetDestinationCommitId(v string) *GetMergeOptionsOutput {
	s.DestinationCommitId = &v
	return s
}

// SetMergeOptions sets the MergeOptions field's value.
func (s *GetMergeOptionsOutput) SetMergeOptions(v []*string) *GetMergeOptionsOutput {
	s.MergeOptions = v
	return s
}

// SetSourceCommitId sets the SourceCommitId field's value.
func (s *GetMergeOptionsOutput) SetSourceCommitId(v string) *GetMergeOptionsOutput {
	s.SourceCommitId = &v
	return s
}

type GetPullRequestApprovalStatesInput struct {
	_ struct{} `type:"structure"`

	// The system-generated ID for the pull request.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The system-generated ID for the pull request revision.
	//
	// RevisionId is a required field
	RevisionId *string `locationName:"revisionId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetPullRequestApprovalStatesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetPullRequestApprovalStatesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetPullRequestApprovalStatesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetPullRequestApprovalStatesInput"}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.RevisionId == nil {
		invalidParams.Add(request.NewErrParamRequired("RevisionId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *GetPullRequestApprovalStatesInput) SetPullRequestId(v string) *GetPullRequestApprovalStatesInput {
	s.PullRequestId = &v
	return s
}

// SetRevisionId sets the RevisionId field's value.
func (s *GetPullRequestApprovalStatesInput) SetRevisionId(v string) *GetPullRequestApprovalStatesInput {
	s.RevisionId = &v
	return s
}

type GetPullRequestApprovalStatesOutput struct {
	_ struct{} `type:"structure"`

	// Information about users who have approved the pull request.
	Approvals []*Approval `locationName:"approvals" type:"list"`
}

// String returns the string representation
func (s GetPullRequestApprovalStatesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetPullRequestApprovalStatesOutput) GoString() string {
	return s.String()
}

// SetApprovals sets the Approvals field's value.
func (s *GetPullRequestApprovalStatesOutput) SetApprovals(v []*Approval) *GetPullRequestApprovalStatesOutput {
	s.Approvals = v
	return s
}

type GetPullRequestInput struct {
	_ struct{} `type:"structure"`

	// The system-generated ID of the pull request. To get this ID, use ListPullRequests.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetPullRequestInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetPullRequestInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetPullRequestInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetPullRequestInput"}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *GetPullRequestInput) SetPullRequestId(v string) *GetPullRequestInput {
	s.PullRequestId = &v
	return s
}

type GetPullRequestOutput struct {
	_ struct{} `type:"structure"`

	// Information about the specified pull request.
	//
	// PullRequest is a required field
	PullRequest *PullRequest `locationName:"pullRequest" type:"structure" required:"true"`
}

// String returns the string representation
func (s GetPullRequestOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetPullRequestOutput) GoString() string {
	return s.String()
}

// SetPullRequest sets the PullRequest field's value.
func (s *GetPullRequestOutput) SetPullRequest(v *PullRequest) *GetPullRequestOutput {
	s.PullRequest = v
	return s
}

type GetPullRequestOverrideStateInput struct {
	_ struct{} `type:"structure"`

	// The ID of the pull request for which you want to get information about whether
	// approval rules have been set aside (overridden).
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The system-generated ID of the revision for the pull request. To retrieve
	// the most recent revision ID, use GetPullRequest.
	//
	// RevisionId is a required field
	RevisionId *string `locationName:"revisionId" type:"string" required:"true"`
}

// String returns the string representation
func (s GetPullRequestOverrideStateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetPullRequestOverrideStateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetPullRequestOverrideStateInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetPullRequestOverrideStateInput"}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.RevisionId == nil {
		invalidParams.Add(request.NewErrParamRequired("RevisionId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *GetPullRequestOverrideStateInput) SetPullRequestId(v string) *GetPullRequestOverrideStateInput {
	s.PullRequestId = &v
	return s
}

// SetRevisionId sets the RevisionId field's value.
func (s *GetPullRequestOverrideStateInput) SetRevisionId(v string) *GetPullRequestOverrideStateInput {
	s.RevisionId = &v
	return s
}

type GetPullRequestOverrideStateOutput struct {
	_ struct{} `type:"structure"`

	// A Boolean value that indicates whether a pull request has had its rules set
	// aside (TRUE) or whether all approval rules still apply (FALSE).
	Overridden *bool `locationName:"overridden" type:"boolean"`

	// The Amazon Resource Name (ARN) of the user or identity that overrode the
	// rules and their requirements for the pull request.
	Overrider *string `locationName:"overrider" type:"string"`
}

// String returns the string representation
func (s GetPullRequestOverrideStateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetPullRequestOverrideStateOutput) GoString() string {
	return s.String()
}

// SetOverridden sets the Overridden field's value.
func (s *GetPullRequestOverrideStateOutput) SetOverridden(v bool) *GetPullRequestOverrideStateOutput {
	s.Overridden = &v
	return s
}

// SetOverrider sets the Overrider field's value.
func (s *GetPullRequestOverrideStateOutput) SetOverrider(v string) *GetPullRequestOverrideStateOutput {
	s.Overrider = &v
	return s
}

// Represents the input of a get repository operation.
type GetRepositoryInput struct {
	_ struct{} `type:"structure"`

	// The name of the repository to get information about.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetRepositoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRepositoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetRepositoryInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetRepositoryInput"}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetRepositoryInput) SetRepositoryName(v string) *GetRepositoryInput {
	s.RepositoryName = &v
	return s
}

// Represents the output of a get repository operation.
type GetRepositoryOutput struct {
	_ struct{} `type:"structure"`

	// Information about the repository.
	RepositoryMetadata *RepositoryMetadata `locationName:"repositoryMetadata" type:"structure"`
}

// String returns the string representation
func (s GetRepositoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRepositoryOutput) GoString() string {
	return s.String()
}

// SetRepositoryMetadata sets the RepositoryMetadata field's value.
func (s *GetRepositoryOutput) SetRepositoryMetadata(v *RepositoryMetadata) *GetRepositoryOutput {
	s.RepositoryMetadata = v
	return s
}

// Represents the input of a get repository triggers operation.
type GetRepositoryTriggersInput struct {
	_ struct{} `type:"structure"`

	// The name of the repository for which the trigger is configured.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s GetRepositoryTriggersInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRepositoryTriggersInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *GetRepositoryTriggersInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "GetRepositoryTriggersInput"}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *GetRepositoryTriggersInput) SetRepositoryName(v string) *GetRepositoryTriggersInput {
	s.RepositoryName = &v
	return s
}

// Represents the output of a get repository triggers operation.
type GetRepositoryTriggersOutput struct {
	_ struct{} `type:"structure"`

	// The system-generated unique ID for the trigger.
	ConfigurationId *string `locationName:"configurationId" type:"string"`

	// The JSON block of configuration information for each trigger.
	Triggers []*RepositoryTrigger `locationName:"triggers" type:"list"`
}

// String returns the string representation
func (s GetRepositoryTriggersOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s GetRepositoryTriggersOutput) GoString() string {
	return s.String()
}

// SetConfigurationId sets the ConfigurationId field's value.
func (s *GetRepositoryTriggersOutput) SetConfigurationId(v string) *GetRepositoryTriggersOutput {
	s.ConfigurationId = &v
	return s
}

// SetTriggers sets the Triggers field's value.
func (s *GetRepositoryTriggersOutput) SetTriggers(v []*RepositoryTrigger) *GetRepositoryTriggersOutput {
	s.Triggers = v
	return s
}

// The client request token is not valid. Either the token is not in a valid
// format, or the token has been used in a previous request and cannot be reused.
type IdempotencyParameterMismatchException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s IdempotencyParameterMismatchException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s IdempotencyParameterMismatchException) GoString() string {
	return s.String()
}

func newErrorIdempotencyParameterMismatchException(v protocol.ResponseMetadata) error {
	return &IdempotencyParameterMismatchException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *IdempotencyParameterMismatchException) Code() string {
	return "IdempotencyParameterMismatchException"
}

// Message returns the exception's message.
func (s *IdempotencyParameterMismatchException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *IdempotencyParameterMismatchException) OrigErr() error {
	return nil
}

func (s *IdempotencyParameterMismatchException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *IdempotencyParameterMismatchException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *IdempotencyParameterMismatchException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The Amazon Resource Name (ARN) is not valid. Make sure that you have provided
// the full ARN for the user who initiated the change for the pull request,
// and then try again.
type InvalidActorArnException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidActorArnException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidActorArnException) GoString() string {
	return s.String()
}

func newErrorInvalidActorArnException(v protocol.ResponseMetadata) error {
	return &InvalidActorArnException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidActorArnException) Code() string {
	return "InvalidActorArnException"
}

// Message returns the exception's message.
func (s *InvalidActorArnException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidActorArnException) OrigErr() error {
	return nil
}

func (s *InvalidActorArnException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidActorArnException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidActorArnException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The content for the approval rule is not valid.
type InvalidApprovalRuleContentException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidApprovalRuleContentException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidApprovalRuleContentException) GoString() string {
	return s.String()
}

func newErrorInvalidApprovalRuleContentException(v protocol.ResponseMetadata) error {
	return &InvalidApprovalRuleContentException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidApprovalRuleContentException) Code() string {
	return "InvalidApprovalRuleContentException"
}

// Message returns the exception's message.
func (s *InvalidApprovalRuleContentException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidApprovalRuleContentException) OrigErr() error {
	return nil
}

func (s *InvalidApprovalRuleContentException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidApprovalRuleContentException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidApprovalRuleContentException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The name for the approval rule is not valid.
type InvalidApprovalRuleNameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidApprovalRuleNameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidApprovalRuleNameException) GoString() string {
	return s.String()
}

func newErrorInvalidApprovalRuleNameException(v protocol.ResponseMetadata) error {
	return &InvalidApprovalRuleNameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidApprovalRuleNameException) Code() string {
	return "InvalidApprovalRuleNameException"
}

// Message returns the exception's message.
func (s *InvalidApprovalRuleNameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidApprovalRuleNameException) OrigErr() error {
	return nil
}

func (s *InvalidApprovalRuleNameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidApprovalRuleNameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidApprovalRuleNameException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The content of the approval rule template is not valid.
type InvalidApprovalRuleTemplateContentException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidApprovalRuleTemplateContentException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidApprovalRuleTemplateContentException) GoString() string {
	return s.String()
}

func newErrorInvalidApprovalRuleTemplateContentException(v protocol.ResponseMetadata) error {
	return &InvalidApprovalRuleTemplateContentException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidApprovalRuleTemplateContentException) Code() string {
	return "InvalidApprovalRuleTemplateContentException"
}

// Message returns the exception's message.
func (s *InvalidApprovalRuleTemplateContentException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidApprovalRuleTemplateContentException) OrigErr() error {
	return nil
}

func (s *InvalidApprovalRuleTemplateContentException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidApprovalRuleTemplateContentException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidApprovalRuleTemplateContentException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The description for the approval rule template is not valid because it exceeds
// the maximum characters allowed for a description. For more information about
// limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
type InvalidApprovalRuleTemplateDescriptionException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidApprovalRuleTemplateDescriptionException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidApprovalRuleTemplateDescriptionException) GoString() string {
	return s.String()
}

func newErrorInvalidApprovalRuleTemplateDescriptionException(v protocol.ResponseMetadata) error {
	return &InvalidApprovalRuleTemplateDescriptionException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidApprovalRuleTemplateDescriptionException) Code() string {
	return "InvalidApprovalRuleTemplateDescriptionException"
}

// Message returns the exception's message.
func (s *InvalidApprovalRuleTemplateDescriptionException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidApprovalRuleTemplateDescriptionException) OrigErr() error {
	return nil
}

func (s *InvalidApprovalRuleTemplateDescriptionException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidApprovalRuleTemplateDescriptionException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidApprovalRuleTemplateDescriptionException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The name of the approval rule template is not valid. Template names must
// be between 1 and 100 valid characters in length. For more information about
// limits in AWS CodeCommit, see AWS CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/limits.html).
type InvalidApprovalRuleTemplateNameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidApprovalRuleTemplateNameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidApprovalRuleTemplateNameException) GoString() string {
	return s.String()
}

func newErrorInvalidApprovalRuleTemplateNameException(v protocol.ResponseMetadata) error {
	return &InvalidApprovalRuleTemplateNameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidApprovalRuleTemplateNameException) Code() string {
	return "InvalidApprovalRuleTemplateNameException"
}

// Message returns the exception's message.
func (s *InvalidApprovalRuleTemplateNameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidApprovalRuleTemplateNameException) OrigErr() error {
	return nil
}

func (s *InvalidApprovalRuleTemplateNameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidApprovalRuleTemplateNameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidApprovalRuleTemplateNameException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The state for the approval is not valid. Valid values include APPROVE and
// REVOKE.
type InvalidApprovalStateException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidApprovalStateException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidApprovalStateException) GoString() string {
	return s.String()
}

func newErrorInvalidApprovalStateException(v protocol.ResponseMetadata) error {
	return &InvalidApprovalStateException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidApprovalStateException) Code() string {
	return "InvalidApprovalStateException"
}

// Message returns the exception's message.
func (s *InvalidApprovalStateException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidApprovalStateException) OrigErr() error {
	return nil
}

func (s *InvalidApprovalStateException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidApprovalStateException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidApprovalStateException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The Amazon Resource Name (ARN) is not valid. Make sure that you have provided
// the full ARN for the author of the pull request, and then try again.
type InvalidAuthorArnException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidAuthorArnException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidAuthorArnException) GoString() string {
	return s.String()
}

func newErrorInvalidAuthorArnException(v protocol.ResponseMetadata) error {
	return &InvalidAuthorArnException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidAuthorArnException) Code() string {
	return "InvalidAuthorArnException"
}

// Message returns the exception's message.
func (s *InvalidAuthorArnException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidAuthorArnException) OrigErr() error {
	return nil
}

func (s *InvalidAuthorArnException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidAuthorArnException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidAuthorArnException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified blob is not valid.
type InvalidBlobIdException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidBlobIdException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidBlobIdException) GoString() string {
	return s.String()
}

func newErrorInvalidBlobIdException(v protocol.ResponseMetadata) error {
	return &InvalidBlobIdException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidBlobIdException) Code() string {
	return "InvalidBlobIdException"
}

// Message returns the exception's message.
func (s *InvalidBlobIdException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidBlobIdException) OrigErr() error {
	return nil
}

func (s *InvalidBlobIdException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidBlobIdException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidBlobIdException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified reference name is not valid.
type InvalidBranchNameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidBranchNameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidBranchNameException) GoString() string {
	return s.String()
}

func newErrorInvalidBranchNameException(v protocol.ResponseMetadata) error {
	return &InvalidBranchNameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidBranchNameException) Code() string {
	return "InvalidBranchNameException"
}

// Message returns the exception's message.
func (s *InvalidBranchNameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidBranchNameException) OrigErr() error {
	return nil
}

func (s *InvalidBranchNameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidBranchNameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidBranchNameException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The client request token is not valid.
type InvalidClientRequestTokenException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidClientRequestTokenException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidClientRequestTokenException) GoString() string {
	return s.String()
}

func newErrorInvalidClientRequestTokenException(v protocol.ResponseMetadata) error {
	return &InvalidClientRequestTokenException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidClientRequestTokenException) Code() string {
	return "InvalidClientRequestTokenException"
}

// Message returns the exception's message.
func (s *InvalidClientRequestTokenException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidClientRequestTokenException) OrigErr() error {
	return nil
}

func (s *InvalidClientRequestTokenException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidClientRequestTokenException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidClientRequestTokenException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The comment ID is not in a valid format. Make sure that you have provided
// the full comment ID.
type InvalidCommentIdException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidCommentIdException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidCommentIdException) GoString() string {
	return s.String()
}

func newErrorInvalidCommentIdException(v protocol.ResponseMetadata) error {
	return &InvalidCommentIdException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidCommentIdException) Code() string {
	return "InvalidCommentIdException"
}

// Message returns the exception's message.
func (s *InvalidCommentIdException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidCommentIdException) OrigErr() error {
	return nil
}

func (s *InvalidCommentIdException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidCommentIdException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidCommentIdException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified commit is not valid.
type InvalidCommitException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidCommitException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidCommitException) GoString() string {
	return s.String()
}

func newErrorInvalidCommitException(v protocol.ResponseMetadata) error {
	return &InvalidCommitException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidCommitException) Code() string {
	return "InvalidCommitException"
}

// Message returns the exception's message.
func (s *InvalidCommitException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidCommitException) OrigErr() error {
	return nil
}

func (s *InvalidCommitException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidCommitException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidCommitException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified commit ID is not valid.
type InvalidCommitIdException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidCommitIdException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidCommitIdException) GoString() string {
	return s.String()
}

func newErrorInvalidCommitIdException(v protocol.ResponseMetadata) error {
	return &InvalidCommitIdException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidCommitIdException) Code() string {
	return "InvalidCommitIdException"
}

// Message returns the exception's message.
func (s *InvalidCommitIdException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidCommitIdException) OrigErr() error {
	return nil
}

func (s *InvalidCommitIdException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidCommitIdException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidCommitIdException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified conflict detail level is not valid.
type InvalidConflictDetailLevelException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidConflictDetailLevelException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidConflictDetailLevelException) GoString() string {
	return s.String()
}

func newErrorInvalidConflictDetailLevelException(v protocol.ResponseMetadata) error {
	return &InvalidConflictDetailLevelException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidConflictDetailLevelException) Code() string {
	return "InvalidConflictDetailLevelException"
}

// Message returns the exception's message.
func (s *InvalidConflictDetailLevelException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidConflictDetailLevelException) OrigErr() error {
	return nil
}

func (s *InvalidConflictDetailLevelException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidConflictDetailLevelException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidConflictDetailLevelException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified conflict resolution list is not valid.
type InvalidConflictResolutionException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidConflictResolutionException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidConflictResolutionException) GoString() string {
	return s.String()
}

func newErrorInvalidConflictResolutionException(v protocol.ResponseMetadata) error {
	return &InvalidConflictResolutionException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidConflictResolutionException) Code() string {
	return "InvalidConflictResolutionException"
}

// Message returns the exception's message.
func (s *InvalidConflictResolutionException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidConflictResolutionException) OrigErr() error {
	return nil
}

func (s *InvalidConflictResolutionException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidConflictResolutionException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidConflictResolutionException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified conflict resolution strategy is not valid.
type InvalidConflictResolutionStrategyException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidConflictResolutionStrategyException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidConflictResolutionStrategyException) GoString() string {
	return s.String()
}

func newErrorInvalidConflictResolutionStrategyException(v protocol.ResponseMetadata) error {
	return &InvalidConflictResolutionStrategyException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidConflictResolutionStrategyException) Code() string {
	return "InvalidConflictResolutionStrategyException"
}

// Message returns the exception's message.
func (s *InvalidConflictResolutionStrategyException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidConflictResolutionStrategyException) OrigErr() error {
	return nil
}

func (s *InvalidConflictResolutionStrategyException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidConflictResolutionStrategyException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidConflictResolutionStrategyException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified continuation token is not valid.
type InvalidContinuationTokenException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidContinuationTokenException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidContinuationTokenException) GoString() string {
	return s.String()
}

func newErrorInvalidContinuationTokenException(v protocol.ResponseMetadata) error {
	return &InvalidContinuationTokenException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidContinuationTokenException) Code() string {
	return "InvalidContinuationTokenException"
}

// Message returns the exception's message.
func (s *InvalidContinuationTokenException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidContinuationTokenException) OrigErr() error {
	return nil
}

func (s *InvalidContinuationTokenException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidContinuationTokenException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidContinuationTokenException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified deletion parameter is not valid.
type InvalidDeletionParameterException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidDeletionParameterException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidDeletionParameterException) GoString() string {
	return s.String()
}

func newErrorInvalidDeletionParameterException(v protocol.ResponseMetadata) error {
	return &InvalidDeletionParameterException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidDeletionParameterException) Code() string {
	return "InvalidDeletionParameterException"
}

// Message returns the exception's message.
func (s *InvalidDeletionParameterException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidDeletionParameterException) OrigErr() error {
	return nil
}

func (s *InvalidDeletionParameterException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidDeletionParameterException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidDeletionParameterException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The pull request description is not valid. Descriptions cannot be more than
// 1,000 characters.
type InvalidDescriptionException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidDescriptionException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidDescriptionException) GoString() string {
	return s.String()
}

func newErrorInvalidDescriptionException(v protocol.ResponseMetadata) error {
	return &InvalidDescriptionException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidDescriptionException) Code() string {
	return "InvalidDescriptionException"
}

// Message returns the exception's message.
func (s *InvalidDescriptionException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidDescriptionException) OrigErr() error {
	return nil
}

func (s *InvalidDescriptionException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidDescriptionException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidDescriptionException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The destination commit specifier is not valid. You must provide a valid branch
// name, tag, or full commit ID.
type InvalidDestinationCommitSpecifierException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidDestinationCommitSpecifierException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidDestinationCommitSpecifierException) GoString() string {
	return s.String()
}

func newErrorInvalidDestinationCommitSpecifierException(v protocol.ResponseMetadata) error {
	return &InvalidDestinationCommitSpecifierException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidDestinationCommitSpecifierException) Code() string {
	return "InvalidDestinationCommitSpecifierException"
}

// Message returns the exception's message.
func (s *InvalidDestinationCommitSpecifierException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidDestinationCommitSpecifierException) OrigErr() error {
	return nil
}

func (s *InvalidDestinationCommitSpecifierException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidDestinationCommitSpecifierException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidDestinationCommitSpecifierException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified email address either contains one or more characters that are
// not allowed, or it exceeds the maximum number of characters allowed for an
// email address.
type InvalidEmailException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidEmailException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidEmailException) GoString() string {
	return s.String()
}

func newErrorInvalidEmailException(v protocol.ResponseMetadata) error {
	return &InvalidEmailException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidEmailException) Code() string {
	return "InvalidEmailException"
}

// Message returns the exception's message.
func (s *InvalidEmailException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidEmailException) OrigErr() error {
	return nil
}

func (s *InvalidEmailException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidEmailException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidEmailException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The location of the file is not valid. Make sure that you include the file
// name and extension.
type InvalidFileLocationException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidFileLocationException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidFileLocationException) GoString() string {
	return s.String()
}

func newErrorInvalidFileLocationException(v protocol.ResponseMetadata) error {
	return &InvalidFileLocationException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidFileLocationException) Code() string {
	return "InvalidFileLocationException"
}

// Message returns the exception's message.
func (s *InvalidFileLocationException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidFileLocationException) OrigErr() error {
	return nil
}

func (s *InvalidFileLocationException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidFileLocationException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidFileLocationException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified file mode permission is not valid. For a list of valid file
// mode permissions, see PutFile.
type InvalidFileModeException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidFileModeException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidFileModeException) GoString() string {
	return s.String()
}

func newErrorInvalidFileModeException(v protocol.ResponseMetadata) error {
	return &InvalidFileModeException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidFileModeException) Code() string {
	return "InvalidFileModeException"
}

// Message returns the exception's message.
func (s *InvalidFileModeException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidFileModeException) OrigErr() error {
	return nil
}

func (s *InvalidFileModeException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidFileModeException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidFileModeException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The position is not valid. Make sure that the line number exists in the version
// of the file you want to comment on.
type InvalidFilePositionException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidFilePositionException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidFilePositionException) GoString() string {
	return s.String()
}

func newErrorInvalidFilePositionException(v protocol.ResponseMetadata) error {
	return &InvalidFilePositionException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidFilePositionException) Code() string {
	return "InvalidFilePositionException"
}

// Message returns the exception's message.
func (s *InvalidFilePositionException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidFilePositionException) OrigErr() error {
	return nil
}

func (s *InvalidFilePositionException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidFilePositionException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidFilePositionException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified value for the number of conflict files to return is not valid.
type InvalidMaxConflictFilesException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidMaxConflictFilesException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidMaxConflictFilesException) GoString() string {
	return s.String()
}

func newErrorInvalidMaxConflictFilesException(v protocol.ResponseMetadata) error {
	return &InvalidMaxConflictFilesException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidMaxConflictFilesException) Code() string {
	return "InvalidMaxConflictFilesException"
}

// Message returns the exception's message.
func (s *InvalidMaxConflictFilesException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidMaxConflictFilesException) OrigErr() error {
	return nil
}

func (s *InvalidMaxConflictFilesException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidMaxConflictFilesException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidMaxConflictFilesException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified value for the number of merge hunks to return is not valid.
type InvalidMaxMergeHunksException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidMaxMergeHunksException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidMaxMergeHunksException) GoString() string {
	return s.String()
}

func newErrorInvalidMaxMergeHunksException(v protocol.ResponseMetadata) error {
	return &InvalidMaxMergeHunksException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidMaxMergeHunksException) Code() string {
	return "InvalidMaxMergeHunksException"
}

// Message returns the exception's message.
func (s *InvalidMaxMergeHunksException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidMaxMergeHunksException) OrigErr() error {
	return nil
}

func (s *InvalidMaxMergeHunksException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidMaxMergeHunksException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidMaxMergeHunksException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified number of maximum results is not valid.
type InvalidMaxResultsException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidMaxResultsException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidMaxResultsException) GoString() string {
	return s.String()
}

func newErrorInvalidMaxResultsException(v protocol.ResponseMetadata) error {
	return &InvalidMaxResultsException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidMaxResultsException) Code() string {
	return "InvalidMaxResultsException"
}

// Message returns the exception's message.
func (s *InvalidMaxResultsException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidMaxResultsException) OrigErr() error {
	return nil
}

func (s *InvalidMaxResultsException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidMaxResultsException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidMaxResultsException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified merge option is not valid for this operation. Not all merge
// strategies are supported for all operations.
type InvalidMergeOptionException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidMergeOptionException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidMergeOptionException) GoString() string {
	return s.String()
}

func newErrorInvalidMergeOptionException(v protocol.ResponseMetadata) error {
	return &InvalidMergeOptionException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidMergeOptionException) Code() string {
	return "InvalidMergeOptionException"
}

// Message returns the exception's message.
func (s *InvalidMergeOptionException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidMergeOptionException) OrigErr() error {
	return nil
}

func (s *InvalidMergeOptionException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidMergeOptionException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidMergeOptionException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified sort order is not valid.
type InvalidOrderException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidOrderException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidOrderException) GoString() string {
	return s.String()
}

func newErrorInvalidOrderException(v protocol.ResponseMetadata) error {
	return &InvalidOrderException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidOrderException) Code() string {
	return "InvalidOrderException"
}

// Message returns the exception's message.
func (s *InvalidOrderException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidOrderException) OrigErr() error {
	return nil
}

func (s *InvalidOrderException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidOrderException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidOrderException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The override status is not valid. Valid statuses are OVERRIDE and REVOKE.
type InvalidOverrideStatusException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidOverrideStatusException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidOverrideStatusException) GoString() string {
	return s.String()
}

func newErrorInvalidOverrideStatusException(v protocol.ResponseMetadata) error {
	return &InvalidOverrideStatusException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidOverrideStatusException) Code() string {
	return "InvalidOverrideStatusException"
}

// Message returns the exception's message.
func (s *InvalidOverrideStatusException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidOverrideStatusException) OrigErr() error {
	return nil
}

func (s *InvalidOverrideStatusException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidOverrideStatusException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidOverrideStatusException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The parent commit ID is not valid. The commit ID cannot be empty, and must
// match the head commit ID for the branch of the repository where you want
// to add or update a file.
type InvalidParentCommitIdException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidParentCommitIdException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidParentCommitIdException) GoString() string {
	return s.String()
}

func newErrorInvalidParentCommitIdException(v protocol.ResponseMetadata) error {
	return &InvalidParentCommitIdException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidParentCommitIdException) Code() string {
	return "InvalidParentCommitIdException"
}

// Message returns the exception's message.
func (s *InvalidParentCommitIdException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidParentCommitIdException) OrigErr() error {
	return nil
}

func (s *InvalidParentCommitIdException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidParentCommitIdException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidParentCommitIdException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified path is not valid.
type InvalidPathException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidPathException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidPathException) GoString() string {
	return s.String()
}

func newErrorInvalidPathException(v protocol.ResponseMetadata) error {
	return &InvalidPathException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidPathException) Code() string {
	return "InvalidPathException"
}

// Message returns the exception's message.
func (s *InvalidPathException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidPathException) OrigErr() error {
	return nil
}

func (s *InvalidPathException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidPathException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidPathException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The pull request event type is not valid.
type InvalidPullRequestEventTypeException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidPullRequestEventTypeException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidPullRequestEventTypeException) GoString() string {
	return s.String()
}

func newErrorInvalidPullRequestEventTypeException(v protocol.ResponseMetadata) error {
	return &InvalidPullRequestEventTypeException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidPullRequestEventTypeException) Code() string {
	return "InvalidPullRequestEventTypeException"
}

// Message returns the exception's message.
func (s *InvalidPullRequestEventTypeException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidPullRequestEventTypeException) OrigErr() error {
	return nil
}

func (s *InvalidPullRequestEventTypeException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidPullRequestEventTypeException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidPullRequestEventTypeException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The pull request ID is not valid. Make sure that you have provided the full
// ID and that the pull request is in the specified repository, and then try
// again.
type InvalidPullRequestIdException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidPullRequestIdException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidPullRequestIdException) GoString() string {
	return s.String()
}

func newErrorInvalidPullRequestIdException(v protocol.ResponseMetadata) error {
	return &InvalidPullRequestIdException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidPullRequestIdException) Code() string {
	return "InvalidPullRequestIdException"
}

// Message returns the exception's message.
func (s *InvalidPullRequestIdException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidPullRequestIdException) OrigErr() error {
	return nil
}

func (s *InvalidPullRequestIdException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidPullRequestIdException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidPullRequestIdException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The pull request status is not valid. The only valid values are OPEN and
// CLOSED.
type InvalidPullRequestStatusException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidPullRequestStatusException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidPullRequestStatusException) GoString() string {
	return s.String()
}

func newErrorInvalidPullRequestStatusException(v protocol.ResponseMetadata) error {
	return &InvalidPullRequestStatusException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidPullRequestStatusException) Code() string {
	return "InvalidPullRequestStatusException"
}

// Message returns the exception's message.
func (s *InvalidPullRequestStatusException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidPullRequestStatusException) OrigErr() error {
	return nil
}

func (s *InvalidPullRequestStatusException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidPullRequestStatusException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidPullRequestStatusException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The pull request status update is not valid. The only valid update is from
// OPEN to CLOSED.
type InvalidPullRequestStatusUpdateException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidPullRequestStatusUpdateException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidPullRequestStatusUpdateException) GoString() string {
	return s.String()
}

func newErrorInvalidPullRequestStatusUpdateException(v protocol.ResponseMetadata) error {
	return &InvalidPullRequestStatusUpdateException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidPullRequestStatusUpdateException) Code() string {
	return "InvalidPullRequestStatusUpdateException"
}

// Message returns the exception's message.
func (s *InvalidPullRequestStatusUpdateException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidPullRequestStatusUpdateException) OrigErr() error {
	return nil
}

func (s *InvalidPullRequestStatusUpdateException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidPullRequestStatusUpdateException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidPullRequestStatusUpdateException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The Amazon Resource Name (ARN) of the user or identity is not valid.
type InvalidReactionUserArnException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidReactionUserArnException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidReactionUserArnException) GoString() string {
	return s.String()
}

func newErrorInvalidReactionUserArnException(v protocol.ResponseMetadata) error {
	return &InvalidReactionUserArnException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidReactionUserArnException) Code() string {
	return "InvalidReactionUserArnException"
}

// Message returns the exception's message.
func (s *InvalidReactionUserArnException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidReactionUserArnException) OrigErr() error {
	return nil
}

func (s *InvalidReactionUserArnException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidReactionUserArnException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidReactionUserArnException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The value of the reaction is not valid. For more information, see the AWS
// CodeCommit User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/welcome.html).
type InvalidReactionValueException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidReactionValueException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidReactionValueException) GoString() string {
	return s.String()
}

func newErrorInvalidReactionValueException(v protocol.ResponseMetadata) error {
	return &InvalidReactionValueException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidReactionValueException) Code() string {
	return "InvalidReactionValueException"
}

// Message returns the exception's message.
func (s *InvalidReactionValueException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidReactionValueException) OrigErr() error {
	return nil
}

func (s *InvalidReactionValueException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidReactionValueException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidReactionValueException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified reference name format is not valid. Reference names must conform
// to the Git references format (for example, refs/heads/master). For more information,
// see Git Internals - Git References (https://git-scm.com/book/en/v2/Git-Internals-Git-References)
// or consult your Git documentation.
type InvalidReferenceNameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidReferenceNameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidReferenceNameException) GoString() string {
	return s.String()
}

func newErrorInvalidReferenceNameException(v protocol.ResponseMetadata) error {
	return &InvalidReferenceNameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidReferenceNameException) Code() string {
	return "InvalidReferenceNameException"
}

// Message returns the exception's message.
func (s *InvalidReferenceNameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidReferenceNameException) OrigErr() error {
	return nil
}

func (s *InvalidReferenceNameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidReferenceNameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidReferenceNameException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Either the enum is not in a valid format, or the specified file version enum
// is not valid in respect to the current file version.
type InvalidRelativeFileVersionEnumException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidRelativeFileVersionEnumException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidRelativeFileVersionEnumException) GoString() string {
	return s.String()
}

func newErrorInvalidRelativeFileVersionEnumException(v protocol.ResponseMetadata) error {
	return &InvalidRelativeFileVersionEnumException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidRelativeFileVersionEnumException) Code() string {
	return "InvalidRelativeFileVersionEnumException"
}

// Message returns the exception's message.
func (s *InvalidRelativeFileVersionEnumException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidRelativeFileVersionEnumException) OrigErr() error {
	return nil
}

func (s *InvalidRelativeFileVersionEnumException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidRelativeFileVersionEnumException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidRelativeFileVersionEnumException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Automerge was specified for resolving the conflict, but the replacement type
// is not valid or content is missing.
type InvalidReplacementContentException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidReplacementContentException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidReplacementContentException) GoString() string {
	return s.String()
}

func newErrorInvalidReplacementContentException(v protocol.ResponseMetadata) error {
	return &InvalidReplacementContentException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidReplacementContentException) Code() string {
	return "InvalidReplacementContentException"
}

// Message returns the exception's message.
func (s *InvalidReplacementContentException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidReplacementContentException) OrigErr() error {
	return nil
}

func (s *InvalidReplacementContentException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidReplacementContentException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidReplacementContentException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Automerge was specified for resolving the conflict, but the specified replacement
// type is not valid.
type InvalidReplacementTypeException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidReplacementTypeException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidReplacementTypeException) GoString() string {
	return s.String()
}

func newErrorInvalidReplacementTypeException(v protocol.ResponseMetadata) error {
	return &InvalidReplacementTypeException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidReplacementTypeException) Code() string {
	return "InvalidReplacementTypeException"
}

// Message returns the exception's message.
func (s *InvalidReplacementTypeException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidReplacementTypeException) OrigErr() error {
	return nil
}

func (s *InvalidReplacementTypeException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidReplacementTypeException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidReplacementTypeException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified repository description is not valid.
type InvalidRepositoryDescriptionException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidRepositoryDescriptionException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidRepositoryDescriptionException) GoString() string {
	return s.String()
}

func newErrorInvalidRepositoryDescriptionException(v protocol.ResponseMetadata) error {
	return &InvalidRepositoryDescriptionException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidRepositoryDescriptionException) Code() string {
	return "InvalidRepositoryDescriptionException"
}

// Message returns the exception's message.
func (s *InvalidRepositoryDescriptionException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidRepositoryDescriptionException) OrigErr() error {
	return nil
}

func (s *InvalidRepositoryDescriptionException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidRepositoryDescriptionException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidRepositoryDescriptionException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A specified repository name is not valid.
//
// This exception occurs only when a specified repository name is not valid.
// Other exceptions occur when a required repository parameter is missing, or
// when a specified repository does not exist.
type InvalidRepositoryNameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidRepositoryNameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidRepositoryNameException) GoString() string {
	return s.String()
}

func newErrorInvalidRepositoryNameException(v protocol.ResponseMetadata) error {
	return &InvalidRepositoryNameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidRepositoryNameException) Code() string {
	return "InvalidRepositoryNameException"
}

// Message returns the exception's message.
func (s *InvalidRepositoryNameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidRepositoryNameException) OrigErr() error {
	return nil
}

func (s *InvalidRepositoryNameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidRepositoryNameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidRepositoryNameException) RequestID() string {
	return s.RespMetadata.RequestID
}

// One or more branch names specified for the trigger is not valid.
type InvalidRepositoryTriggerBranchNameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidRepositoryTriggerBranchNameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidRepositoryTriggerBranchNameException) GoString() string {
	return s.String()
}

func newErrorInvalidRepositoryTriggerBranchNameException(v protocol.ResponseMetadata) error {
	return &InvalidRepositoryTriggerBranchNameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidRepositoryTriggerBranchNameException) Code() string {
	return "InvalidRepositoryTriggerBranchNameException"
}

// Message returns the exception's message.
func (s *InvalidRepositoryTriggerBranchNameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidRepositoryTriggerBranchNameException) OrigErr() error {
	return nil
}

func (s *InvalidRepositoryTriggerBranchNameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidRepositoryTriggerBranchNameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidRepositoryTriggerBranchNameException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The custom data provided for the trigger is not valid.
type InvalidRepositoryTriggerCustomDataException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidRepositoryTriggerCustomDataException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidRepositoryTriggerCustomDataException) GoString() string {
	return s.String()
}

func newErrorInvalidRepositoryTriggerCustomDataException(v protocol.ResponseMetadata) error {
	return &InvalidRepositoryTriggerCustomDataException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidRepositoryTriggerCustomDataException) Code() string {
	return "InvalidRepositoryTriggerCustomDataException"
}

// Message returns the exception's message.
func (s *InvalidRepositoryTriggerCustomDataException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidRepositoryTriggerCustomDataException) OrigErr() error {
	return nil
}

func (s *InvalidRepositoryTriggerCustomDataException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidRepositoryTriggerCustomDataException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidRepositoryTriggerCustomDataException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The Amazon Resource Name (ARN) for the trigger is not valid for the specified
// destination. The most common reason for this error is that the ARN does not
// meet the requirements for the service type.
type InvalidRepositoryTriggerDestinationArnException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidRepositoryTriggerDestinationArnException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidRepositoryTriggerDestinationArnException) GoString() string {
	return s.String()
}

func newErrorInvalidRepositoryTriggerDestinationArnException(v protocol.ResponseMetadata) error {
	return &InvalidRepositoryTriggerDestinationArnException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidRepositoryTriggerDestinationArnException) Code() string {
	return "InvalidRepositoryTriggerDestinationArnException"
}

// Message returns the exception's message.
func (s *InvalidRepositoryTriggerDestinationArnException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidRepositoryTriggerDestinationArnException) OrigErr() error {
	return nil
}

func (s *InvalidRepositoryTriggerDestinationArnException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidRepositoryTriggerDestinationArnException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidRepositoryTriggerDestinationArnException) RequestID() string {
	return s.RespMetadata.RequestID
}

// One or more events specified for the trigger is not valid. Check to make
// sure that all events specified match the requirements for allowed events.
type InvalidRepositoryTriggerEventsException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidRepositoryTriggerEventsException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidRepositoryTriggerEventsException) GoString() string {
	return s.String()
}

func newErrorInvalidRepositoryTriggerEventsException(v protocol.ResponseMetadata) error {
	return &InvalidRepositoryTriggerEventsException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidRepositoryTriggerEventsException) Code() string {
	return "InvalidRepositoryTriggerEventsException"
}

// Message returns the exception's message.
func (s *InvalidRepositoryTriggerEventsException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidRepositoryTriggerEventsException) OrigErr() error {
	return nil
}

func (s *InvalidRepositoryTriggerEventsException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidRepositoryTriggerEventsException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidRepositoryTriggerEventsException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The name of the trigger is not valid.
type InvalidRepositoryTriggerNameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidRepositoryTriggerNameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidRepositoryTriggerNameException) GoString() string {
	return s.String()
}

func newErrorInvalidRepositoryTriggerNameException(v protocol.ResponseMetadata) error {
	return &InvalidRepositoryTriggerNameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidRepositoryTriggerNameException) Code() string {
	return "InvalidRepositoryTriggerNameException"
}

// Message returns the exception's message.
func (s *InvalidRepositoryTriggerNameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidRepositoryTriggerNameException) OrigErr() error {
	return nil
}

func (s *InvalidRepositoryTriggerNameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidRepositoryTriggerNameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidRepositoryTriggerNameException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The AWS Region for the trigger target does not match the AWS Region for the
// repository. Triggers must be created in the same Region as the target for
// the trigger.
type InvalidRepositoryTriggerRegionException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidRepositoryTriggerRegionException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidRepositoryTriggerRegionException) GoString() string {
	return s.String()
}

func newErrorInvalidRepositoryTriggerRegionException(v protocol.ResponseMetadata) error {
	return &InvalidRepositoryTriggerRegionException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidRepositoryTriggerRegionException) Code() string {
	return "InvalidRepositoryTriggerRegionException"
}

// Message returns the exception's message.
func (s *InvalidRepositoryTriggerRegionException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidRepositoryTriggerRegionException) OrigErr() error {
	return nil
}

func (s *InvalidRepositoryTriggerRegionException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidRepositoryTriggerRegionException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidRepositoryTriggerRegionException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The value for the resource ARN is not valid. For more information about resources
// in AWS CodeCommit, see CodeCommit Resources and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
// in the AWS CodeCommit User Guide.
type InvalidResourceArnException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidResourceArnException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidResourceArnException) GoString() string {
	return s.String()
}

func newErrorInvalidResourceArnException(v protocol.ResponseMetadata) error {
	return &InvalidResourceArnException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidResourceArnException) Code() string {
	return "InvalidResourceArnException"
}

// Message returns the exception's message.
func (s *InvalidResourceArnException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidResourceArnException) OrigErr() error {
	return nil
}

func (s *InvalidResourceArnException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidResourceArnException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidResourceArnException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The revision ID is not valid. Use GetPullRequest to determine the value.
type InvalidRevisionIdException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidRevisionIdException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidRevisionIdException) GoString() string {
	return s.String()
}

func newErrorInvalidRevisionIdException(v protocol.ResponseMetadata) error {
	return &InvalidRevisionIdException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidRevisionIdException) Code() string {
	return "InvalidRevisionIdException"
}

// Message returns the exception's message.
func (s *InvalidRevisionIdException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidRevisionIdException) OrigErr() error {
	return nil
}

func (s *InvalidRevisionIdException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidRevisionIdException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidRevisionIdException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The SHA-256 hash signature for the rule content is not valid.
type InvalidRuleContentSha256Exception struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidRuleContentSha256Exception) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidRuleContentSha256Exception) GoString() string {
	return s.String()
}

func newErrorInvalidRuleContentSha256Exception(v protocol.ResponseMetadata) error {
	return &InvalidRuleContentSha256Exception{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidRuleContentSha256Exception) Code() string {
	return "InvalidRuleContentSha256Exception"
}

// Message returns the exception's message.
func (s *InvalidRuleContentSha256Exception) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidRuleContentSha256Exception) OrigErr() error {
	return nil
}

func (s *InvalidRuleContentSha256Exception) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidRuleContentSha256Exception) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidRuleContentSha256Exception) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified sort by value is not valid.
type InvalidSortByException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidSortByException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidSortByException) GoString() string {
	return s.String()
}

func newErrorInvalidSortByException(v protocol.ResponseMetadata) error {
	return &InvalidSortByException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidSortByException) Code() string {
	return "InvalidSortByException"
}

// Message returns the exception's message.
func (s *InvalidSortByException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidSortByException) OrigErr() error {
	return nil
}

func (s *InvalidSortByException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidSortByException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidSortByException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The source commit specifier is not valid. You must provide a valid branch
// name, tag, or full commit ID.
type InvalidSourceCommitSpecifierException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidSourceCommitSpecifierException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidSourceCommitSpecifierException) GoString() string {
	return s.String()
}

func newErrorInvalidSourceCommitSpecifierException(v protocol.ResponseMetadata) error {
	return &InvalidSourceCommitSpecifierException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidSourceCommitSpecifierException) Code() string {
	return "InvalidSourceCommitSpecifierException"
}

// Message returns the exception's message.
func (s *InvalidSourceCommitSpecifierException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidSourceCommitSpecifierException) OrigErr() error {
	return nil
}

func (s *InvalidSourceCommitSpecifierException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidSourceCommitSpecifierException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidSourceCommitSpecifierException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified tag is not valid. Key names cannot be prefixed with aws:.
type InvalidSystemTagUsageException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidSystemTagUsageException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidSystemTagUsageException) GoString() string {
	return s.String()
}

func newErrorInvalidSystemTagUsageException(v protocol.ResponseMetadata) error {
	return &InvalidSystemTagUsageException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidSystemTagUsageException) Code() string {
	return "InvalidSystemTagUsageException"
}

// Message returns the exception's message.
func (s *InvalidSystemTagUsageException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidSystemTagUsageException) OrigErr() error {
	return nil
}

func (s *InvalidSystemTagUsageException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidSystemTagUsageException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidSystemTagUsageException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The list of tags is not valid.
type InvalidTagKeysListException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidTagKeysListException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidTagKeysListException) GoString() string {
	return s.String()
}

func newErrorInvalidTagKeysListException(v protocol.ResponseMetadata) error {
	return &InvalidTagKeysListException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidTagKeysListException) Code() string {
	return "InvalidTagKeysListException"
}

// Message returns the exception's message.
func (s *InvalidTagKeysListException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidTagKeysListException) OrigErr() error {
	return nil
}

func (s *InvalidTagKeysListException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidTagKeysListException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidTagKeysListException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The map of tags is not valid.
type InvalidTagsMapException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidTagsMapException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidTagsMapException) GoString() string {
	return s.String()
}

func newErrorInvalidTagsMapException(v protocol.ResponseMetadata) error {
	return &InvalidTagsMapException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidTagsMapException) Code() string {
	return "InvalidTagsMapException"
}

// Message returns the exception's message.
func (s *InvalidTagsMapException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidTagsMapException) OrigErr() error {
	return nil
}

func (s *InvalidTagsMapException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidTagsMapException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidTagsMapException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified target branch is not valid.
type InvalidTargetBranchException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidTargetBranchException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidTargetBranchException) GoString() string {
	return s.String()
}

func newErrorInvalidTargetBranchException(v protocol.ResponseMetadata) error {
	return &InvalidTargetBranchException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidTargetBranchException) Code() string {
	return "InvalidTargetBranchException"
}

// Message returns the exception's message.
func (s *InvalidTargetBranchException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidTargetBranchException) OrigErr() error {
	return nil
}

func (s *InvalidTargetBranchException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidTargetBranchException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidTargetBranchException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The target for the pull request is not valid. A target must contain the full
// values for the repository name, source branch, and destination branch for
// the pull request.
type InvalidTargetException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidTargetException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidTargetException) GoString() string {
	return s.String()
}

func newErrorInvalidTargetException(v protocol.ResponseMetadata) error {
	return &InvalidTargetException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidTargetException) Code() string {
	return "InvalidTargetException"
}

// Message returns the exception's message.
func (s *InvalidTargetException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidTargetException) OrigErr() error {
	return nil
}

func (s *InvalidTargetException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidTargetException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidTargetException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The targets for the pull request is not valid or not in a valid format. Targets
// are a list of target objects. Each target object must contain the full values
// for the repository name, source branch, and destination branch for a pull
// request.
type InvalidTargetsException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidTargetsException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidTargetsException) GoString() string {
	return s.String()
}

func newErrorInvalidTargetsException(v protocol.ResponseMetadata) error {
	return &InvalidTargetsException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidTargetsException) Code() string {
	return "InvalidTargetsException"
}

// Message returns the exception's message.
func (s *InvalidTargetsException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidTargetsException) OrigErr() error {
	return nil
}

func (s *InvalidTargetsException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidTargetsException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidTargetsException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The title of the pull request is not valid. Pull request titles cannot exceed
// 100 characters in length.
type InvalidTitleException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s InvalidTitleException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s InvalidTitleException) GoString() string {
	return s.String()
}

func newErrorInvalidTitleException(v protocol.ResponseMetadata) error {
	return &InvalidTitleException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *InvalidTitleException) Code() string {
	return "InvalidTitleException"
}

// Message returns the exception's message.
func (s *InvalidTitleException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *InvalidTitleException) OrigErr() error {
	return nil
}

func (s *InvalidTitleException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *InvalidTitleException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *InvalidTitleException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about whether a file is binary or textual in a merge or pull
// request operation.
type IsBinaryFile struct {
	_ struct{} `type:"structure"`

	// The binary or non-binary status of a file in the base of a merge or pull
	// request.
	Base *bool `locationName:"base" type:"boolean"`

	// The binary or non-binary status of a file in the destination of a merge or
	// pull request.
	Destination *bool `locationName:"destination" type:"boolean"`

	// The binary or non-binary status of file in the source of a merge or pull
	// request.
	Source *bool `locationName:"source" type:"boolean"`
}

// String returns the string representation
func (s IsBinaryFile) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s IsBinaryFile) GoString() string {
	return s.String()
}

// SetBase sets the Base field's value.
func (s *IsBinaryFile) SetBase(v bool) *IsBinaryFile {
	s.Base = &v
	return s
}

// SetDestination sets the Destination field's value.
func (s *IsBinaryFile) SetDestination(v bool) *IsBinaryFile {
	s.Destination = &v
	return s
}

// SetSource sets the Source field's value.
func (s *IsBinaryFile) SetSource(v bool) *IsBinaryFile {
	s.Source = &v
	return s
}

type ListApprovalRuleTemplatesInput struct {
	_ struct{} `type:"structure"`

	// A non-zero, non-negative integer used to limit the number of returned results.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListApprovalRuleTemplatesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListApprovalRuleTemplatesInput) GoString() string {
	return s.String()
}

// SetMaxResults sets the MaxResults field's value.
func (s *ListApprovalRuleTemplatesInput) SetMaxResults(v int64) *ListApprovalRuleTemplatesInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *ListApprovalRuleTemplatesInput) SetNextToken(v string) *ListApprovalRuleTemplatesInput {
	s.NextToken = &v
	return s
}

type ListApprovalRuleTemplatesOutput struct {
	_ struct{} `type:"structure"`

	// The names of all the approval rule templates found in the AWS Region for
	// your AWS account.
	ApprovalRuleTemplateNames []*string `locationName:"approvalRuleTemplateNames" type:"list"`

	// An enumeration token that allows the operation to batch the next results
	// of the operation.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListApprovalRuleTemplatesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListApprovalRuleTemplatesOutput) GoString() string {
	return s.String()
}

// SetApprovalRuleTemplateNames sets the ApprovalRuleTemplateNames field's value.
func (s *ListApprovalRuleTemplatesOutput) SetApprovalRuleTemplateNames(v []*string) *ListApprovalRuleTemplatesOutput {
	s.ApprovalRuleTemplateNames = v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *ListApprovalRuleTemplatesOutput) SetNextToken(v string) *ListApprovalRuleTemplatesOutput {
	s.NextToken = &v
	return s
}

type ListAssociatedApprovalRuleTemplatesForRepositoryInput struct {
	_ struct{} `type:"structure"`

	// A non-zero, non-negative integer used to limit the number of returned results.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The name of the repository for which you want to list all associated approval
	// rule templates.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ListAssociatedApprovalRuleTemplatesForRepositoryInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAssociatedApprovalRuleTemplatesForRepositoryInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListAssociatedApprovalRuleTemplatesForRepositoryInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "ListAssociatedApprovalRuleTemplatesForRepositoryInput"}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetMaxResults sets the MaxResults field's value.
func (s *ListAssociatedApprovalRuleTemplatesForRepositoryInput) SetMaxResults(v int64) *ListAssociatedApprovalRuleTemplatesForRepositoryInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *ListAssociatedApprovalRuleTemplatesForRepositoryInput) SetNextToken(v string) *ListAssociatedApprovalRuleTemplatesForRepositoryInput {
	s.NextToken = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *ListAssociatedApprovalRuleTemplatesForRepositoryInput) SetRepositoryName(v string) *ListAssociatedApprovalRuleTemplatesForRepositoryInput {
	s.RepositoryName = &v
	return s
}

type ListAssociatedApprovalRuleTemplatesForRepositoryOutput struct {
	_ struct{} `type:"structure"`

	// The names of all approval rule templates associated with the repository.
	ApprovalRuleTemplateNames []*string `locationName:"approvalRuleTemplateNames" type:"list"`

	// An enumeration token that allows the operation to batch the next results
	// of the operation.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListAssociatedApprovalRuleTemplatesForRepositoryOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListAssociatedApprovalRuleTemplatesForRepositoryOutput) GoString() string {
	return s.String()
}

// SetApprovalRuleTemplateNames sets the ApprovalRuleTemplateNames field's value.
func (s *ListAssociatedApprovalRuleTemplatesForRepositoryOutput) SetApprovalRuleTemplateNames(v []*string) *ListAssociatedApprovalRuleTemplatesForRepositoryOutput {
	s.ApprovalRuleTemplateNames = v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *ListAssociatedApprovalRuleTemplatesForRepositoryOutput) SetNextToken(v string) *ListAssociatedApprovalRuleTemplatesForRepositoryOutput {
	s.NextToken = &v
	return s
}

// Represents the input of a list branches operation.
type ListBranchesInput struct {
	_ struct{} `type:"structure"`

	// An enumeration token that allows the operation to batch the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The name of the repository that contains the branches.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ListBranchesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBranchesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListBranchesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "ListBranchesInput"}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetNextToken sets the NextToken field's value.
func (s *ListBranchesInput) SetNextToken(v string) *ListBranchesInput {
	s.NextToken = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *ListBranchesInput) SetRepositoryName(v string) *ListBranchesInput {
	s.RepositoryName = &v
	return s
}

// Represents the output of a list branches operation.
type ListBranchesOutput struct {
	_ struct{} `type:"structure"`

	// The list of branch names.
	Branches []*string `locationName:"branches" type:"list"`

	// An enumeration token that returns the batch of the results.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListBranchesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListBranchesOutput) GoString() string {
	return s.String()
}

// SetBranches sets the Branches field's value.
func (s *ListBranchesOutput) SetBranches(v []*string) *ListBranchesOutput {
	s.Branches = v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *ListBranchesOutput) SetNextToken(v string) *ListBranchesOutput {
	s.NextToken = &v
	return s
}

type ListPullRequestsInput struct {
	_ struct{} `type:"structure"`

	// Optional. The Amazon Resource Name (ARN) of the user who created the pull
	// request. If used, this filters the results to pull requests created by that
	// user.
	AuthorArn *string `locationName:"authorArn" type:"string"`

	// A non-zero, non-negative integer used to limit the number of returned results.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// Optional. The status of the pull request. If used, this refines the results
	// to the pull requests that match the specified status.
	PullRequestStatus *string `locationName:"pullRequestStatus" type:"string" enum:"PullRequestStatusEnum"`

	// The name of the repository for which you want to list pull requests.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s ListPullRequestsInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPullRequestsInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListPullRequestsInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "ListPullRequestsInput"}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAuthorArn sets the AuthorArn field's value.
func (s *ListPullRequestsInput) SetAuthorArn(v string) *ListPullRequestsInput {
	s.AuthorArn = &v
	return s
}

// SetMaxResults sets the MaxResults field's value.
func (s *ListPullRequestsInput) SetMaxResults(v int64) *ListPullRequestsInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *ListPullRequestsInput) SetNextToken(v string) *ListPullRequestsInput {
	s.NextToken = &v
	return s
}

// SetPullRequestStatus sets the PullRequestStatus field's value.
func (s *ListPullRequestsInput) SetPullRequestStatus(v string) *ListPullRequestsInput {
	s.PullRequestStatus = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *ListPullRequestsInput) SetRepositoryName(v string) *ListPullRequestsInput {
	s.RepositoryName = &v
	return s
}

type ListPullRequestsOutput struct {
	_ struct{} `type:"structure"`

	// An enumeration token that allows the operation to batch the next results
	// of the operation.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The system-generated IDs of the pull requests.
	//
	// PullRequestIds is a required field
	PullRequestIds []*string `locationName:"pullRequestIds" type:"list" required:"true"`
}

// String returns the string representation
func (s ListPullRequestsOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListPullRequestsOutput) GoString() string {
	return s.String()
}

// SetNextToken sets the NextToken field's value.
func (s *ListPullRequestsOutput) SetNextToken(v string) *ListPullRequestsOutput {
	s.NextToken = &v
	return s
}

// SetPullRequestIds sets the PullRequestIds field's value.
func (s *ListPullRequestsOutput) SetPullRequestIds(v []*string) *ListPullRequestsOutput {
	s.PullRequestIds = v
	return s
}

type ListRepositoriesForApprovalRuleTemplateInput struct {
	_ struct{} `type:"structure"`

	// The name of the approval rule template for which you want to list repositories
	// that are associated with that template.
	//
	// ApprovalRuleTemplateName is a required field
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string" required:"true"`

	// A non-zero, non-negative integer used to limit the number of returned results.
	MaxResults *int64 `locationName:"maxResults" type:"integer"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`
}

// String returns the string representation
func (s ListRepositoriesForApprovalRuleTemplateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRepositoriesForApprovalRuleTemplateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListRepositoriesForApprovalRuleTemplateInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "ListRepositoriesForApprovalRuleTemplateInput"}
	if s.ApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateName"))
	}
	if s.ApprovalRuleTemplateName != nil && len(*s.ApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleTemplateName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *ListRepositoriesForApprovalRuleTemplateInput) SetApprovalRuleTemplateName(v string) *ListRepositoriesForApprovalRuleTemplateInput {
	s.ApprovalRuleTemplateName = &v
	return s
}

// SetMaxResults sets the MaxResults field's value.
func (s *ListRepositoriesForApprovalRuleTemplateInput) SetMaxResults(v int64) *ListRepositoriesForApprovalRuleTemplateInput {
	s.MaxResults = &v
	return s
}

// SetNextToken sets the NextToken field's value.
func (s *ListRepositoriesForApprovalRuleTemplateInput) SetNextToken(v string) *ListRepositoriesForApprovalRuleTemplateInput {
	s.NextToken = &v
	return s
}

type ListRepositoriesForApprovalRuleTemplateOutput struct {
	_ struct{} `type:"structure"`

	// An enumeration token that allows the operation to batch the next results
	// of the operation.
	NextToken *string `locationName:"nextToken" type:"string"`

	// A list of repository names that are associated with the specified approval
	// rule template.
	RepositoryNames []*string `locationName:"repositoryNames" type:"list"`
}

// String returns the string representation
func (s ListRepositoriesForApprovalRuleTemplateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRepositoriesForApprovalRuleTemplateOutput) GoString() string {
	return s.String()
}

// SetNextToken sets the NextToken field's value.
func (s *ListRepositoriesForApprovalRuleTemplateOutput) SetNextToken(v string) *ListRepositoriesForApprovalRuleTemplateOutput {
	s.NextToken = &v
	return s
}

// SetRepositoryNames sets the RepositoryNames field's value.
func (s *ListRepositoriesForApprovalRuleTemplateOutput) SetRepositoryNames(v []*string) *ListRepositoriesForApprovalRuleTemplateOutput {
	s.RepositoryNames = v
	return s
}

// Represents the input of a list repositories operation.
type ListRepositoriesInput struct {
	_ struct{} `type:"structure"`

	// An enumeration token that allows the operation to batch the results of the
	// operation. Batch sizes are 1,000 for list repository operations. When the
	// client sends the token back to AWS CodeCommit, another page of 1,000 records
	// is retrieved.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The order in which to sort the results of a list repositories operation.
	Order *string `locationName:"order" type:"string" enum:"OrderEnum"`

	// The criteria used to sort the results of a list repositories operation.
	SortBy *string `locationName:"sortBy" type:"string" enum:"SortByEnum"`
}

// String returns the string representation
func (s ListRepositoriesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRepositoriesInput) GoString() string {
	return s.String()
}

// SetNextToken sets the NextToken field's value.
func (s *ListRepositoriesInput) SetNextToken(v string) *ListRepositoriesInput {
	s.NextToken = &v
	return s
}

// SetOrder sets the Order field's value.
func (s *ListRepositoriesInput) SetOrder(v string) *ListRepositoriesInput {
	s.Order = &v
	return s
}

// SetSortBy sets the SortBy field's value.
func (s *ListRepositoriesInput) SetSortBy(v string) *ListRepositoriesInput {
	s.SortBy = &v
	return s
}

// Represents the output of a list repositories operation.
type ListRepositoriesOutput struct {
	_ struct{} `type:"structure"`

	// An enumeration token that allows the operation to batch the results of the
	// operation. Batch sizes are 1,000 for list repository operations. When the
	// client sends the token back to AWS CodeCommit, another page of 1,000 records
	// is retrieved.
	NextToken *string `locationName:"nextToken" type:"string"`

	// Lists the repositories called by the list repositories operation.
	Repositories []*RepositoryNameIdPair `locationName:"repositories" type:"list"`
}

// String returns the string representation
func (s ListRepositoriesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListRepositoriesOutput) GoString() string {
	return s.String()
}

// SetNextToken sets the NextToken field's value.
func (s *ListRepositoriesOutput) SetNextToken(v string) *ListRepositoriesOutput {
	s.NextToken = &v
	return s
}

// SetRepositories sets the Repositories field's value.
func (s *ListRepositoriesOutput) SetRepositories(v []*RepositoryNameIdPair) *ListRepositoriesOutput {
	s.Repositories = v
	return s
}

type ListTagsForResourceInput struct {
	_ struct{} `type:"structure"`

	// An enumeration token that, when provided in a request, returns the next batch
	// of the results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// The Amazon Resource Name (ARN) of the resource for which you want to get
	// information about tags, if any.
	//
	// ResourceArn is a required field
	ResourceArn *string `locationName:"resourceArn" type:"string" required:"true"`
}

// String returns the string representation
func (s ListTagsForResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsForResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ListTagsForResourceInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "ListTagsForResourceInput"}
	if s.ResourceArn == nil {
		invalidParams.Add(request.NewErrParamRequired("ResourceArn"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetNextToken sets the NextToken field's value.
func (s *ListTagsForResourceInput) SetNextToken(v string) *ListTagsForResourceInput {
	s.NextToken = &v
	return s
}

// SetResourceArn sets the ResourceArn field's value.
func (s *ListTagsForResourceInput) SetResourceArn(v string) *ListTagsForResourceInput {
	s.ResourceArn = &v
	return s
}

type ListTagsForResourceOutput struct {
	_ struct{} `type:"structure"`

	// An enumeration token that allows the operation to batch the next results
	// of the operation.
	NextToken *string `locationName:"nextToken" type:"string"`

	// A list of tag key and value pairs associated with the specified resource.
	Tags map[string]*string `locationName:"tags" type:"map"`
}

// String returns the string representation
func (s ListTagsForResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ListTagsForResourceOutput) GoString() string {
	return s.String()
}

// SetNextToken sets the NextToken field's value.
func (s *ListTagsForResourceOutput) SetNextToken(v string) *ListTagsForResourceOutput {
	s.NextToken = &v
	return s
}

// SetTags sets the Tags field's value.
func (s *ListTagsForResourceOutput) SetTags(v map[string]*string) *ListTagsForResourceOutput {
	s.Tags = v
	return s
}

// Returns information about the location of a change or comment in the comparison
// between two commits or a pull request.
type Location struct {
	_ struct{} `type:"structure"`

	// The name of the file being compared, including its extension and subdirectory,
	// if any.
	FilePath *string `locationName:"filePath" type:"string"`

	// The position of a change in a compared file, in line number format.
	FilePosition *int64 `locationName:"filePosition" type:"long"`

	// In a comparison of commits or a pull request, whether the change is in the
	// before or after of that comparison.
	RelativeFileVersion *string `locationName:"relativeFileVersion" type:"string" enum:"RelativeFileVersionEnum"`
}

// String returns the string representation
func (s Location) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Location) GoString() string {
	return s.String()
}

// SetFilePath sets the FilePath field's value.
func (s *Location) SetFilePath(v string) *Location {
	s.FilePath = &v
	return s
}

// SetFilePosition sets the FilePosition field's value.
func (s *Location) SetFilePosition(v int64) *Location {
	s.FilePosition = &v
	return s
}

// SetRelativeFileVersion sets the RelativeFileVersion field's value.
func (s *Location) SetRelativeFileVersion(v string) *Location {
	s.RelativeFileVersion = &v
	return s
}

// The pull request cannot be merged automatically into the destination branch.
// You must manually merge the branches and resolve any conflicts.
type ManualMergeRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ManualMergeRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ManualMergeRequiredException) GoString() string {
	return s.String()
}

func newErrorManualMergeRequiredException(v protocol.ResponseMetadata) error {
	return &ManualMergeRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ManualMergeRequiredException) Code() string {
	return "ManualMergeRequiredException"
}

// Message returns the exception's message.
func (s *ManualMergeRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ManualMergeRequiredException) OrigErr() error {
	return nil
}

func (s *ManualMergeRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ManualMergeRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ManualMergeRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The number of branches for the trigger was exceeded.
type MaximumBranchesExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MaximumBranchesExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MaximumBranchesExceededException) GoString() string {
	return s.String()
}

func newErrorMaximumBranchesExceededException(v protocol.ResponseMetadata) error {
	return &MaximumBranchesExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MaximumBranchesExceededException) Code() string {
	return "MaximumBranchesExceededException"
}

// Message returns the exception's message.
func (s *MaximumBranchesExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MaximumBranchesExceededException) OrigErr() error {
	return nil
}

func (s *MaximumBranchesExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MaximumBranchesExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MaximumBranchesExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The number of allowed conflict resolution entries was exceeded.
type MaximumConflictResolutionEntriesExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MaximumConflictResolutionEntriesExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MaximumConflictResolutionEntriesExceededException) GoString() string {
	return s.String()
}

func newErrorMaximumConflictResolutionEntriesExceededException(v protocol.ResponseMetadata) error {
	return &MaximumConflictResolutionEntriesExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MaximumConflictResolutionEntriesExceededException) Code() string {
	return "MaximumConflictResolutionEntriesExceededException"
}

// Message returns the exception's message.
func (s *MaximumConflictResolutionEntriesExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MaximumConflictResolutionEntriesExceededException) OrigErr() error {
	return nil
}

func (s *MaximumConflictResolutionEntriesExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MaximumConflictResolutionEntriesExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MaximumConflictResolutionEntriesExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The number of files to load exceeds the allowed limit.
type MaximumFileContentToLoadExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MaximumFileContentToLoadExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MaximumFileContentToLoadExceededException) GoString() string {
	return s.String()
}

func newErrorMaximumFileContentToLoadExceededException(v protocol.ResponseMetadata) error {
	return &MaximumFileContentToLoadExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MaximumFileContentToLoadExceededException) Code() string {
	return "MaximumFileContentToLoadExceededException"
}

// Message returns the exception's message.
func (s *MaximumFileContentToLoadExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MaximumFileContentToLoadExceededException) OrigErr() error {
	return nil
}

func (s *MaximumFileContentToLoadExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MaximumFileContentToLoadExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MaximumFileContentToLoadExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The number of specified files to change as part of this commit exceeds the
// maximum number of files that can be changed in a single commit. Consider
// using a Git client for these changes.
type MaximumFileEntriesExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MaximumFileEntriesExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MaximumFileEntriesExceededException) GoString() string {
	return s.String()
}

func newErrorMaximumFileEntriesExceededException(v protocol.ResponseMetadata) error {
	return &MaximumFileEntriesExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MaximumFileEntriesExceededException) Code() string {
	return "MaximumFileEntriesExceededException"
}

// Message returns the exception's message.
func (s *MaximumFileEntriesExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MaximumFileEntriesExceededException) OrigErr() error {
	return nil
}

func (s *MaximumFileEntriesExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MaximumFileEntriesExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MaximumFileEntriesExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The number of items to compare between the source or destination branches
// and the merge base has exceeded the maximum allowed.
type MaximumItemsToCompareExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MaximumItemsToCompareExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MaximumItemsToCompareExceededException) GoString() string {
	return s.String()
}

func newErrorMaximumItemsToCompareExceededException(v protocol.ResponseMetadata) error {
	return &MaximumItemsToCompareExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MaximumItemsToCompareExceededException) Code() string {
	return "MaximumItemsToCompareExceededException"
}

// Message returns the exception's message.
func (s *MaximumItemsToCompareExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MaximumItemsToCompareExceededException) OrigErr() error {
	return nil
}

func (s *MaximumItemsToCompareExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MaximumItemsToCompareExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MaximumItemsToCompareExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The number of approvals required for the approval rule exceeds the maximum
// number allowed.
type MaximumNumberOfApprovalsExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MaximumNumberOfApprovalsExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MaximumNumberOfApprovalsExceededException) GoString() string {
	return s.String()
}

func newErrorMaximumNumberOfApprovalsExceededException(v protocol.ResponseMetadata) error {
	return &MaximumNumberOfApprovalsExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MaximumNumberOfApprovalsExceededException) Code() string {
	return "MaximumNumberOfApprovalsExceededException"
}

// Message returns the exception's message.
func (s *MaximumNumberOfApprovalsExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MaximumNumberOfApprovalsExceededException) OrigErr() error {
	return nil
}

func (s *MaximumNumberOfApprovalsExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MaximumNumberOfApprovalsExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MaximumNumberOfApprovalsExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// You cannot create the pull request because the repository has too many open
// pull requests. The maximum number of open pull requests for a repository
// is 1,000. Close one or more open pull requests, and then try again.
type MaximumOpenPullRequestsExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MaximumOpenPullRequestsExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MaximumOpenPullRequestsExceededException) GoString() string {
	return s.String()
}

func newErrorMaximumOpenPullRequestsExceededException(v protocol.ResponseMetadata) error {
	return &MaximumOpenPullRequestsExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MaximumOpenPullRequestsExceededException) Code() string {
	return "MaximumOpenPullRequestsExceededException"
}

// Message returns the exception's message.
func (s *MaximumOpenPullRequestsExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MaximumOpenPullRequestsExceededException) OrigErr() error {
	return nil
}

func (s *MaximumOpenPullRequestsExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MaximumOpenPullRequestsExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MaximumOpenPullRequestsExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The maximum number of allowed repository names was exceeded. Currently, this
// number is 100.
type MaximumRepositoryNamesExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MaximumRepositoryNamesExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MaximumRepositoryNamesExceededException) GoString() string {
	return s.String()
}

func newErrorMaximumRepositoryNamesExceededException(v protocol.ResponseMetadata) error {
	return &MaximumRepositoryNamesExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MaximumRepositoryNamesExceededException) Code() string {
	return "MaximumRepositoryNamesExceededException"
}

// Message returns the exception's message.
func (s *MaximumRepositoryNamesExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MaximumRepositoryNamesExceededException) OrigErr() error {
	return nil
}

func (s *MaximumRepositoryNamesExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MaximumRepositoryNamesExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MaximumRepositoryNamesExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The number of triggers allowed for the repository was exceeded.
type MaximumRepositoryTriggersExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MaximumRepositoryTriggersExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MaximumRepositoryTriggersExceededException) GoString() string {
	return s.String()
}

func newErrorMaximumRepositoryTriggersExceededException(v protocol.ResponseMetadata) error {
	return &MaximumRepositoryTriggersExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MaximumRepositoryTriggersExceededException) Code() string {
	return "MaximumRepositoryTriggersExceededException"
}

// Message returns the exception's message.
func (s *MaximumRepositoryTriggersExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MaximumRepositoryTriggersExceededException) OrigErr() error {
	return nil
}

func (s *MaximumRepositoryTriggersExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MaximumRepositoryTriggersExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MaximumRepositoryTriggersExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The maximum number of approval rule templates for a repository has been exceeded.
// You cannot associate more than 25 approval rule templates with a repository.
type MaximumRuleTemplatesAssociatedWithRepositoryException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MaximumRuleTemplatesAssociatedWithRepositoryException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MaximumRuleTemplatesAssociatedWithRepositoryException) GoString() string {
	return s.String()
}

func newErrorMaximumRuleTemplatesAssociatedWithRepositoryException(v protocol.ResponseMetadata) error {
	return &MaximumRuleTemplatesAssociatedWithRepositoryException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MaximumRuleTemplatesAssociatedWithRepositoryException) Code() string {
	return "MaximumRuleTemplatesAssociatedWithRepositoryException"
}

// Message returns the exception's message.
func (s *MaximumRuleTemplatesAssociatedWithRepositoryException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MaximumRuleTemplatesAssociatedWithRepositoryException) OrigErr() error {
	return nil
}

func (s *MaximumRuleTemplatesAssociatedWithRepositoryException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MaximumRuleTemplatesAssociatedWithRepositoryException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MaximumRuleTemplatesAssociatedWithRepositoryException) RequestID() string {
	return s.RespMetadata.RequestID
}

type MergeBranchesByFastForwardInput struct {
	_ struct{} `type:"structure"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// DestinationCommitSpecifier is a required field
	DestinationCommitSpecifier *string `locationName:"destinationCommitSpecifier" type:"string" required:"true"`

	// The name of the repository where you want to merge two branches.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// SourceCommitSpecifier is a required field
	SourceCommitSpecifier *string `locationName:"sourceCommitSpecifier" type:"string" required:"true"`

	// The branch where the merge is applied.
	TargetBranch *string `locationName:"targetBranch" min:"1" type:"string"`
}

// String returns the string representation
func (s MergeBranchesByFastForwardInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergeBranchesByFastForwardInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *MergeBranchesByFastForwardInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "MergeBranchesByFastForwardInput"}
	if s.DestinationCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("DestinationCommitSpecifier"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.SourceCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("SourceCommitSpecifier"))
	}
	if s.TargetBranch != nil && len(*s.TargetBranch) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("TargetBranch", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetDestinationCommitSpecifier sets the DestinationCommitSpecifier field's value.
func (s *MergeBranchesByFastForwardInput) SetDestinationCommitSpecifier(v string) *MergeBranchesByFastForwardInput {
	s.DestinationCommitSpecifier = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *MergeBranchesByFastForwardInput) SetRepositoryName(v string) *MergeBranchesByFastForwardInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitSpecifier sets the SourceCommitSpecifier field's value.
func (s *MergeBranchesByFastForwardInput) SetSourceCommitSpecifier(v string) *MergeBranchesByFastForwardInput {
	s.SourceCommitSpecifier = &v
	return s
}

// SetTargetBranch sets the TargetBranch field's value.
func (s *MergeBranchesByFastForwardInput) SetTargetBranch(v string) *MergeBranchesByFastForwardInput {
	s.TargetBranch = &v
	return s
}

type MergeBranchesByFastForwardOutput struct {
	_ struct{} `type:"structure"`

	// The commit ID of the merge in the destination or target branch.
	CommitId *string `locationName:"commitId" type:"string"`

	// The tree ID of the merge in the destination or target branch.
	TreeId *string `locationName:"treeId" type:"string"`
}

// String returns the string representation
func (s MergeBranchesByFastForwardOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergeBranchesByFastForwardOutput) GoString() string {
	return s.String()
}

// SetCommitId sets the CommitId field's value.
func (s *MergeBranchesByFastForwardOutput) SetCommitId(v string) *MergeBranchesByFastForwardOutput {
	s.CommitId = &v
	return s
}

// SetTreeId sets the TreeId field's value.
func (s *MergeBranchesByFastForwardOutput) SetTreeId(v string) *MergeBranchesByFastForwardOutput {
	s.TreeId = &v
	return s
}

type MergeBranchesBySquashInput struct {
	_ struct{} `type:"structure"`

	// The name of the author who created the commit. This information is used as
	// both the author and committer for the commit.
	AuthorName *string `locationName:"authorName" type:"string"`

	// The commit message for the merge.
	CommitMessage *string `locationName:"commitMessage" type:"string"`

	// The level of conflict detail to use. If unspecified, the default FILE_LEVEL
	// is used, which returns a not-mergeable result if the same file has differences
	// in both branches. If LINE_LEVEL is specified, a conflict is considered not
	// mergeable if the same file in both branches has differences on the same line.
	ConflictDetailLevel *string `locationName:"conflictDetailLevel" type:"string" enum:"ConflictDetailLevelTypeEnum"`

	// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use
	// when resolving conflicts during a merge.
	ConflictResolution *ConflictResolution `locationName:"conflictResolution" type:"structure"`

	// Specifies which branch to use when resolving conflicts, or whether to attempt
	// automatically merging two versions of a file. The default is NONE, which
	// requires any conflicts to be resolved manually before the merge operation
	// is successful.
	ConflictResolutionStrategy *string `locationName:"conflictResolutionStrategy" type:"string" enum:"ConflictResolutionStrategyTypeEnum"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// DestinationCommitSpecifier is a required field
	DestinationCommitSpecifier *string `locationName:"destinationCommitSpecifier" type:"string" required:"true"`

	// The email address of the person merging the branches. This information is
	// used in the commit information for the merge.
	Email *string `locationName:"email" type:"string"`

	// If the commit contains deletions, whether to keep a folder or folder structure
	// if the changes leave the folders empty. If this is specified as true, a .gitkeep
	// file is created for empty folders. The default is false.
	KeepEmptyFolders *bool `locationName:"keepEmptyFolders" type:"boolean"`

	// The name of the repository where you want to merge two branches.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// SourceCommitSpecifier is a required field
	SourceCommitSpecifier *string `locationName:"sourceCommitSpecifier" type:"string" required:"true"`

	// The branch where the merge is applied.
	TargetBranch *string `locationName:"targetBranch" min:"1" type:"string"`
}

// String returns the string representation
func (s MergeBranchesBySquashInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergeBranchesBySquashInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *MergeBranchesBySquashInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "MergeBranchesBySquashInput"}
	if s.DestinationCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("DestinationCommitSpecifier"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.SourceCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("SourceCommitSpecifier"))
	}
	if s.TargetBranch != nil && len(*s.TargetBranch) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("TargetBranch", 1))
	}
	if s.ConflictResolution != nil {
		if err := s.ConflictResolution.Validate(); err != nil {
			invalidParams.AddNested("ConflictResolution", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAuthorName sets the AuthorName field's value.
func (s *MergeBranchesBySquashInput) SetAuthorName(v string) *MergeBranchesBySquashInput {
	s.AuthorName = &v
	return s
}

// SetCommitMessage sets the CommitMessage field's value.
func (s *MergeBranchesBySquashInput) SetCommitMessage(v string) *MergeBranchesBySquashInput {
	s.CommitMessage = &v
	return s
}

// SetConflictDetailLevel sets the ConflictDetailLevel field's value.
func (s *MergeBranchesBySquashInput) SetConflictDetailLevel(v string) *MergeBranchesBySquashInput {
	s.ConflictDetailLevel = &v
	return s
}

// SetConflictResolution sets the ConflictResolution field's value.
func (s *MergeBranchesBySquashInput) SetConflictResolution(v *ConflictResolution) *MergeBranchesBySquashInput {
	s.ConflictResolution = v
	return s
}

// SetConflictResolutionStrategy sets the ConflictResolutionStrategy field's value.
func (s *MergeBranchesBySquashInput) SetConflictResolutionStrategy(v string) *MergeBranchesBySquashInput {
	s.ConflictResolutionStrategy = &v
	return s
}

// SetDestinationCommitSpecifier sets the DestinationCommitSpecifier field's value.
func (s *MergeBranchesBySquashInput) SetDestinationCommitSpecifier(v string) *MergeBranchesBySquashInput {
	s.DestinationCommitSpecifier = &v
	return s
}

// SetEmail sets the Email field's value.
func (s *MergeBranchesBySquashInput) SetEmail(v string) *MergeBranchesBySquashInput {
	s.Email = &v
	return s
}

// SetKeepEmptyFolders sets the KeepEmptyFolders field's value.
func (s *MergeBranchesBySquashInput) SetKeepEmptyFolders(v bool) *MergeBranchesBySquashInput {
	s.KeepEmptyFolders = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *MergeBranchesBySquashInput) SetRepositoryName(v string) *MergeBranchesBySquashInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitSpecifier sets the SourceCommitSpecifier field's value.
func (s *MergeBranchesBySquashInput) SetSourceCommitSpecifier(v string) *MergeBranchesBySquashInput {
	s.SourceCommitSpecifier = &v
	return s
}

// SetTargetBranch sets the TargetBranch field's value.
func (s *MergeBranchesBySquashInput) SetTargetBranch(v string) *MergeBranchesBySquashInput {
	s.TargetBranch = &v
	return s
}

type MergeBranchesBySquashOutput struct {
	_ struct{} `type:"structure"`

	// The commit ID of the merge in the destination or target branch.
	CommitId *string `locationName:"commitId" type:"string"`

	// The tree ID of the merge in the destination or target branch.
	TreeId *string `locationName:"treeId" type:"string"`
}

// String returns the string representation
func (s MergeBranchesBySquashOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergeBranchesBySquashOutput) GoString() string {
	return s.String()
}

// SetCommitId sets the CommitId field's value.
func (s *MergeBranchesBySquashOutput) SetCommitId(v string) *MergeBranchesBySquashOutput {
	s.CommitId = &v
	return s
}

// SetTreeId sets the TreeId field's value.
func (s *MergeBranchesBySquashOutput) SetTreeId(v string) *MergeBranchesBySquashOutput {
	s.TreeId = &v
	return s
}

type MergeBranchesByThreeWayInput struct {
	_ struct{} `type:"structure"`

	// The name of the author who created the commit. This information is used as
	// both the author and committer for the commit.
	AuthorName *string `locationName:"authorName" type:"string"`

	// The commit message to include in the commit information for the merge.
	CommitMessage *string `locationName:"commitMessage" type:"string"`

	// The level of conflict detail to use. If unspecified, the default FILE_LEVEL
	// is used, which returns a not-mergeable result if the same file has differences
	// in both branches. If LINE_LEVEL is specified, a conflict is considered not
	// mergeable if the same file in both branches has differences on the same line.
	ConflictDetailLevel *string `locationName:"conflictDetailLevel" type:"string" enum:"ConflictDetailLevelTypeEnum"`

	// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use
	// when resolving conflicts during a merge.
	ConflictResolution *ConflictResolution `locationName:"conflictResolution" type:"structure"`

	// Specifies which branch to use when resolving conflicts, or whether to attempt
	// automatically merging two versions of a file. The default is NONE, which
	// requires any conflicts to be resolved manually before the merge operation
	// is successful.
	ConflictResolutionStrategy *string `locationName:"conflictResolutionStrategy" type:"string" enum:"ConflictResolutionStrategyTypeEnum"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// DestinationCommitSpecifier is a required field
	DestinationCommitSpecifier *string `locationName:"destinationCommitSpecifier" type:"string" required:"true"`

	// The email address of the person merging the branches. This information is
	// used in the commit information for the merge.
	Email *string `locationName:"email" type:"string"`

	// If the commit contains deletions, whether to keep a folder or folder structure
	// if the changes leave the folders empty. If true, a .gitkeep file is created
	// for empty folders. The default is false.
	KeepEmptyFolders *bool `locationName:"keepEmptyFolders" type:"boolean"`

	// The name of the repository where you want to merge two branches.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The branch, tag, HEAD, or other fully qualified reference used to identify
	// a commit (for example, a branch name or a full commit ID).
	//
	// SourceCommitSpecifier is a required field
	SourceCommitSpecifier *string `locationName:"sourceCommitSpecifier" type:"string" required:"true"`

	// The branch where the merge is applied.
	TargetBranch *string `locationName:"targetBranch" min:"1" type:"string"`
}

// String returns the string representation
func (s MergeBranchesByThreeWayInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergeBranchesByThreeWayInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *MergeBranchesByThreeWayInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "MergeBranchesByThreeWayInput"}
	if s.DestinationCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("DestinationCommitSpecifier"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.SourceCommitSpecifier == nil {
		invalidParams.Add(request.NewErrParamRequired("SourceCommitSpecifier"))
	}
	if s.TargetBranch != nil && len(*s.TargetBranch) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("TargetBranch", 1))
	}
	if s.ConflictResolution != nil {
		if err := s.ConflictResolution.Validate(); err != nil {
			invalidParams.AddNested("ConflictResolution", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAuthorName sets the AuthorName field's value.
func (s *MergeBranchesByThreeWayInput) SetAuthorName(v string) *MergeBranchesByThreeWayInput {
	s.AuthorName = &v
	return s
}

// SetCommitMessage sets the CommitMessage field's value.
func (s *MergeBranchesByThreeWayInput) SetCommitMessage(v string) *MergeBranchesByThreeWayInput {
	s.CommitMessage = &v
	return s
}

// SetConflictDetailLevel sets the ConflictDetailLevel field's value.
func (s *MergeBranchesByThreeWayInput) SetConflictDetailLevel(v string) *MergeBranchesByThreeWayInput {
	s.ConflictDetailLevel = &v
	return s
}

// SetConflictResolution sets the ConflictResolution field's value.
func (s *MergeBranchesByThreeWayInput) SetConflictResolution(v *ConflictResolution) *MergeBranchesByThreeWayInput {
	s.ConflictResolution = v
	return s
}

// SetConflictResolutionStrategy sets the ConflictResolutionStrategy field's value.
func (s *MergeBranchesByThreeWayInput) SetConflictResolutionStrategy(v string) *MergeBranchesByThreeWayInput {
	s.ConflictResolutionStrategy = &v
	return s
}

// SetDestinationCommitSpecifier sets the DestinationCommitSpecifier field's value.
func (s *MergeBranchesByThreeWayInput) SetDestinationCommitSpecifier(v string) *MergeBranchesByThreeWayInput {
	s.DestinationCommitSpecifier = &v
	return s
}

// SetEmail sets the Email field's value.
func (s *MergeBranchesByThreeWayInput) SetEmail(v string) *MergeBranchesByThreeWayInput {
	s.Email = &v
	return s
}

// SetKeepEmptyFolders sets the KeepEmptyFolders field's value.
func (s *MergeBranchesByThreeWayInput) SetKeepEmptyFolders(v bool) *MergeBranchesByThreeWayInput {
	s.KeepEmptyFolders = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *MergeBranchesByThreeWayInput) SetRepositoryName(v string) *MergeBranchesByThreeWayInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitSpecifier sets the SourceCommitSpecifier field's value.
func (s *MergeBranchesByThreeWayInput) SetSourceCommitSpecifier(v string) *MergeBranchesByThreeWayInput {
	s.SourceCommitSpecifier = &v
	return s
}

// SetTargetBranch sets the TargetBranch field's value.
func (s *MergeBranchesByThreeWayInput) SetTargetBranch(v string) *MergeBranchesByThreeWayInput {
	s.TargetBranch = &v
	return s
}

type MergeBranchesByThreeWayOutput struct {
	_ struct{} `type:"structure"`

	// The commit ID of the merge in the destination or target branch.
	CommitId *string `locationName:"commitId" type:"string"`

	// The tree ID of the merge in the destination or target branch.
	TreeId *string `locationName:"treeId" type:"string"`
}

// String returns the string representation
func (s MergeBranchesByThreeWayOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergeBranchesByThreeWayOutput) GoString() string {
	return s.String()
}

// SetCommitId sets the CommitId field's value.
func (s *MergeBranchesByThreeWayOutput) SetCommitId(v string) *MergeBranchesByThreeWayOutput {
	s.CommitId = &v
	return s
}

// SetTreeId sets the TreeId field's value.
func (s *MergeBranchesByThreeWayOutput) SetTreeId(v string) *MergeBranchesByThreeWayOutput {
	s.TreeId = &v
	return s
}

// Information about merge hunks in a merge or pull request operation.
type MergeHunk struct {
	_ struct{} `type:"structure"`

	// Information about the merge hunk in the base of a merge or pull request.
	Base *MergeHunkDetail `locationName:"base" type:"structure"`

	// Information about the merge hunk in the destination of a merge or pull request.
	Destination *MergeHunkDetail `locationName:"destination" type:"structure"`

	// A Boolean value indicating whether a combination of hunks contains a conflict.
	// Conflicts occur when the same file or the same lines in a file were modified
	// in both the source and destination of a merge or pull request. Valid values
	// include true, false, and null. True when the hunk represents a conflict and
	// one or more files contains a line conflict. File mode conflicts in a merge
	// do not set this to true.
	IsConflict *bool `locationName:"isConflict" type:"boolean"`

	// Information about the merge hunk in the source of a merge or pull request.
	Source *MergeHunkDetail `locationName:"source" type:"structure"`
}

// String returns the string representation
func (s MergeHunk) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergeHunk) GoString() string {
	return s.String()
}

// SetBase sets the Base field's value.
func (s *MergeHunk) SetBase(v *MergeHunkDetail) *MergeHunk {
	s.Base = v
	return s
}

// SetDestination sets the Destination field's value.
func (s *MergeHunk) SetDestination(v *MergeHunkDetail) *MergeHunk {
	s.Destination = v
	return s
}

// SetIsConflict sets the IsConflict field's value.
func (s *MergeHunk) SetIsConflict(v bool) *MergeHunk {
	s.IsConflict = &v
	return s
}

// SetSource sets the Source field's value.
func (s *MergeHunk) SetSource(v *MergeHunkDetail) *MergeHunk {
	s.Source = v
	return s
}

// Information about the details of a merge hunk that contains a conflict in
// a merge or pull request operation.
type MergeHunkDetail struct {
	_ struct{} `type:"structure"`

	// The end position of the hunk in the merge result.
	EndLine *int64 `locationName:"endLine" type:"integer"`

	// The base-64 encoded content of the hunk merged region that might contain
	// a conflict.
	HunkContent *string `locationName:"hunkContent" type:"string"`

	// The start position of the hunk in the merge result.
	StartLine *int64 `locationName:"startLine" type:"integer"`
}

// String returns the string representation
func (s MergeHunkDetail) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergeHunkDetail) GoString() string {
	return s.String()
}

// SetEndLine sets the EndLine field's value.
func (s *MergeHunkDetail) SetEndLine(v int64) *MergeHunkDetail {
	s.EndLine = &v
	return s
}

// SetHunkContent sets the HunkContent field's value.
func (s *MergeHunkDetail) SetHunkContent(v string) *MergeHunkDetail {
	s.HunkContent = &v
	return s
}

// SetStartLine sets the StartLine field's value.
func (s *MergeHunkDetail) SetStartLine(v int64) *MergeHunkDetail {
	s.StartLine = &v
	return s
}

// Returns information about a merge or potential merge between a source reference
// and a destination reference in a pull request.
type MergeMetadata struct {
	_ struct{} `type:"structure"`

	// A Boolean value indicating whether the merge has been made.
	IsMerged *bool `locationName:"isMerged" type:"boolean"`

	// The commit ID for the merge commit, if any.
	MergeCommitId *string `locationName:"mergeCommitId" type:"string"`

	// The merge strategy used in the merge.
	MergeOption *string `locationName:"mergeOption" type:"string" enum:"MergeOptionTypeEnum"`

	// The Amazon Resource Name (ARN) of the user who merged the branches.
	MergedBy *string `locationName:"mergedBy" type:"string"`
}

// String returns the string representation
func (s MergeMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergeMetadata) GoString() string {
	return s.String()
}

// SetIsMerged sets the IsMerged field's value.
func (s *MergeMetadata) SetIsMerged(v bool) *MergeMetadata {
	s.IsMerged = &v
	return s
}

// SetMergeCommitId sets the MergeCommitId field's value.
func (s *MergeMetadata) SetMergeCommitId(v string) *MergeMetadata {
	s.MergeCommitId = &v
	return s
}

// SetMergeOption sets the MergeOption field's value.
func (s *MergeMetadata) SetMergeOption(v string) *MergeMetadata {
	s.MergeOption = &v
	return s
}

// SetMergedBy sets the MergedBy field's value.
func (s *MergeMetadata) SetMergedBy(v string) *MergeMetadata {
	s.MergedBy = &v
	return s
}

// Information about the file operation conflicts in a merge operation.
type MergeOperations struct {
	_ struct{} `type:"structure"`

	// The operation on a file in the destination of a merge or pull request.
	Destination *string `locationName:"destination" type:"string" enum:"ChangeTypeEnum"`

	// The operation (add, modify, or delete) on a file in the source of a merge
	// or pull request.
	Source *string `locationName:"source" type:"string" enum:"ChangeTypeEnum"`
}

// String returns the string representation
func (s MergeOperations) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergeOperations) GoString() string {
	return s.String()
}

// SetDestination sets the Destination field's value.
func (s *MergeOperations) SetDestination(v string) *MergeOperations {
	s.Destination = &v
	return s
}

// SetSource sets the Source field's value.
func (s *MergeOperations) SetSource(v string) *MergeOperations {
	s.Source = &v
	return s
}

// A merge option or stategy is required, and none was provided.
type MergeOptionRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MergeOptionRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergeOptionRequiredException) GoString() string {
	return s.String()
}

func newErrorMergeOptionRequiredException(v protocol.ResponseMetadata) error {
	return &MergeOptionRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MergeOptionRequiredException) Code() string {
	return "MergeOptionRequiredException"
}

// Message returns the exception's message.
func (s *MergeOptionRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MergeOptionRequiredException) OrigErr() error {
	return nil
}

func (s *MergeOptionRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MergeOptionRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MergeOptionRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

type MergePullRequestByFastForwardInput struct {
	_ struct{} `type:"structure"`

	// The system-generated ID of the pull request. To get this ID, use ListPullRequests.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The name of the repository where the pull request was created.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The full commit ID of the original or updated commit in the pull request
	// source branch. Pass this value if you want an exception thrown if the current
	// commit ID of the tip of the source branch does not match this commit ID.
	SourceCommitId *string `locationName:"sourceCommitId" type:"string"`
}

// String returns the string representation
func (s MergePullRequestByFastForwardInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergePullRequestByFastForwardInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *MergePullRequestByFastForwardInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "MergePullRequestByFastForwardInput"}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *MergePullRequestByFastForwardInput) SetPullRequestId(v string) *MergePullRequestByFastForwardInput {
	s.PullRequestId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *MergePullRequestByFastForwardInput) SetRepositoryName(v string) *MergePullRequestByFastForwardInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitId sets the SourceCommitId field's value.
func (s *MergePullRequestByFastForwardInput) SetSourceCommitId(v string) *MergePullRequestByFastForwardInput {
	s.SourceCommitId = &v
	return s
}

type MergePullRequestByFastForwardOutput struct {
	_ struct{} `type:"structure"`

	// Information about the specified pull request, including the merge.
	PullRequest *PullRequest `locationName:"pullRequest" type:"structure"`
}

// String returns the string representation
func (s MergePullRequestByFastForwardOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergePullRequestByFastForwardOutput) GoString() string {
	return s.String()
}

// SetPullRequest sets the PullRequest field's value.
func (s *MergePullRequestByFastForwardOutput) SetPullRequest(v *PullRequest) *MergePullRequestByFastForwardOutput {
	s.PullRequest = v
	return s
}

type MergePullRequestBySquashInput struct {
	_ struct{} `type:"structure"`

	// The name of the author who created the commit. This information is used as
	// both the author and committer for the commit.
	AuthorName *string `locationName:"authorName" type:"string"`

	// The commit message to include in the commit information for the merge.
	CommitMessage *string `locationName:"commitMessage" type:"string"`

	// The level of conflict detail to use. If unspecified, the default FILE_LEVEL
	// is used, which returns a not-mergeable result if the same file has differences
	// in both branches. If LINE_LEVEL is specified, a conflict is considered not
	// mergeable if the same file in both branches has differences on the same line.
	ConflictDetailLevel *string `locationName:"conflictDetailLevel" type:"string" enum:"ConflictDetailLevelTypeEnum"`

	// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use
	// when resolving conflicts during a merge.
	ConflictResolution *ConflictResolution `locationName:"conflictResolution" type:"structure"`

	// Specifies which branch to use when resolving conflicts, or whether to attempt
	// automatically merging two versions of a file. The default is NONE, which
	// requires any conflicts to be resolved manually before the merge operation
	// is successful.
	ConflictResolutionStrategy *string `locationName:"conflictResolutionStrategy" type:"string" enum:"ConflictResolutionStrategyTypeEnum"`

	// The email address of the person merging the branches. This information is
	// used in the commit information for the merge.
	Email *string `locationName:"email" type:"string"`

	// If the commit contains deletions, whether to keep a folder or folder structure
	// if the changes leave the folders empty. If true, a .gitkeep file is created
	// for empty folders. The default is false.
	KeepEmptyFolders *bool `locationName:"keepEmptyFolders" type:"boolean"`

	// The system-generated ID of the pull request. To get this ID, use ListPullRequests.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The name of the repository where the pull request was created.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The full commit ID of the original or updated commit in the pull request
	// source branch. Pass this value if you want an exception thrown if the current
	// commit ID of the tip of the source branch does not match this commit ID.
	SourceCommitId *string `locationName:"sourceCommitId" type:"string"`
}

// String returns the string representation
func (s MergePullRequestBySquashInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergePullRequestBySquashInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *MergePullRequestBySquashInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "MergePullRequestBySquashInput"}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.ConflictResolution != nil {
		if err := s.ConflictResolution.Validate(); err != nil {
			invalidParams.AddNested("ConflictResolution", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAuthorName sets the AuthorName field's value.
func (s *MergePullRequestBySquashInput) SetAuthorName(v string) *MergePullRequestBySquashInput {
	s.AuthorName = &v
	return s
}

// SetCommitMessage sets the CommitMessage field's value.
func (s *MergePullRequestBySquashInput) SetCommitMessage(v string) *MergePullRequestBySquashInput {
	s.CommitMessage = &v
	return s
}

// SetConflictDetailLevel sets the ConflictDetailLevel field's value.
func (s *MergePullRequestBySquashInput) SetConflictDetailLevel(v string) *MergePullRequestBySquashInput {
	s.ConflictDetailLevel = &v
	return s
}

// SetConflictResolution sets the ConflictResolution field's value.
func (s *MergePullRequestBySquashInput) SetConflictResolution(v *ConflictResolution) *MergePullRequestBySquashInput {
	s.ConflictResolution = v
	return s
}

// SetConflictResolutionStrategy sets the ConflictResolutionStrategy field's value.
func (s *MergePullRequestBySquashInput) SetConflictResolutionStrategy(v string) *MergePullRequestBySquashInput {
	s.ConflictResolutionStrategy = &v
	return s
}

// SetEmail sets the Email field's value.
func (s *MergePullRequestBySquashInput) SetEmail(v string) *MergePullRequestBySquashInput {
	s.Email = &v
	return s
}

// SetKeepEmptyFolders sets the KeepEmptyFolders field's value.
func (s *MergePullRequestBySquashInput) SetKeepEmptyFolders(v bool) *MergePullRequestBySquashInput {
	s.KeepEmptyFolders = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *MergePullRequestBySquashInput) SetPullRequestId(v string) *MergePullRequestBySquashInput {
	s.PullRequestId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *MergePullRequestBySquashInput) SetRepositoryName(v string) *MergePullRequestBySquashInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitId sets the SourceCommitId field's value.
func (s *MergePullRequestBySquashInput) SetSourceCommitId(v string) *MergePullRequestBySquashInput {
	s.SourceCommitId = &v
	return s
}

type MergePullRequestBySquashOutput struct {
	_ struct{} `type:"structure"`

	// Returns information about a pull request.
	PullRequest *PullRequest `locationName:"pullRequest" type:"structure"`
}

// String returns the string representation
func (s MergePullRequestBySquashOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergePullRequestBySquashOutput) GoString() string {
	return s.String()
}

// SetPullRequest sets the PullRequest field's value.
func (s *MergePullRequestBySquashOutput) SetPullRequest(v *PullRequest) *MergePullRequestBySquashOutput {
	s.PullRequest = v
	return s
}

type MergePullRequestByThreeWayInput struct {
	_ struct{} `type:"structure"`

	// The name of the author who created the commit. This information is used as
	// both the author and committer for the commit.
	AuthorName *string `locationName:"authorName" type:"string"`

	// The commit message to include in the commit information for the merge.
	CommitMessage *string `locationName:"commitMessage" type:"string"`

	// The level of conflict detail to use. If unspecified, the default FILE_LEVEL
	// is used, which returns a not-mergeable result if the same file has differences
	// in both branches. If LINE_LEVEL is specified, a conflict is considered not
	// mergeable if the same file in both branches has differences on the same line.
	ConflictDetailLevel *string `locationName:"conflictDetailLevel" type:"string" enum:"ConflictDetailLevelTypeEnum"`

	// If AUTOMERGE is the conflict resolution strategy, a list of inputs to use
	// when resolving conflicts during a merge.
	ConflictResolution *ConflictResolution `locationName:"conflictResolution" type:"structure"`

	// Specifies which branch to use when resolving conflicts, or whether to attempt
	// automatically merging two versions of a file. The default is NONE, which
	// requires any conflicts to be resolved manually before the merge operation
	// is successful.
	ConflictResolutionStrategy *string `locationName:"conflictResolutionStrategy" type:"string" enum:"ConflictResolutionStrategyTypeEnum"`

	// The email address of the person merging the branches. This information is
	// used in the commit information for the merge.
	Email *string `locationName:"email" type:"string"`

	// If the commit contains deletions, whether to keep a folder or folder structure
	// if the changes leave the folders empty. If true, a .gitkeep file is created
	// for empty folders. The default is false.
	KeepEmptyFolders *bool `locationName:"keepEmptyFolders" type:"boolean"`

	// The system-generated ID of the pull request. To get this ID, use ListPullRequests.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The name of the repository where the pull request was created.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The full commit ID of the original or updated commit in the pull request
	// source branch. Pass this value if you want an exception thrown if the current
	// commit ID of the tip of the source branch does not match this commit ID.
	SourceCommitId *string `locationName:"sourceCommitId" type:"string"`
}

// String returns the string representation
func (s MergePullRequestByThreeWayInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergePullRequestByThreeWayInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *MergePullRequestByThreeWayInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "MergePullRequestByThreeWayInput"}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.ConflictResolution != nil {
		if err := s.ConflictResolution.Validate(); err != nil {
			invalidParams.AddNested("ConflictResolution", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAuthorName sets the AuthorName field's value.
func (s *MergePullRequestByThreeWayInput) SetAuthorName(v string) *MergePullRequestByThreeWayInput {
	s.AuthorName = &v
	return s
}

// SetCommitMessage sets the CommitMessage field's value.
func (s *MergePullRequestByThreeWayInput) SetCommitMessage(v string) *MergePullRequestByThreeWayInput {
	s.CommitMessage = &v
	return s
}

// SetConflictDetailLevel sets the ConflictDetailLevel field's value.
func (s *MergePullRequestByThreeWayInput) SetConflictDetailLevel(v string) *MergePullRequestByThreeWayInput {
	s.ConflictDetailLevel = &v
	return s
}

// SetConflictResolution sets the ConflictResolution field's value.
func (s *MergePullRequestByThreeWayInput) SetConflictResolution(v *ConflictResolution) *MergePullRequestByThreeWayInput {
	s.ConflictResolution = v
	return s
}

// SetConflictResolutionStrategy sets the ConflictResolutionStrategy field's value.
func (s *MergePullRequestByThreeWayInput) SetConflictResolutionStrategy(v string) *MergePullRequestByThreeWayInput {
	s.ConflictResolutionStrategy = &v
	return s
}

// SetEmail sets the Email field's value.
func (s *MergePullRequestByThreeWayInput) SetEmail(v string) *MergePullRequestByThreeWayInput {
	s.Email = &v
	return s
}

// SetKeepEmptyFolders sets the KeepEmptyFolders field's value.
func (s *MergePullRequestByThreeWayInput) SetKeepEmptyFolders(v bool) *MergePullRequestByThreeWayInput {
	s.KeepEmptyFolders = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *MergePullRequestByThreeWayInput) SetPullRequestId(v string) *MergePullRequestByThreeWayInput {
	s.PullRequestId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *MergePullRequestByThreeWayInput) SetRepositoryName(v string) *MergePullRequestByThreeWayInput {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitId sets the SourceCommitId field's value.
func (s *MergePullRequestByThreeWayInput) SetSourceCommitId(v string) *MergePullRequestByThreeWayInput {
	s.SourceCommitId = &v
	return s
}

type MergePullRequestByThreeWayOutput struct {
	_ struct{} `type:"structure"`

	// Returns information about a pull request.
	PullRequest *PullRequest `locationName:"pullRequest" type:"structure"`
}

// String returns the string representation
func (s MergePullRequestByThreeWayOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MergePullRequestByThreeWayOutput) GoString() string {
	return s.String()
}

// SetPullRequest sets the PullRequest field's value.
func (s *MergePullRequestByThreeWayOutput) SetPullRequest(v *PullRequest) *MergePullRequestByThreeWayOutput {
	s.PullRequest = v
	return s
}

// More than one conflict resolution entries exists for the conflict. A conflict
// can have only one conflict resolution entry.
type MultipleConflictResolutionEntriesException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MultipleConflictResolutionEntriesException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MultipleConflictResolutionEntriesException) GoString() string {
	return s.String()
}

func newErrorMultipleConflictResolutionEntriesException(v protocol.ResponseMetadata) error {
	return &MultipleConflictResolutionEntriesException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MultipleConflictResolutionEntriesException) Code() string {
	return "MultipleConflictResolutionEntriesException"
}

// Message returns the exception's message.
func (s *MultipleConflictResolutionEntriesException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MultipleConflictResolutionEntriesException) OrigErr() error {
	return nil
}

func (s *MultipleConflictResolutionEntriesException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MultipleConflictResolutionEntriesException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MultipleConflictResolutionEntriesException) RequestID() string {
	return s.RespMetadata.RequestID
}

// You cannot include more than one repository in a pull request. Make sure
// you have specified only one repository name in your request, and then try
// again.
type MultipleRepositoriesInPullRequestException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s MultipleRepositoriesInPullRequestException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s MultipleRepositoriesInPullRequestException) GoString() string {
	return s.String()
}

func newErrorMultipleRepositoriesInPullRequestException(v protocol.ResponseMetadata) error {
	return &MultipleRepositoriesInPullRequestException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *MultipleRepositoriesInPullRequestException) Code() string {
	return "MultipleRepositoriesInPullRequestException"
}

// Message returns the exception's message.
func (s *MultipleRepositoriesInPullRequestException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *MultipleRepositoriesInPullRequestException) OrigErr() error {
	return nil
}

func (s *MultipleRepositoriesInPullRequestException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *MultipleRepositoriesInPullRequestException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *MultipleRepositoriesInPullRequestException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The user name is not valid because it has exceeded the character limit for
// author names.
type NameLengthExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s NameLengthExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s NameLengthExceededException) GoString() string {
	return s.String()
}

func newErrorNameLengthExceededException(v protocol.ResponseMetadata) error {
	return &NameLengthExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *NameLengthExceededException) Code() string {
	return "NameLengthExceededException"
}

// Message returns the exception's message.
func (s *NameLengthExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *NameLengthExceededException) OrigErr() error {
	return nil
}

func (s *NameLengthExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *NameLengthExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *NameLengthExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The commit cannot be created because no changes will be made to the repository
// as a result of this commit. A commit must contain at least one change.
type NoChangeException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s NoChangeException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s NoChangeException) GoString() string {
	return s.String()
}

func newErrorNoChangeException(v protocol.ResponseMetadata) error {
	return &NoChangeException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *NoChangeException) Code() string {
	return "NoChangeException"
}

// Message returns the exception's message.
func (s *NoChangeException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *NoChangeException) OrigErr() error {
	return nil
}

func (s *NoChangeException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *NoChangeException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *NoChangeException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The maximum number of approval rule templates has been exceeded for this
// AWS Region.
type NumberOfRuleTemplatesExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s NumberOfRuleTemplatesExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s NumberOfRuleTemplatesExceededException) GoString() string {
	return s.String()
}

func newErrorNumberOfRuleTemplatesExceededException(v protocol.ResponseMetadata) error {
	return &NumberOfRuleTemplatesExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *NumberOfRuleTemplatesExceededException) Code() string {
	return "NumberOfRuleTemplatesExceededException"
}

// Message returns the exception's message.
func (s *NumberOfRuleTemplatesExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *NumberOfRuleTemplatesExceededException) OrigErr() error {
	return nil
}

func (s *NumberOfRuleTemplatesExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *NumberOfRuleTemplatesExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *NumberOfRuleTemplatesExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The approval rule cannot be added. The pull request has the maximum number
// of approval rules associated with it.
type NumberOfRulesExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s NumberOfRulesExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s NumberOfRulesExceededException) GoString() string {
	return s.String()
}

func newErrorNumberOfRulesExceededException(v protocol.ResponseMetadata) error {
	return &NumberOfRulesExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *NumberOfRulesExceededException) Code() string {
	return "NumberOfRulesExceededException"
}

// Message returns the exception's message.
func (s *NumberOfRulesExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *NumberOfRulesExceededException) OrigErr() error {
	return nil
}

func (s *NumberOfRulesExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *NumberOfRulesExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *NumberOfRulesExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about the type of an object in a merge operation.
type ObjectTypes struct {
	_ struct{} `type:"structure"`

	// The type of the object in the base commit of the merge.
	Base *string `locationName:"base" type:"string" enum:"ObjectTypeEnum"`

	// The type of the object in the destination branch.
	Destination *string `locationName:"destination" type:"string" enum:"ObjectTypeEnum"`

	// The type of the object in the source branch.
	Source *string `locationName:"source" type:"string" enum:"ObjectTypeEnum"`
}

// String returns the string representation
func (s ObjectTypes) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ObjectTypes) GoString() string {
	return s.String()
}

// SetBase sets the Base field's value.
func (s *ObjectTypes) SetBase(v string) *ObjectTypes {
	s.Base = &v
	return s
}

// SetDestination sets the Destination field's value.
func (s *ObjectTypes) SetDestination(v string) *ObjectTypes {
	s.Destination = &v
	return s
}

// SetSource sets the Source field's value.
func (s *ObjectTypes) SetSource(v string) *ObjectTypes {
	s.Source = &v
	return s
}

// Returns information about the template that created the approval rule for
// a pull request.
type OriginApprovalRuleTemplate struct {
	_ struct{} `type:"structure"`

	// The ID of the template that created the approval rule.
	ApprovalRuleTemplateId *string `locationName:"approvalRuleTemplateId" type:"string"`

	// The name of the template that created the approval rule.
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string"`
}

// String returns the string representation
func (s OriginApprovalRuleTemplate) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OriginApprovalRuleTemplate) GoString() string {
	return s.String()
}

// SetApprovalRuleTemplateId sets the ApprovalRuleTemplateId field's value.
func (s *OriginApprovalRuleTemplate) SetApprovalRuleTemplateId(v string) *OriginApprovalRuleTemplate {
	s.ApprovalRuleTemplateId = &v
	return s
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *OriginApprovalRuleTemplate) SetApprovalRuleTemplateName(v string) *OriginApprovalRuleTemplate {
	s.ApprovalRuleTemplateName = &v
	return s
}

// The pull request has already had its approval rules set to override.
type OverrideAlreadySetException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s OverrideAlreadySetException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OverrideAlreadySetException) GoString() string {
	return s.String()
}

func newErrorOverrideAlreadySetException(v protocol.ResponseMetadata) error {
	return &OverrideAlreadySetException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *OverrideAlreadySetException) Code() string {
	return "OverrideAlreadySetException"
}

// Message returns the exception's message.
func (s *OverrideAlreadySetException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *OverrideAlreadySetException) OrigErr() error {
	return nil
}

func (s *OverrideAlreadySetException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *OverrideAlreadySetException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *OverrideAlreadySetException) RequestID() string {
	return s.RespMetadata.RequestID
}

type OverridePullRequestApprovalRulesInput struct {
	_ struct{} `type:"structure"`

	// Whether you want to set aside approval rule requirements for the pull request
	// (OVERRIDE) or revoke a previous override and apply approval rule requirements
	// (REVOKE). REVOKE status is not stored.
	//
	// OverrideStatus is a required field
	OverrideStatus *string `locationName:"overrideStatus" type:"string" required:"true" enum:"OverrideStatus"`

	// The system-generated ID of the pull request for which you want to override
	// all approval rule requirements. To get this information, use GetPullRequest.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The system-generated ID of the most recent revision of the pull request.
	// You cannot override approval rules for anything but the most recent revision
	// of a pull request. To get the revision ID, use GetPullRequest.
	//
	// RevisionId is a required field
	RevisionId *string `locationName:"revisionId" type:"string" required:"true"`
}

// String returns the string representation
func (s OverridePullRequestApprovalRulesInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OverridePullRequestApprovalRulesInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *OverridePullRequestApprovalRulesInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "OverridePullRequestApprovalRulesInput"}
	if s.OverrideStatus == nil {
		invalidParams.Add(request.NewErrParamRequired("OverrideStatus"))
	}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.RevisionId == nil {
		invalidParams.Add(request.NewErrParamRequired("RevisionId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetOverrideStatus sets the OverrideStatus field's value.
func (s *OverridePullRequestApprovalRulesInput) SetOverrideStatus(v string) *OverridePullRequestApprovalRulesInput {
	s.OverrideStatus = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *OverridePullRequestApprovalRulesInput) SetPullRequestId(v string) *OverridePullRequestApprovalRulesInput {
	s.PullRequestId = &v
	return s
}

// SetRevisionId sets the RevisionId field's value.
func (s *OverridePullRequestApprovalRulesInput) SetRevisionId(v string) *OverridePullRequestApprovalRulesInput {
	s.RevisionId = &v
	return s
}

type OverridePullRequestApprovalRulesOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s OverridePullRequestApprovalRulesOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OverridePullRequestApprovalRulesOutput) GoString() string {
	return s.String()
}

// An override status is required, but no value was provided. Valid values include
// OVERRIDE and REVOKE.
type OverrideStatusRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s OverrideStatusRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s OverrideStatusRequiredException) GoString() string {
	return s.String()
}

func newErrorOverrideStatusRequiredException(v protocol.ResponseMetadata) error {
	return &OverrideStatusRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *OverrideStatusRequiredException) Code() string {
	return "OverrideStatusRequiredException"
}

// Message returns the exception's message.
func (s *OverrideStatusRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *OverrideStatusRequiredException) OrigErr() error {
	return nil
}

func (s *OverrideStatusRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *OverrideStatusRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *OverrideStatusRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The parent commit ID is not valid because it does not exist. The specified
// parent commit ID does not exist in the specified branch of the repository.
type ParentCommitDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ParentCommitDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ParentCommitDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorParentCommitDoesNotExistException(v protocol.ResponseMetadata) error {
	return &ParentCommitDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ParentCommitDoesNotExistException) Code() string {
	return "ParentCommitDoesNotExistException"
}

// Message returns the exception's message.
func (s *ParentCommitDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ParentCommitDoesNotExistException) OrigErr() error {
	return nil
}

func (s *ParentCommitDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ParentCommitDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ParentCommitDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The file could not be added because the provided parent commit ID is not
// the current tip of the specified branch. To view the full commit ID of the
// current head of the branch, use GetBranch.
type ParentCommitIdOutdatedException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ParentCommitIdOutdatedException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ParentCommitIdOutdatedException) GoString() string {
	return s.String()
}

func newErrorParentCommitIdOutdatedException(v protocol.ResponseMetadata) error {
	return &ParentCommitIdOutdatedException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ParentCommitIdOutdatedException) Code() string {
	return "ParentCommitIdOutdatedException"
}

// Message returns the exception's message.
func (s *ParentCommitIdOutdatedException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ParentCommitIdOutdatedException) OrigErr() error {
	return nil
}

func (s *ParentCommitIdOutdatedException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ParentCommitIdOutdatedException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ParentCommitIdOutdatedException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A parent commit ID is required. To view the full commit ID of a branch in
// a repository, use GetBranch or a Git command (for example, git pull or git
// log).
type ParentCommitIdRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ParentCommitIdRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ParentCommitIdRequiredException) GoString() string {
	return s.String()
}

func newErrorParentCommitIdRequiredException(v protocol.ResponseMetadata) error {
	return &ParentCommitIdRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ParentCommitIdRequiredException) Code() string {
	return "ParentCommitIdRequiredException"
}

// Message returns the exception's message.
func (s *ParentCommitIdRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ParentCommitIdRequiredException) OrigErr() error {
	return nil
}

func (s *ParentCommitIdRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ParentCommitIdRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ParentCommitIdRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified path does not exist.
type PathDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s PathDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PathDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorPathDoesNotExistException(v protocol.ResponseMetadata) error {
	return &PathDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *PathDoesNotExistException) Code() string {
	return "PathDoesNotExistException"
}

// Message returns the exception's message.
func (s *PathDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *PathDoesNotExistException) OrigErr() error {
	return nil
}

func (s *PathDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *PathDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *PathDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The folderPath for a location cannot be null.
type PathRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s PathRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PathRequiredException) GoString() string {
	return s.String()
}

func newErrorPathRequiredException(v protocol.ResponseMetadata) error {
	return &PathRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *PathRequiredException) Code() string {
	return "PathRequiredException"
}

// Message returns the exception's message.
func (s *PathRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *PathRequiredException) OrigErr() error {
	return nil
}

func (s *PathRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *PathRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *PathRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

type PostCommentForComparedCommitInput struct {
	_ struct{} `type:"structure"`

	// To establish the directionality of the comparison, the full commit ID of
	// the after commit.
	//
	// AfterCommitId is a required field
	AfterCommitId *string `locationName:"afterCommitId" type:"string" required:"true"`

	// To establish the directionality of the comparison, the full commit ID of
	// the before commit. Required for commenting on any commit unless that commit
	// is the initial commit.
	BeforeCommitId *string `locationName:"beforeCommitId" type:"string"`

	// A unique, client-generated idempotency token that, when provided in a request,
	// ensures the request cannot be repeated with a changed parameter. If a request
	// is received with the same parameters and a token is included, the request
	// returns information about the initial request that used that token.
	ClientRequestToken *string `locationName:"clientRequestToken" type:"string" idempotencyToken:"true"`

	// The content of the comment you want to make.
	//
	// Content is a required field
	Content *string `locationName:"content" type:"string" required:"true"`

	// The location of the comparison where you want to comment.
	Location *Location `locationName:"location" type:"structure"`

	// The name of the repository where you want to post a comment on the comparison
	// between commits.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s PostCommentForComparedCommitInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PostCommentForComparedCommitInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PostCommentForComparedCommitInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "PostCommentForComparedCommitInput"}
	if s.AfterCommitId == nil {
		invalidParams.Add(request.NewErrParamRequired("AfterCommitId"))
	}
	if s.Content == nil {
		invalidParams.Add(request.NewErrParamRequired("Content"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAfterCommitId sets the AfterCommitId field's value.
func (s *PostCommentForComparedCommitInput) SetAfterCommitId(v string) *PostCommentForComparedCommitInput {
	s.AfterCommitId = &v
	return s
}

// SetBeforeCommitId sets the BeforeCommitId field's value.
func (s *PostCommentForComparedCommitInput) SetBeforeCommitId(v string) *PostCommentForComparedCommitInput {
	s.BeforeCommitId = &v
	return s
}

// SetClientRequestToken sets the ClientRequestToken field's value.
func (s *PostCommentForComparedCommitInput) SetClientRequestToken(v string) *PostCommentForComparedCommitInput {
	s.ClientRequestToken = &v
	return s
}

// SetContent sets the Content field's value.
func (s *PostCommentForComparedCommitInput) SetContent(v string) *PostCommentForComparedCommitInput {
	s.Content = &v
	return s
}

// SetLocation sets the Location field's value.
func (s *PostCommentForComparedCommitInput) SetLocation(v *Location) *PostCommentForComparedCommitInput {
	s.Location = v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *PostCommentForComparedCommitInput) SetRepositoryName(v string) *PostCommentForComparedCommitInput {
	s.RepositoryName = &v
	return s
}

type PostCommentForComparedCommitOutput struct {
	_ struct{} `type:"structure"`

	// In the directionality you established, the blob ID of the after blob.
	AfterBlobId *string `locationName:"afterBlobId" type:"string"`

	// In the directionality you established, the full commit ID of the after commit.
	AfterCommitId *string `locationName:"afterCommitId" type:"string"`

	// In the directionality you established, the blob ID of the before blob.
	BeforeBlobId *string `locationName:"beforeBlobId" type:"string"`

	// In the directionality you established, the full commit ID of the before commit.
	BeforeCommitId *string `locationName:"beforeCommitId" type:"string"`

	// The content of the comment you posted.
	Comment *Comment `locationName:"comment" type:"structure"`

	// The location of the comment in the comparison between the two commits.
	Location *Location `locationName:"location" type:"structure"`

	// The name of the repository where you posted a comment on the comparison between
	// commits.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s PostCommentForComparedCommitOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PostCommentForComparedCommitOutput) GoString() string {
	return s.String()
}

// SetAfterBlobId sets the AfterBlobId field's value.
func (s *PostCommentForComparedCommitOutput) SetAfterBlobId(v string) *PostCommentForComparedCommitOutput {
	s.AfterBlobId = &v
	return s
}

// SetAfterCommitId sets the AfterCommitId field's value.
func (s *PostCommentForComparedCommitOutput) SetAfterCommitId(v string) *PostCommentForComparedCommitOutput {
	s.AfterCommitId = &v
	return s
}

// SetBeforeBlobId sets the BeforeBlobId field's value.
func (s *PostCommentForComparedCommitOutput) SetBeforeBlobId(v string) *PostCommentForComparedCommitOutput {
	s.BeforeBlobId = &v
	return s
}

// SetBeforeCommitId sets the BeforeCommitId field's value.
func (s *PostCommentForComparedCommitOutput) SetBeforeCommitId(v string) *PostCommentForComparedCommitOutput {
	s.BeforeCommitId = &v
	return s
}

// SetComment sets the Comment field's value.
func (s *PostCommentForComparedCommitOutput) SetComment(v *Comment) *PostCommentForComparedCommitOutput {
	s.Comment = v
	return s
}

// SetLocation sets the Location field's value.
func (s *PostCommentForComparedCommitOutput) SetLocation(v *Location) *PostCommentForComparedCommitOutput {
	s.Location = v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *PostCommentForComparedCommitOutput) SetRepositoryName(v string) *PostCommentForComparedCommitOutput {
	s.RepositoryName = &v
	return s
}

type PostCommentForPullRequestInput struct {
	_ struct{} `type:"structure"`

	// The full commit ID of the commit in the source branch that is the current
	// tip of the branch for the pull request when you post the comment.
	//
	// AfterCommitId is a required field
	AfterCommitId *string `locationName:"afterCommitId" type:"string" required:"true"`

	// The full commit ID of the commit in the destination branch that was the tip
	// of the branch at the time the pull request was created.
	//
	// BeforeCommitId is a required field
	BeforeCommitId *string `locationName:"beforeCommitId" type:"string" required:"true"`

	// A unique, client-generated idempotency token that, when provided in a request,
	// ensures the request cannot be repeated with a changed parameter. If a request
	// is received with the same parameters and a token is included, the request
	// returns information about the initial request that used that token.
	ClientRequestToken *string `locationName:"clientRequestToken" type:"string" idempotencyToken:"true"`

	// The content of your comment on the change.
	//
	// Content is a required field
	Content *string `locationName:"content" type:"string" required:"true"`

	// The location of the change where you want to post your comment. If no location
	// is provided, the comment is posted as a general comment on the pull request
	// difference between the before commit ID and the after commit ID.
	Location *Location `locationName:"location" type:"structure"`

	// The system-generated ID of the pull request. To get this ID, use ListPullRequests.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The name of the repository where you want to post a comment on a pull request.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s PostCommentForPullRequestInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PostCommentForPullRequestInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PostCommentForPullRequestInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "PostCommentForPullRequestInput"}
	if s.AfterCommitId == nil {
		invalidParams.Add(request.NewErrParamRequired("AfterCommitId"))
	}
	if s.BeforeCommitId == nil {
		invalidParams.Add(request.NewErrParamRequired("BeforeCommitId"))
	}
	if s.Content == nil {
		invalidParams.Add(request.NewErrParamRequired("Content"))
	}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetAfterCommitId sets the AfterCommitId field's value.
func (s *PostCommentForPullRequestInput) SetAfterCommitId(v string) *PostCommentForPullRequestInput {
	s.AfterCommitId = &v
	return s
}

// SetBeforeCommitId sets the BeforeCommitId field's value.
func (s *PostCommentForPullRequestInput) SetBeforeCommitId(v string) *PostCommentForPullRequestInput {
	s.BeforeCommitId = &v
	return s
}

// SetClientRequestToken sets the ClientRequestToken field's value.
func (s *PostCommentForPullRequestInput) SetClientRequestToken(v string) *PostCommentForPullRequestInput {
	s.ClientRequestToken = &v
	return s
}

// SetContent sets the Content field's value.
func (s *PostCommentForPullRequestInput) SetContent(v string) *PostCommentForPullRequestInput {
	s.Content = &v
	return s
}

// SetLocation sets the Location field's value.
func (s *PostCommentForPullRequestInput) SetLocation(v *Location) *PostCommentForPullRequestInput {
	s.Location = v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *PostCommentForPullRequestInput) SetPullRequestId(v string) *PostCommentForPullRequestInput {
	s.PullRequestId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *PostCommentForPullRequestInput) SetRepositoryName(v string) *PostCommentForPullRequestInput {
	s.RepositoryName = &v
	return s
}

type PostCommentForPullRequestOutput struct {
	_ struct{} `type:"structure"`

	// In the directionality of the pull request, the blob ID of the after blob.
	AfterBlobId *string `locationName:"afterBlobId" type:"string"`

	// The full commit ID of the commit in the destination branch where the pull
	// request is merged.
	AfterCommitId *string `locationName:"afterCommitId" type:"string"`

	// In the directionality of the pull request, the blob ID of the before blob.
	BeforeBlobId *string `locationName:"beforeBlobId" type:"string"`

	// The full commit ID of the commit in the source branch used to create the
	// pull request, or in the case of an updated pull request, the full commit
	// ID of the commit used to update the pull request.
	BeforeCommitId *string `locationName:"beforeCommitId" type:"string"`

	// The content of the comment you posted.
	Comment *Comment `locationName:"comment" type:"structure"`

	// The location of the change where you posted your comment.
	Location *Location `locationName:"location" type:"structure"`

	// The system-generated ID of the pull request.
	PullRequestId *string `locationName:"pullRequestId" type:"string"`

	// The name of the repository where you posted a comment on a pull request.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s PostCommentForPullRequestOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PostCommentForPullRequestOutput) GoString() string {
	return s.String()
}

// SetAfterBlobId sets the AfterBlobId field's value.
func (s *PostCommentForPullRequestOutput) SetAfterBlobId(v string) *PostCommentForPullRequestOutput {
	s.AfterBlobId = &v
	return s
}

// SetAfterCommitId sets the AfterCommitId field's value.
func (s *PostCommentForPullRequestOutput) SetAfterCommitId(v string) *PostCommentForPullRequestOutput {
	s.AfterCommitId = &v
	return s
}

// SetBeforeBlobId sets the BeforeBlobId field's value.
func (s *PostCommentForPullRequestOutput) SetBeforeBlobId(v string) *PostCommentForPullRequestOutput {
	s.BeforeBlobId = &v
	return s
}

// SetBeforeCommitId sets the BeforeCommitId field's value.
func (s *PostCommentForPullRequestOutput) SetBeforeCommitId(v string) *PostCommentForPullRequestOutput {
	s.BeforeCommitId = &v
	return s
}

// SetComment sets the Comment field's value.
func (s *PostCommentForPullRequestOutput) SetComment(v *Comment) *PostCommentForPullRequestOutput {
	s.Comment = v
	return s
}

// SetLocation sets the Location field's value.
func (s *PostCommentForPullRequestOutput) SetLocation(v *Location) *PostCommentForPullRequestOutput {
	s.Location = v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *PostCommentForPullRequestOutput) SetPullRequestId(v string) *PostCommentForPullRequestOutput {
	s.PullRequestId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *PostCommentForPullRequestOutput) SetRepositoryName(v string) *PostCommentForPullRequestOutput {
	s.RepositoryName = &v
	return s
}

type PostCommentReplyInput struct {
	_ struct{} `type:"structure"`

	// A unique, client-generated idempotency token that, when provided in a request,
	// ensures the request cannot be repeated with a changed parameter. If a request
	// is received with the same parameters and a token is included, the request
	// returns information about the initial request that used that token.
	ClientRequestToken *string `locationName:"clientRequestToken" type:"string" idempotencyToken:"true"`

	// The contents of your reply to a comment.
	//
	// Content is a required field
	Content *string `locationName:"content" type:"string" required:"true"`

	// The system-generated ID of the comment to which you want to reply. To get
	// this ID, use GetCommentsForComparedCommit or GetCommentsForPullRequest.
	//
	// InReplyTo is a required field
	InReplyTo *string `locationName:"inReplyTo" type:"string" required:"true"`
}

// String returns the string representation
func (s PostCommentReplyInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PostCommentReplyInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PostCommentReplyInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "PostCommentReplyInput"}
	if s.Content == nil {
		invalidParams.Add(request.NewErrParamRequired("Content"))
	}
	if s.InReplyTo == nil {
		invalidParams.Add(request.NewErrParamRequired("InReplyTo"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetClientRequestToken sets the ClientRequestToken field's value.
func (s *PostCommentReplyInput) SetClientRequestToken(v string) *PostCommentReplyInput {
	s.ClientRequestToken = &v
	return s
}

// SetContent sets the Content field's value.
func (s *PostCommentReplyInput) SetContent(v string) *PostCommentReplyInput {
	s.Content = &v
	return s
}

// SetInReplyTo sets the InReplyTo field's value.
func (s *PostCommentReplyInput) SetInReplyTo(v string) *PostCommentReplyInput {
	s.InReplyTo = &v
	return s
}

type PostCommentReplyOutput struct {
	_ struct{} `type:"structure"`

	// Information about the reply to a comment.
	Comment *Comment `locationName:"comment" type:"structure"`
}

// String returns the string representation
func (s PostCommentReplyOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PostCommentReplyOutput) GoString() string {
	return s.String()
}

// SetComment sets the Comment field's value.
func (s *PostCommentReplyOutput) SetComment(v *Comment) *PostCommentReplyOutput {
	s.Comment = v
	return s
}

// Returns information about a pull request.
type PullRequest struct {
	_ struct{} `type:"structure"`

	// The approval rules applied to the pull request.
	ApprovalRules []*ApprovalRule `locationName:"approvalRules" type:"list"`

	// The Amazon Resource Name (ARN) of the user who created the pull request.
	AuthorArn *string `locationName:"authorArn" type:"string"`

	// A unique, client-generated idempotency token that, when provided in a request,
	// ensures the request cannot be repeated with a changed parameter. If a request
	// is received with the same parameters and a token is included, the request
	// returns information about the initial request that used that token.
	ClientRequestToken *string `locationName:"clientRequestToken" type:"string"`

	// The date and time the pull request was originally created, in timestamp format.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp"`

	// The user-defined description of the pull request. This description can be
	// used to clarify what should be reviewed and other details of the request.
	Description *string `locationName:"description" type:"string"`

	// The day and time of the last user or system activity on the pull request,
	// in timestamp format.
	LastActivityDate *time.Time `locationName:"lastActivityDate" type:"timestamp"`

	// The system-generated ID of the pull request.
	PullRequestId *string `locationName:"pullRequestId" type:"string"`

	// The status of the pull request. Pull request status can only change from
	// OPEN to CLOSED.
	PullRequestStatus *string `locationName:"pullRequestStatus" type:"string" enum:"PullRequestStatusEnum"`

	// The targets of the pull request, including the source branch and destination
	// branch for the pull request.
	PullRequestTargets []*PullRequestTarget `locationName:"pullRequestTargets" type:"list"`

	// The system-generated revision ID for the pull request.
	RevisionId *string `locationName:"revisionId" type:"string"`

	// The user-defined title of the pull request. This title is displayed in the
	// list of pull requests to other repository users.
	Title *string `locationName:"title" type:"string"`
}

// String returns the string representation
func (s PullRequest) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequest) GoString() string {
	return s.String()
}

// SetApprovalRules sets the ApprovalRules field's value.
func (s *PullRequest) SetApprovalRules(v []*ApprovalRule) *PullRequest {
	s.ApprovalRules = v
	return s
}

// SetAuthorArn sets the AuthorArn field's value.
func (s *PullRequest) SetAuthorArn(v string) *PullRequest {
	s.AuthorArn = &v
	return s
}

// SetClientRequestToken sets the ClientRequestToken field's value.
func (s *PullRequest) SetClientRequestToken(v string) *PullRequest {
	s.ClientRequestToken = &v
	return s
}

// SetCreationDate sets the CreationDate field's value.
func (s *PullRequest) SetCreationDate(v time.Time) *PullRequest {
	s.CreationDate = &v
	return s
}

// SetDescription sets the Description field's value.
func (s *PullRequest) SetDescription(v string) *PullRequest {
	s.Description = &v
	return s
}

// SetLastActivityDate sets the LastActivityDate field's value.
func (s *PullRequest) SetLastActivityDate(v time.Time) *PullRequest {
	s.LastActivityDate = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *PullRequest) SetPullRequestId(v string) *PullRequest {
	s.PullRequestId = &v
	return s
}

// SetPullRequestStatus sets the PullRequestStatus field's value.
func (s *PullRequest) SetPullRequestStatus(v string) *PullRequest {
	s.PullRequestStatus = &v
	return s
}

// SetPullRequestTargets sets the PullRequestTargets field's value.
func (s *PullRequest) SetPullRequestTargets(v []*PullRequestTarget) *PullRequest {
	s.PullRequestTargets = v
	return s
}

// SetRevisionId sets the RevisionId field's value.
func (s *PullRequest) SetRevisionId(v string) *PullRequest {
	s.RevisionId = &v
	return s
}

// SetTitle sets the Title field's value.
func (s *PullRequest) SetTitle(v string) *PullRequest {
	s.Title = &v
	return s
}

// The pull request status cannot be updated because it is already closed.
type PullRequestAlreadyClosedException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s PullRequestAlreadyClosedException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestAlreadyClosedException) GoString() string {
	return s.String()
}

func newErrorPullRequestAlreadyClosedException(v protocol.ResponseMetadata) error {
	return &PullRequestAlreadyClosedException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *PullRequestAlreadyClosedException) Code() string {
	return "PullRequestAlreadyClosedException"
}

// Message returns the exception's message.
func (s *PullRequestAlreadyClosedException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *PullRequestAlreadyClosedException) OrigErr() error {
	return nil
}

func (s *PullRequestAlreadyClosedException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *PullRequestAlreadyClosedException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *PullRequestAlreadyClosedException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The pull request cannot be merged because one or more approval rules applied
// to the pull request have conditions that have not been met.
type PullRequestApprovalRulesNotSatisfiedException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s PullRequestApprovalRulesNotSatisfiedException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestApprovalRulesNotSatisfiedException) GoString() string {
	return s.String()
}

func newErrorPullRequestApprovalRulesNotSatisfiedException(v protocol.ResponseMetadata) error {
	return &PullRequestApprovalRulesNotSatisfiedException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *PullRequestApprovalRulesNotSatisfiedException) Code() string {
	return "PullRequestApprovalRulesNotSatisfiedException"
}

// Message returns the exception's message.
func (s *PullRequestApprovalRulesNotSatisfiedException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *PullRequestApprovalRulesNotSatisfiedException) OrigErr() error {
	return nil
}

func (s *PullRequestApprovalRulesNotSatisfiedException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *PullRequestApprovalRulesNotSatisfiedException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *PullRequestApprovalRulesNotSatisfiedException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The approval cannot be applied because the user approving the pull request
// matches the user who created the pull request. You cannot approve a pull
// request that you created.
type PullRequestCannotBeApprovedByAuthorException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s PullRequestCannotBeApprovedByAuthorException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestCannotBeApprovedByAuthorException) GoString() string {
	return s.String()
}

func newErrorPullRequestCannotBeApprovedByAuthorException(v protocol.ResponseMetadata) error {
	return &PullRequestCannotBeApprovedByAuthorException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *PullRequestCannotBeApprovedByAuthorException) Code() string {
	return "PullRequestCannotBeApprovedByAuthorException"
}

// Message returns the exception's message.
func (s *PullRequestCannotBeApprovedByAuthorException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *PullRequestCannotBeApprovedByAuthorException) OrigErr() error {
	return nil
}

func (s *PullRequestCannotBeApprovedByAuthorException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *PullRequestCannotBeApprovedByAuthorException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *PullRequestCannotBeApprovedByAuthorException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Metadata about the pull request that is used when comparing the pull request
// source with its destination.
type PullRequestCreatedEventMetadata struct {
	_ struct{} `type:"structure"`

	// The commit ID of the tip of the branch specified as the destination branch
	// when the pull request was created.
	DestinationCommitId *string `locationName:"destinationCommitId" type:"string"`

	// The commit ID of the most recent commit that the source branch and the destination
	// branch have in common.
	MergeBase *string `locationName:"mergeBase" type:"string"`

	// The name of the repository where the pull request was created.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`

	// The commit ID on the source branch used when the pull request was created.
	SourceCommitId *string `locationName:"sourceCommitId" type:"string"`
}

// String returns the string representation
func (s PullRequestCreatedEventMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestCreatedEventMetadata) GoString() string {
	return s.String()
}

// SetDestinationCommitId sets the DestinationCommitId field's value.
func (s *PullRequestCreatedEventMetadata) SetDestinationCommitId(v string) *PullRequestCreatedEventMetadata {
	s.DestinationCommitId = &v
	return s
}

// SetMergeBase sets the MergeBase field's value.
func (s *PullRequestCreatedEventMetadata) SetMergeBase(v string) *PullRequestCreatedEventMetadata {
	s.MergeBase = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *PullRequestCreatedEventMetadata) SetRepositoryName(v string) *PullRequestCreatedEventMetadata {
	s.RepositoryName = &v
	return s
}

// SetSourceCommitId sets the SourceCommitId field's value.
func (s *PullRequestCreatedEventMetadata) SetSourceCommitId(v string) *PullRequestCreatedEventMetadata {
	s.SourceCommitId = &v
	return s
}

// The pull request ID could not be found. Make sure that you have specified
// the correct repository name and pull request ID, and then try again.
type PullRequestDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s PullRequestDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorPullRequestDoesNotExistException(v protocol.ResponseMetadata) error {
	return &PullRequestDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *PullRequestDoesNotExistException) Code() string {
	return "PullRequestDoesNotExistException"
}

// Message returns the exception's message.
func (s *PullRequestDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *PullRequestDoesNotExistException) OrigErr() error {
	return nil
}

func (s *PullRequestDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *PullRequestDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *PullRequestDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about a pull request event.
type PullRequestEvent struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the user whose actions resulted in the
	// event. Examples include updating the pull request with more commits or changing
	// the status of a pull request.
	ActorArn *string `locationName:"actorArn" type:"string"`

	// Information about a pull request event.
	ApprovalRuleEventMetadata *ApprovalRuleEventMetadata `locationName:"approvalRuleEventMetadata" type:"structure"`

	// Information about an approval rule override event for a pull request.
	ApprovalRuleOverriddenEventMetadata *ApprovalRuleOverriddenEventMetadata `locationName:"approvalRuleOverriddenEventMetadata" type:"structure"`

	// Information about an approval state change for a pull request.
	ApprovalStateChangedEventMetadata *ApprovalStateChangedEventMetadata `locationName:"approvalStateChangedEventMetadata" type:"structure"`

	// The day and time of the pull request event, in timestamp format.
	EventDate *time.Time `locationName:"eventDate" type:"timestamp"`

	// Information about the source and destination branches for the pull request.
	PullRequestCreatedEventMetadata *PullRequestCreatedEventMetadata `locationName:"pullRequestCreatedEventMetadata" type:"structure"`

	// The type of the pull request event (for example, a status change event (PULL_REQUEST_STATUS_CHANGED)
	// or update event (PULL_REQUEST_SOURCE_REFERENCE_UPDATED)).
	PullRequestEventType *string `locationName:"pullRequestEventType" type:"string" enum:"PullRequestEventType"`

	// The system-generated ID of the pull request.
	PullRequestId *string `locationName:"pullRequestId" type:"string"`

	// Information about the change in mergability state for the pull request event.
	PullRequestMergedStateChangedEventMetadata *PullRequestMergedStateChangedEventMetadata `locationName:"pullRequestMergedStateChangedEventMetadata" type:"structure"`

	// Information about the updated source branch for the pull request event.
	PullRequestSourceReferenceUpdatedEventMetadata *PullRequestSourceReferenceUpdatedEventMetadata `locationName:"pullRequestSourceReferenceUpdatedEventMetadata" type:"structure"`

	// Information about the change in status for the pull request event.
	PullRequestStatusChangedEventMetadata *PullRequestStatusChangedEventMetadata `locationName:"pullRequestStatusChangedEventMetadata" type:"structure"`
}

// String returns the string representation
func (s PullRequestEvent) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestEvent) GoString() string {
	return s.String()
}

// SetActorArn sets the ActorArn field's value.
func (s *PullRequestEvent) SetActorArn(v string) *PullRequestEvent {
	s.ActorArn = &v
	return s
}

// SetApprovalRuleEventMetadata sets the ApprovalRuleEventMetadata field's value.
func (s *PullRequestEvent) SetApprovalRuleEventMetadata(v *ApprovalRuleEventMetadata) *PullRequestEvent {
	s.ApprovalRuleEventMetadata = v
	return s
}

// SetApprovalRuleOverriddenEventMetadata sets the ApprovalRuleOverriddenEventMetadata field's value.
func (s *PullRequestEvent) SetApprovalRuleOverriddenEventMetadata(v *ApprovalRuleOverriddenEventMetadata) *PullRequestEvent {
	s.ApprovalRuleOverriddenEventMetadata = v
	return s
}

// SetApprovalStateChangedEventMetadata sets the ApprovalStateChangedEventMetadata field's value.
func (s *PullRequestEvent) SetApprovalStateChangedEventMetadata(v *ApprovalStateChangedEventMetadata) *PullRequestEvent {
	s.ApprovalStateChangedEventMetadata = v
	return s
}

// SetEventDate sets the EventDate field's value.
func (s *PullRequestEvent) SetEventDate(v time.Time) *PullRequestEvent {
	s.EventDate = &v
	return s
}

// SetPullRequestCreatedEventMetadata sets the PullRequestCreatedEventMetadata field's value.
func (s *PullRequestEvent) SetPullRequestCreatedEventMetadata(v *PullRequestCreatedEventMetadata) *PullRequestEvent {
	s.PullRequestCreatedEventMetadata = v
	return s
}

// SetPullRequestEventType sets the PullRequestEventType field's value.
func (s *PullRequestEvent) SetPullRequestEventType(v string) *PullRequestEvent {
	s.PullRequestEventType = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *PullRequestEvent) SetPullRequestId(v string) *PullRequestEvent {
	s.PullRequestId = &v
	return s
}

// SetPullRequestMergedStateChangedEventMetadata sets the PullRequestMergedStateChangedEventMetadata field's value.
func (s *PullRequestEvent) SetPullRequestMergedStateChangedEventMetadata(v *PullRequestMergedStateChangedEventMetadata) *PullRequestEvent {
	s.PullRequestMergedStateChangedEventMetadata = v
	return s
}

// SetPullRequestSourceReferenceUpdatedEventMetadata sets the PullRequestSourceReferenceUpdatedEventMetadata field's value.
func (s *PullRequestEvent) SetPullRequestSourceReferenceUpdatedEventMetadata(v *PullRequestSourceReferenceUpdatedEventMetadata) *PullRequestEvent {
	s.PullRequestSourceReferenceUpdatedEventMetadata = v
	return s
}

// SetPullRequestStatusChangedEventMetadata sets the PullRequestStatusChangedEventMetadata field's value.
func (s *PullRequestEvent) SetPullRequestStatusChangedEventMetadata(v *PullRequestStatusChangedEventMetadata) *PullRequestEvent {
	s.PullRequestStatusChangedEventMetadata = v
	return s
}

// A pull request ID is required, but none was provided.
type PullRequestIdRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s PullRequestIdRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestIdRequiredException) GoString() string {
	return s.String()
}

func newErrorPullRequestIdRequiredException(v protocol.ResponseMetadata) error {
	return &PullRequestIdRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *PullRequestIdRequiredException) Code() string {
	return "PullRequestIdRequiredException"
}

// Message returns the exception's message.
func (s *PullRequestIdRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *PullRequestIdRequiredException) OrigErr() error {
	return nil
}

func (s *PullRequestIdRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *PullRequestIdRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *PullRequestIdRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about the change in the merge state for a pull request
// event.
type PullRequestMergedStateChangedEventMetadata struct {
	_ struct{} `type:"structure"`

	// The name of the branch that the pull request is merged into.
	DestinationReference *string `locationName:"destinationReference" type:"string"`

	// Information about the merge state change event.
	MergeMetadata *MergeMetadata `locationName:"mergeMetadata" type:"structure"`

	// The name of the repository where the pull request was created.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s PullRequestMergedStateChangedEventMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestMergedStateChangedEventMetadata) GoString() string {
	return s.String()
}

// SetDestinationReference sets the DestinationReference field's value.
func (s *PullRequestMergedStateChangedEventMetadata) SetDestinationReference(v string) *PullRequestMergedStateChangedEventMetadata {
	s.DestinationReference = &v
	return s
}

// SetMergeMetadata sets the MergeMetadata field's value.
func (s *PullRequestMergedStateChangedEventMetadata) SetMergeMetadata(v *MergeMetadata) *PullRequestMergedStateChangedEventMetadata {
	s.MergeMetadata = v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *PullRequestMergedStateChangedEventMetadata) SetRepositoryName(v string) *PullRequestMergedStateChangedEventMetadata {
	s.RepositoryName = &v
	return s
}

// Information about an update to the source branch of a pull request.
type PullRequestSourceReferenceUpdatedEventMetadata struct {
	_ struct{} `type:"structure"`

	// The full commit ID of the commit in the source branch that was the tip of
	// the branch at the time the pull request was updated.
	AfterCommitId *string `locationName:"afterCommitId" type:"string"`

	// The full commit ID of the commit in the destination branch that was the tip
	// of the branch at the time the pull request was updated.
	BeforeCommitId *string `locationName:"beforeCommitId" type:"string"`

	// The commit ID of the most recent commit that the source branch and the destination
	// branch have in common.
	MergeBase *string `locationName:"mergeBase" type:"string"`

	// The name of the repository where the pull request was updated.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s PullRequestSourceReferenceUpdatedEventMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestSourceReferenceUpdatedEventMetadata) GoString() string {
	return s.String()
}

// SetAfterCommitId sets the AfterCommitId field's value.
func (s *PullRequestSourceReferenceUpdatedEventMetadata) SetAfterCommitId(v string) *PullRequestSourceReferenceUpdatedEventMetadata {
	s.AfterCommitId = &v
	return s
}

// SetBeforeCommitId sets the BeforeCommitId field's value.
func (s *PullRequestSourceReferenceUpdatedEventMetadata) SetBeforeCommitId(v string) *PullRequestSourceReferenceUpdatedEventMetadata {
	s.BeforeCommitId = &v
	return s
}

// SetMergeBase sets the MergeBase field's value.
func (s *PullRequestSourceReferenceUpdatedEventMetadata) SetMergeBase(v string) *PullRequestSourceReferenceUpdatedEventMetadata {
	s.MergeBase = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *PullRequestSourceReferenceUpdatedEventMetadata) SetRepositoryName(v string) *PullRequestSourceReferenceUpdatedEventMetadata {
	s.RepositoryName = &v
	return s
}

// Information about a change to the status of a pull request.
type PullRequestStatusChangedEventMetadata struct {
	_ struct{} `type:"structure"`

	// The changed status of the pull request.
	PullRequestStatus *string `locationName:"pullRequestStatus" type:"string" enum:"PullRequestStatusEnum"`
}

// String returns the string representation
func (s PullRequestStatusChangedEventMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestStatusChangedEventMetadata) GoString() string {
	return s.String()
}

// SetPullRequestStatus sets the PullRequestStatus field's value.
func (s *PullRequestStatusChangedEventMetadata) SetPullRequestStatus(v string) *PullRequestStatusChangedEventMetadata {
	s.PullRequestStatus = &v
	return s
}

// A pull request status is required, but none was provided.
type PullRequestStatusRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s PullRequestStatusRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestStatusRequiredException) GoString() string {
	return s.String()
}

func newErrorPullRequestStatusRequiredException(v protocol.ResponseMetadata) error {
	return &PullRequestStatusRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *PullRequestStatusRequiredException) Code() string {
	return "PullRequestStatusRequiredException"
}

// Message returns the exception's message.
func (s *PullRequestStatusRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *PullRequestStatusRequiredException) OrigErr() error {
	return nil
}

func (s *PullRequestStatusRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *PullRequestStatusRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *PullRequestStatusRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about a pull request target.
type PullRequestTarget struct {
	_ struct{} `type:"structure"`

	// The full commit ID that is the tip of the destination branch. This is the
	// commit where the pull request was or will be merged.
	DestinationCommit *string `locationName:"destinationCommit" type:"string"`

	// The branch of the repository where the pull request changes are merged. Also
	// known as the destination branch.
	DestinationReference *string `locationName:"destinationReference" type:"string"`

	// The commit ID of the most recent commit that the source branch and the destination
	// branch have in common.
	MergeBase *string `locationName:"mergeBase" type:"string"`

	// Returns metadata about the state of the merge, including whether the merge
	// has been made.
	MergeMetadata *MergeMetadata `locationName:"mergeMetadata" type:"structure"`

	// The name of the repository that contains the pull request source and destination
	// branches.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`

	// The full commit ID of the tip of the source branch used to create the pull
	// request. If the pull request branch is updated by a push while the pull request
	// is open, the commit ID changes to reflect the new tip of the branch.
	SourceCommit *string `locationName:"sourceCommit" type:"string"`

	// The branch of the repository that contains the changes for the pull request.
	// Also known as the source branch.
	SourceReference *string `locationName:"sourceReference" type:"string"`
}

// String returns the string representation
func (s PullRequestTarget) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PullRequestTarget) GoString() string {
	return s.String()
}

// SetDestinationCommit sets the DestinationCommit field's value.
func (s *PullRequestTarget) SetDestinationCommit(v string) *PullRequestTarget {
	s.DestinationCommit = &v
	return s
}

// SetDestinationReference sets the DestinationReference field's value.
func (s *PullRequestTarget) SetDestinationReference(v string) *PullRequestTarget {
	s.DestinationReference = &v
	return s
}

// SetMergeBase sets the MergeBase field's value.
func (s *PullRequestTarget) SetMergeBase(v string) *PullRequestTarget {
	s.MergeBase = &v
	return s
}

// SetMergeMetadata sets the MergeMetadata field's value.
func (s *PullRequestTarget) SetMergeMetadata(v *MergeMetadata) *PullRequestTarget {
	s.MergeMetadata = v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *PullRequestTarget) SetRepositoryName(v string) *PullRequestTarget {
	s.RepositoryName = &v
	return s
}

// SetSourceCommit sets the SourceCommit field's value.
func (s *PullRequestTarget) SetSourceCommit(v string) *PullRequestTarget {
	s.SourceCommit = &v
	return s
}

// SetSourceReference sets the SourceReference field's value.
func (s *PullRequestTarget) SetSourceReference(v string) *PullRequestTarget {
	s.SourceReference = &v
	return s
}

type PutCommentReactionInput struct {
	_ struct{} `type:"structure"`

	// The ID of the comment to which you want to add or update a reaction.
	//
	// CommentId is a required field
	CommentId *string `locationName:"commentId" type:"string" required:"true"`

	// The emoji reaction you want to add or update. To remove a reaction, provide
	// a value of blank or null. You can also provide the value of none. For information
	// about emoji reaction values supported in AWS CodeCommit, see the AWS CodeCommit
	// User Guide (https://docs.aws.amazon.com/codecommit/latest/userguide/how-to-commit-comment.html#emoji-reaction-table).
	//
	// ReactionValue is a required field
	ReactionValue *string `locationName:"reactionValue" type:"string" required:"true"`
}

// String returns the string representation
func (s PutCommentReactionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutCommentReactionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutCommentReactionInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "PutCommentReactionInput"}
	if s.CommentId == nil {
		invalidParams.Add(request.NewErrParamRequired("CommentId"))
	}
	if s.ReactionValue == nil {
		invalidParams.Add(request.NewErrParamRequired("ReactionValue"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetCommentId sets the CommentId field's value.
func (s *PutCommentReactionInput) SetCommentId(v string) *PutCommentReactionInput {
	s.CommentId = &v
	return s
}

// SetReactionValue sets the ReactionValue field's value.
func (s *PutCommentReactionInput) SetReactionValue(v string) *PutCommentReactionInput {
	s.ReactionValue = &v
	return s
}

type PutCommentReactionOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s PutCommentReactionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutCommentReactionOutput) GoString() string {
	return s.String()
}

// Information about a file added or updated as part of a commit.
type PutFileEntry struct {
	_ struct{} `type:"structure"`

	// The content of the file, if a source file is not specified.
	//
	// FileContent is automatically base64 encoded/decoded by the SDK.
	FileContent []byte `locationName:"fileContent" type:"blob"`

	// The extrapolated file mode permissions for the file. Valid values include
	// EXECUTABLE and NORMAL.
	FileMode *string `locationName:"fileMode" type:"string" enum:"FileModeTypeEnum"`

	// The full path to the file in the repository, including the name of the file.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`

	// The name and full path of the file that contains the changes you want to
	// make as part of the commit, if you are not providing the file content directly.
	SourceFile *SourceFileSpecifier `locationName:"sourceFile" type:"structure"`
}

// String returns the string representation
func (s PutFileEntry) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutFileEntry) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutFileEntry) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "PutFileEntry"}
	if s.FilePath == nil {
		invalidParams.Add(request.NewErrParamRequired("FilePath"))
	}
	if s.SourceFile != nil {
		if err := s.SourceFile.Validate(); err != nil {
			invalidParams.AddNested("SourceFile", err.(request.ErrInvalidParams))
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetFileContent sets the FileContent field's value.
func (s *PutFileEntry) SetFileContent(v []byte) *PutFileEntry {
	s.FileContent = v
	return s
}

// SetFileMode sets the FileMode field's value.
func (s *PutFileEntry) SetFileMode(v string) *PutFileEntry {
	s.FileMode = &v
	return s
}

// SetFilePath sets the FilePath field's value.
func (s *PutFileEntry) SetFilePath(v string) *PutFileEntry {
	s.FilePath = &v
	return s
}

// SetSourceFile sets the SourceFile field's value.
func (s *PutFileEntry) SetSourceFile(v *SourceFileSpecifier) *PutFileEntry {
	s.SourceFile = v
	return s
}

// The commit cannot be created because one or more files specified in the commit
// reference both a file and a folder.
type PutFileEntryConflictException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s PutFileEntryConflictException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutFileEntryConflictException) GoString() string {
	return s.String()
}

func newErrorPutFileEntryConflictException(v protocol.ResponseMetadata) error {
	return &PutFileEntryConflictException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *PutFileEntryConflictException) Code() string {
	return "PutFileEntryConflictException"
}

// Message returns the exception's message.
func (s *PutFileEntryConflictException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *PutFileEntryConflictException) OrigErr() error {
	return nil
}

func (s *PutFileEntryConflictException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *PutFileEntryConflictException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *PutFileEntryConflictException) RequestID() string {
	return s.RespMetadata.RequestID
}

type PutFileInput struct {
	_ struct{} `type:"structure"`

	// The name of the branch where you want to add or update the file. If this
	// is an empty repository, this branch is created.
	//
	// BranchName is a required field
	BranchName *string `locationName:"branchName" min:"1" type:"string" required:"true"`

	// A message about why this file was added or updated. Although it is optional,
	// a message makes the commit history for your repository more useful.
	CommitMessage *string `locationName:"commitMessage" type:"string"`

	// An email address for the person adding or updating the file.
	Email *string `locationName:"email" type:"string"`

	// The content of the file, in binary object format.
	//
	// FileContent is automatically base64 encoded/decoded by the SDK.
	//
	// FileContent is a required field
	FileContent []byte `locationName:"fileContent" type:"blob" required:"true"`

	// The file mode permissions of the blob. Valid file mode permissions are listed
	// here.
	FileMode *string `locationName:"fileMode" type:"string" enum:"FileModeTypeEnum"`

	// The name of the file you want to add or update, including the relative path
	// to the file in the repository.
	//
	// If the path does not currently exist in the repository, the path is created
	// as part of adding the file.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`

	// The name of the person adding or updating the file. Although it is optional,
	// a name makes the commit history for your repository more useful.
	Name *string `locationName:"name" type:"string"`

	// The full commit ID of the head commit in the branch where you want to add
	// or update the file. If this is an empty repository, no commit ID is required.
	// If this is not an empty repository, a commit ID is required.
	//
	// The commit ID must match the ID of the head commit at the time of the operation.
	// Otherwise, an error occurs, and the file is not added or updated.
	ParentCommitId *string `locationName:"parentCommitId" type:"string"`

	// The name of the repository where you want to add or update the file.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s PutFileInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutFileInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutFileInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "PutFileInput"}
	if s.BranchName == nil {
		invalidParams.Add(request.NewErrParamRequired("BranchName"))
	}
	if s.BranchName != nil && len(*s.BranchName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("BranchName", 1))
	}
	if s.FileContent == nil {
		invalidParams.Add(request.NewErrParamRequired("FileContent"))
	}
	if s.FilePath == nil {
		invalidParams.Add(request.NewErrParamRequired("FilePath"))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetBranchName sets the BranchName field's value.
func (s *PutFileInput) SetBranchName(v string) *PutFileInput {
	s.BranchName = &v
	return s
}

// SetCommitMessage sets the CommitMessage field's value.
func (s *PutFileInput) SetCommitMessage(v string) *PutFileInput {
	s.CommitMessage = &v
	return s
}

// SetEmail sets the Email field's value.
func (s *PutFileInput) SetEmail(v string) *PutFileInput {
	s.Email = &v
	return s
}

// SetFileContent sets the FileContent field's value.
func (s *PutFileInput) SetFileContent(v []byte) *PutFileInput {
	s.FileContent = v
	return s
}

// SetFileMode sets the FileMode field's value.
func (s *PutFileInput) SetFileMode(v string) *PutFileInput {
	s.FileMode = &v
	return s
}

// SetFilePath sets the FilePath field's value.
func (s *PutFileInput) SetFilePath(v string) *PutFileInput {
	s.FilePath = &v
	return s
}

// SetName sets the Name field's value.
func (s *PutFileInput) SetName(v string) *PutFileInput {
	s.Name = &v
	return s
}

// SetParentCommitId sets the ParentCommitId field's value.
func (s *PutFileInput) SetParentCommitId(v string) *PutFileInput {
	s.ParentCommitId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *PutFileInput) SetRepositoryName(v string) *PutFileInput {
	s.RepositoryName = &v
	return s
}

type PutFileOutput struct {
	_ struct{} `type:"structure"`

	// The ID of the blob, which is its SHA-1 pointer.
	//
	// BlobId is a required field
	BlobId *string `locationName:"blobId" type:"string" required:"true"`

	// The full SHA ID of the commit that contains this file change.
	//
	// CommitId is a required field
	CommitId *string `locationName:"commitId" type:"string" required:"true"`

	// The full SHA-1 pointer of the tree information for the commit that contains
	// this file change.
	//
	// TreeId is a required field
	TreeId *string `locationName:"treeId" type:"string" required:"true"`
}

// String returns the string representation
func (s PutFileOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutFileOutput) GoString() string {
	return s.String()
}

// SetBlobId sets the BlobId field's value.
func (s *PutFileOutput) SetBlobId(v string) *PutFileOutput {
	s.BlobId = &v
	return s
}

// SetCommitId sets the CommitId field's value.
func (s *PutFileOutput) SetCommitId(v string) *PutFileOutput {
	s.CommitId = &v
	return s
}

// SetTreeId sets the TreeId field's value.
func (s *PutFileOutput) SetTreeId(v string) *PutFileOutput {
	s.TreeId = &v
	return s
}

// Represents the input of a put repository triggers operation.
type PutRepositoryTriggersInput struct {
	_ struct{} `type:"structure"`

	// The name of the repository where you want to create or update the trigger.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The JSON block of configuration information for each trigger.
	//
	// Triggers is a required field
	Triggers []*RepositoryTrigger `locationName:"triggers" type:"list" required:"true"`
}

// String returns the string representation
func (s PutRepositoryTriggersInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutRepositoryTriggersInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *PutRepositoryTriggersInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "PutRepositoryTriggersInput"}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.Triggers == nil {
		invalidParams.Add(request.NewErrParamRequired("Triggers"))
	}
	if s.Triggers != nil {
		for i, v := range s.Triggers {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Triggers", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *PutRepositoryTriggersInput) SetRepositoryName(v string) *PutRepositoryTriggersInput {
	s.RepositoryName = &v
	return s
}

// SetTriggers sets the Triggers field's value.
func (s *PutRepositoryTriggersInput) SetTriggers(v []*RepositoryTrigger) *PutRepositoryTriggersInput {
	s.Triggers = v
	return s
}

// Represents the output of a put repository triggers operation.
type PutRepositoryTriggersOutput struct {
	_ struct{} `type:"structure"`

	// The system-generated unique ID for the create or update operation.
	ConfigurationId *string `locationName:"configurationId" type:"string"`
}

// String returns the string representation
func (s PutRepositoryTriggersOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s PutRepositoryTriggersOutput) GoString() string {
	return s.String()
}

// SetConfigurationId sets the ConfigurationId field's value.
func (s *PutRepositoryTriggersOutput) SetConfigurationId(v string) *PutRepositoryTriggersOutput {
	s.ConfigurationId = &v
	return s
}

// Information about the reaction values provided by users on a comment.
type ReactionForComment struct {
	_ struct{} `type:"structure"`

	// The reaction for a specified comment.
	Reaction *ReactionValueFormats `locationName:"reaction" type:"structure"`

	// The Amazon Resource Names (ARNs) of users who have provided reactions to
	// the comment.
	ReactionUsers []*string `locationName:"reactionUsers" type:"list"`

	// A numerical count of users who reacted with the specified emoji whose identities
	// have been subsequently deleted from IAM. While these IAM users or roles no
	// longer exist, the reactions might still appear in total reaction counts.
	ReactionsFromDeletedUsersCount *int64 `locationName:"reactionsFromDeletedUsersCount" type:"integer"`
}

// String returns the string representation
func (s ReactionForComment) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReactionForComment) GoString() string {
	return s.String()
}

// SetReaction sets the Reaction field's value.
func (s *ReactionForComment) SetReaction(v *ReactionValueFormats) *ReactionForComment {
	s.Reaction = v
	return s
}

// SetReactionUsers sets the ReactionUsers field's value.
func (s *ReactionForComment) SetReactionUsers(v []*string) *ReactionForComment {
	s.ReactionUsers = v
	return s
}

// SetReactionsFromDeletedUsersCount sets the ReactionsFromDeletedUsersCount field's value.
func (s *ReactionForComment) SetReactionsFromDeletedUsersCount(v int64) *ReactionForComment {
	s.ReactionsFromDeletedUsersCount = &v
	return s
}

// The number of reactions has been exceeded. Reactions are limited to one reaction
// per user for each individual comment ID.
type ReactionLimitExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ReactionLimitExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReactionLimitExceededException) GoString() string {
	return s.String()
}

func newErrorReactionLimitExceededException(v protocol.ResponseMetadata) error {
	return &ReactionLimitExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ReactionLimitExceededException) Code() string {
	return "ReactionLimitExceededException"
}

// Message returns the exception's message.
func (s *ReactionLimitExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ReactionLimitExceededException) OrigErr() error {
	return nil
}

func (s *ReactionLimitExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ReactionLimitExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ReactionLimitExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about the values for reactions to a comment. AWS CodeCommit supports
// a limited set of reactions.
type ReactionValueFormats struct {
	_ struct{} `type:"structure"`

	// The Emoji Version 1.0 graphic of the reaction. These graphics are interpreted
	// slightly differently on different operating systems.
	Emoji *string `locationName:"emoji" type:"string"`

	// The emoji short code for the reaction. Short codes are interpreted slightly
	// differently on different operating systems.
	ShortCode *string `locationName:"shortCode" type:"string"`

	// The Unicode codepoint for the reaction.
	Unicode *string `locationName:"unicode" type:"string"`
}

// String returns the string representation
func (s ReactionValueFormats) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReactionValueFormats) GoString() string {
	return s.String()
}

// SetEmoji sets the Emoji field's value.
func (s *ReactionValueFormats) SetEmoji(v string) *ReactionValueFormats {
	s.Emoji = &v
	return s
}

// SetShortCode sets the ShortCode field's value.
func (s *ReactionValueFormats) SetShortCode(v string) *ReactionValueFormats {
	s.ShortCode = &v
	return s
}

// SetUnicode sets the Unicode field's value.
func (s *ReactionValueFormats) SetUnicode(v string) *ReactionValueFormats {
	s.Unicode = &v
	return s
}

// A reaction value is required.
type ReactionValueRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ReactionValueRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReactionValueRequiredException) GoString() string {
	return s.String()
}

func newErrorReactionValueRequiredException(v protocol.ResponseMetadata) error {
	return &ReactionValueRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ReactionValueRequiredException) Code() string {
	return "ReactionValueRequiredException"
}

// Message returns the exception's message.
func (s *ReactionValueRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ReactionValueRequiredException) OrigErr() error {
	return nil
}

func (s *ReactionValueRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ReactionValueRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ReactionValueRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified reference does not exist. You must provide a full commit ID.
type ReferenceDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ReferenceDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReferenceDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorReferenceDoesNotExistException(v protocol.ResponseMetadata) error {
	return &ReferenceDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ReferenceDoesNotExistException) Code() string {
	return "ReferenceDoesNotExistException"
}

// Message returns the exception's message.
func (s *ReferenceDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ReferenceDoesNotExistException) OrigErr() error {
	return nil
}

func (s *ReferenceDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ReferenceDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ReferenceDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A reference name is required, but none was provided.
type ReferenceNameRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ReferenceNameRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReferenceNameRequiredException) GoString() string {
	return s.String()
}

func newErrorReferenceNameRequiredException(v protocol.ResponseMetadata) error {
	return &ReferenceNameRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ReferenceNameRequiredException) Code() string {
	return "ReferenceNameRequiredException"
}

// Message returns the exception's message.
func (s *ReferenceNameRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ReferenceNameRequiredException) OrigErr() error {
	return nil
}

func (s *ReferenceNameRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ReferenceNameRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ReferenceNameRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified reference is not a supported type.
type ReferenceTypeNotSupportedException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ReferenceTypeNotSupportedException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReferenceTypeNotSupportedException) GoString() string {
	return s.String()
}

func newErrorReferenceTypeNotSupportedException(v protocol.ResponseMetadata) error {
	return &ReferenceTypeNotSupportedException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ReferenceTypeNotSupportedException) Code() string {
	return "ReferenceTypeNotSupportedException"
}

// Message returns the exception's message.
func (s *ReferenceTypeNotSupportedException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ReferenceTypeNotSupportedException) OrigErr() error {
	return nil
}

func (s *ReferenceTypeNotSupportedException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ReferenceTypeNotSupportedException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ReferenceTypeNotSupportedException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about a replacement content entry in the conflict of a merge
// or pull request operation.
type ReplaceContentEntry struct {
	_ struct{} `type:"structure"`

	// The base-64 encoded content to use when the replacement type is USE_NEW_CONTENT.
	//
	// Content is automatically base64 encoded/decoded by the SDK.
	Content []byte `locationName:"content" type:"blob"`

	// The file mode to apply during conflict resoltion.
	FileMode *string `locationName:"fileMode" type:"string" enum:"FileModeTypeEnum"`

	// The path of the conflicting file.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`

	// The replacement type to use when determining how to resolve the conflict.
	//
	// ReplacementType is a required field
	ReplacementType *string `locationName:"replacementType" type:"string" required:"true" enum:"ReplacementTypeEnum"`
}

// String returns the string representation
func (s ReplaceContentEntry) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReplaceContentEntry) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *ReplaceContentEntry) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "ReplaceContentEntry"}
	if s.FilePath == nil {
		invalidParams.Add(request.NewErrParamRequired("FilePath"))
	}
	if s.ReplacementType == nil {
		invalidParams.Add(request.NewErrParamRequired("ReplacementType"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetContent sets the Content field's value.
func (s *ReplaceContentEntry) SetContent(v []byte) *ReplaceContentEntry {
	s.Content = v
	return s
}

// SetFileMode sets the FileMode field's value.
func (s *ReplaceContentEntry) SetFileMode(v string) *ReplaceContentEntry {
	s.FileMode = &v
	return s
}

// SetFilePath sets the FilePath field's value.
func (s *ReplaceContentEntry) SetFilePath(v string) *ReplaceContentEntry {
	s.FilePath = &v
	return s
}

// SetReplacementType sets the ReplacementType field's value.
func (s *ReplaceContentEntry) SetReplacementType(v string) *ReplaceContentEntry {
	s.ReplacementType = &v
	return s
}

// USE_NEW_CONTENT was specified, but no replacement content has been provided.
type ReplacementContentRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ReplacementContentRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReplacementContentRequiredException) GoString() string {
	return s.String()
}

func newErrorReplacementContentRequiredException(v protocol.ResponseMetadata) error {
	return &ReplacementContentRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ReplacementContentRequiredException) Code() string {
	return "ReplacementContentRequiredException"
}

// Message returns the exception's message.
func (s *ReplacementContentRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ReplacementContentRequiredException) OrigErr() error {
	return nil
}

func (s *ReplacementContentRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ReplacementContentRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ReplacementContentRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A replacement type is required.
type ReplacementTypeRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ReplacementTypeRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ReplacementTypeRequiredException) GoString() string {
	return s.String()
}

func newErrorReplacementTypeRequiredException(v protocol.ResponseMetadata) error {
	return &ReplacementTypeRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ReplacementTypeRequiredException) Code() string {
	return "ReplacementTypeRequiredException"
}

// Message returns the exception's message.
func (s *ReplacementTypeRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ReplacementTypeRequiredException) OrigErr() error {
	return nil
}

func (s *ReplacementTypeRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ReplacementTypeRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ReplacementTypeRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The specified repository does not exist.
type RepositoryDoesNotExistException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RepositoryDoesNotExistException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryDoesNotExistException) GoString() string {
	return s.String()
}

func newErrorRepositoryDoesNotExistException(v protocol.ResponseMetadata) error {
	return &RepositoryDoesNotExistException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RepositoryDoesNotExistException) Code() string {
	return "RepositoryDoesNotExistException"
}

// Message returns the exception's message.
func (s *RepositoryDoesNotExistException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RepositoryDoesNotExistException) OrigErr() error {
	return nil
}

func (s *RepositoryDoesNotExistException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RepositoryDoesNotExistException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RepositoryDoesNotExistException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A repository resource limit was exceeded.
type RepositoryLimitExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RepositoryLimitExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryLimitExceededException) GoString() string {
	return s.String()
}

func newErrorRepositoryLimitExceededException(v protocol.ResponseMetadata) error {
	return &RepositoryLimitExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RepositoryLimitExceededException) Code() string {
	return "RepositoryLimitExceededException"
}

// Message returns the exception's message.
func (s *RepositoryLimitExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RepositoryLimitExceededException) OrigErr() error {
	return nil
}

func (s *RepositoryLimitExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RepositoryLimitExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RepositoryLimitExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about a repository.
type RepositoryMetadata struct {
	_ struct{} `type:"structure"`

	// The ID of the AWS account associated with the repository.
	AccountId *string `locationName:"accountId" type:"string"`

	// The Amazon Resource Name (ARN) of the repository.
	Arn *string `type:"string"`

	// The URL to use for cloning the repository over HTTPS.
	CloneUrlHttp *string `locationName:"cloneUrlHttp" type:"string"`

	// The URL to use for cloning the repository over SSH.
	CloneUrlSsh *string `locationName:"cloneUrlSsh" type:"string"`

	// The date and time the repository was created, in timestamp format.
	CreationDate *time.Time `locationName:"creationDate" type:"timestamp"`

	// The repository's default branch name.
	DefaultBranch *string `locationName:"defaultBranch" min:"1" type:"string"`

	// The date and time the repository was last modified, in timestamp format.
	LastModifiedDate *time.Time `locationName:"lastModifiedDate" type:"timestamp"`

	// A comment or description about the repository.
	RepositoryDescription *string `locationName:"repositoryDescription" type:"string"`

	// The ID of the repository.
	RepositoryId *string `locationName:"repositoryId" type:"string"`

	// The repository's name.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s RepositoryMetadata) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryMetadata) GoString() string {
	return s.String()
}

// SetAccountId sets the AccountId field's value.
func (s *RepositoryMetadata) SetAccountId(v string) *RepositoryMetadata {
	s.AccountId = &v
	return s
}

// SetArn sets the Arn field's value.
func (s *RepositoryMetadata) SetArn(v string) *RepositoryMetadata {
	s.Arn = &v
	return s
}

// SetCloneUrlHttp sets the CloneUrlHttp field's value.
func (s *RepositoryMetadata) SetCloneUrlHttp(v string) *RepositoryMetadata {
	s.CloneUrlHttp = &v
	return s
}

// SetCloneUrlSsh sets the CloneUrlSsh field's value.
func (s *RepositoryMetadata) SetCloneUrlSsh(v string) *RepositoryMetadata {
	s.CloneUrlSsh = &v
	return s
}

// SetCreationDate sets the CreationDate field's value.
func (s *RepositoryMetadata) SetCreationDate(v time.Time) *RepositoryMetadata {
	s.CreationDate = &v
	return s
}

// SetDefaultBranch sets the DefaultBranch field's value.
func (s *RepositoryMetadata) SetDefaultBranch(v string) *RepositoryMetadata {
	s.DefaultBranch = &v
	return s
}

// SetLastModifiedDate sets the LastModifiedDate field's value.
func (s *RepositoryMetadata) SetLastModifiedDate(v time.Time) *RepositoryMetadata {
	s.LastModifiedDate = &v
	return s
}

// SetRepositoryDescription sets the RepositoryDescription field's value.
func (s *RepositoryMetadata) SetRepositoryDescription(v string) *RepositoryMetadata {
	s.RepositoryDescription = &v
	return s
}

// SetRepositoryId sets the RepositoryId field's value.
func (s *RepositoryMetadata) SetRepositoryId(v string) *RepositoryMetadata {
	s.RepositoryId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *RepositoryMetadata) SetRepositoryName(v string) *RepositoryMetadata {
	s.RepositoryName = &v
	return s
}

// The specified repository name already exists.
type RepositoryNameExistsException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RepositoryNameExistsException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryNameExistsException) GoString() string {
	return s.String()
}

func newErrorRepositoryNameExistsException(v protocol.ResponseMetadata) error {
	return &RepositoryNameExistsException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RepositoryNameExistsException) Code() string {
	return "RepositoryNameExistsException"
}

// Message returns the exception's message.
func (s *RepositoryNameExistsException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RepositoryNameExistsException) OrigErr() error {
	return nil
}

func (s *RepositoryNameExistsException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RepositoryNameExistsException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RepositoryNameExistsException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about a repository name and ID.
type RepositoryNameIdPair struct {
	_ struct{} `type:"structure"`

	// The ID associated with the repository.
	RepositoryId *string `locationName:"repositoryId" type:"string"`

	// The name associated with the repository.
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string"`
}

// String returns the string representation
func (s RepositoryNameIdPair) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryNameIdPair) GoString() string {
	return s.String()
}

// SetRepositoryId sets the RepositoryId field's value.
func (s *RepositoryNameIdPair) SetRepositoryId(v string) *RepositoryNameIdPair {
	s.RepositoryId = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *RepositoryNameIdPair) SetRepositoryName(v string) *RepositoryNameIdPair {
	s.RepositoryName = &v
	return s
}

// A repository name is required, but was not specified.
type RepositoryNameRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RepositoryNameRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryNameRequiredException) GoString() string {
	return s.String()
}

func newErrorRepositoryNameRequiredException(v protocol.ResponseMetadata) error {
	return &RepositoryNameRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RepositoryNameRequiredException) Code() string {
	return "RepositoryNameRequiredException"
}

// Message returns the exception's message.
func (s *RepositoryNameRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RepositoryNameRequiredException) OrigErr() error {
	return nil
}

func (s *RepositoryNameRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RepositoryNameRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RepositoryNameRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// At least one repository name object is required, but was not specified.
type RepositoryNamesRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RepositoryNamesRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryNamesRequiredException) GoString() string {
	return s.String()
}

func newErrorRepositoryNamesRequiredException(v protocol.ResponseMetadata) error {
	return &RepositoryNamesRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RepositoryNamesRequiredException) Code() string {
	return "RepositoryNamesRequiredException"
}

// Message returns the exception's message.
func (s *RepositoryNamesRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RepositoryNamesRequiredException) OrigErr() error {
	return nil
}

func (s *RepositoryNamesRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RepositoryNamesRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RepositoryNamesRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The repository does not contain any pull requests with that pull request
// ID. Use GetPullRequest to verify the correct repository name for the pull
// request ID.
type RepositoryNotAssociatedWithPullRequestException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RepositoryNotAssociatedWithPullRequestException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryNotAssociatedWithPullRequestException) GoString() string {
	return s.String()
}

func newErrorRepositoryNotAssociatedWithPullRequestException(v protocol.ResponseMetadata) error {
	return &RepositoryNotAssociatedWithPullRequestException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RepositoryNotAssociatedWithPullRequestException) Code() string {
	return "RepositoryNotAssociatedWithPullRequestException"
}

// Message returns the exception's message.
func (s *RepositoryNotAssociatedWithPullRequestException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RepositoryNotAssociatedWithPullRequestException) OrigErr() error {
	return nil
}

func (s *RepositoryNotAssociatedWithPullRequestException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RepositoryNotAssociatedWithPullRequestException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RepositoryNotAssociatedWithPullRequestException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about a trigger for a repository.
type RepositoryTrigger struct {
	_ struct{} `type:"structure"`

	// The branches to be included in the trigger configuration. If you specify
	// an empty array, the trigger applies to all branches.
	//
	// Although no content is required in the array, you must include the array
	// itself.
	Branches []*string `locationName:"branches" type:"list"`

	// Any custom data associated with the trigger to be included in the information
	// sent to the target of the trigger.
	CustomData *string `locationName:"customData" type:"string"`

	// The ARN of the resource that is the target for a trigger (for example, the
	// ARN of a topic in Amazon SNS).
	//
	// DestinationArn is a required field
	DestinationArn *string `locationName:"destinationArn" type:"string" required:"true"`

	// The repository events that cause the trigger to run actions in another service,
	// such as sending a notification through Amazon SNS.
	//
	// The valid value "all" cannot be used with any other values.
	//
	// Events is a required field
	Events []*string `locationName:"events" type:"list" required:"true"`

	// The name of the trigger.
	//
	// Name is a required field
	Name *string `locationName:"name" type:"string" required:"true"`
}

// String returns the string representation
func (s RepositoryTrigger) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryTrigger) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *RepositoryTrigger) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "RepositoryTrigger"}
	if s.DestinationArn == nil {
		invalidParams.Add(request.NewErrParamRequired("DestinationArn"))
	}
	if s.Events == nil {
		invalidParams.Add(request.NewErrParamRequired("Events"))
	}
	if s.Name == nil {
		invalidParams.Add(request.NewErrParamRequired("Name"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetBranches sets the Branches field's value.
func (s *RepositoryTrigger) SetBranches(v []*string) *RepositoryTrigger {
	s.Branches = v
	return s
}

// SetCustomData sets the CustomData field's value.
func (s *RepositoryTrigger) SetCustomData(v string) *RepositoryTrigger {
	s.CustomData = &v
	return s
}

// SetDestinationArn sets the DestinationArn field's value.
func (s *RepositoryTrigger) SetDestinationArn(v string) *RepositoryTrigger {
	s.DestinationArn = &v
	return s
}

// SetEvents sets the Events field's value.
func (s *RepositoryTrigger) SetEvents(v []*string) *RepositoryTrigger {
	s.Events = v
	return s
}

// SetName sets the Name field's value.
func (s *RepositoryTrigger) SetName(v string) *RepositoryTrigger {
	s.Name = &v
	return s
}

// At least one branch name is required, but was not specified in the trigger
// configuration.
type RepositoryTriggerBranchNameListRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RepositoryTriggerBranchNameListRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryTriggerBranchNameListRequiredException) GoString() string {
	return s.String()
}

func newErrorRepositoryTriggerBranchNameListRequiredException(v protocol.ResponseMetadata) error {
	return &RepositoryTriggerBranchNameListRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RepositoryTriggerBranchNameListRequiredException) Code() string {
	return "RepositoryTriggerBranchNameListRequiredException"
}

// Message returns the exception's message.
func (s *RepositoryTriggerBranchNameListRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RepositoryTriggerBranchNameListRequiredException) OrigErr() error {
	return nil
}

func (s *RepositoryTriggerBranchNameListRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RepositoryTriggerBranchNameListRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RepositoryTriggerBranchNameListRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A destination ARN for the target service for the trigger is required, but
// was not specified.
type RepositoryTriggerDestinationArnRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RepositoryTriggerDestinationArnRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryTriggerDestinationArnRequiredException) GoString() string {
	return s.String()
}

func newErrorRepositoryTriggerDestinationArnRequiredException(v protocol.ResponseMetadata) error {
	return &RepositoryTriggerDestinationArnRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RepositoryTriggerDestinationArnRequiredException) Code() string {
	return "RepositoryTriggerDestinationArnRequiredException"
}

// Message returns the exception's message.
func (s *RepositoryTriggerDestinationArnRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RepositoryTriggerDestinationArnRequiredException) OrigErr() error {
	return nil
}

func (s *RepositoryTriggerDestinationArnRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RepositoryTriggerDestinationArnRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RepositoryTriggerDestinationArnRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// At least one event for the trigger is required, but was not specified.
type RepositoryTriggerEventsListRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RepositoryTriggerEventsListRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryTriggerEventsListRequiredException) GoString() string {
	return s.String()
}

func newErrorRepositoryTriggerEventsListRequiredException(v protocol.ResponseMetadata) error {
	return &RepositoryTriggerEventsListRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RepositoryTriggerEventsListRequiredException) Code() string {
	return "RepositoryTriggerEventsListRequiredException"
}

// Message returns the exception's message.
func (s *RepositoryTriggerEventsListRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RepositoryTriggerEventsListRequiredException) OrigErr() error {
	return nil
}

func (s *RepositoryTriggerEventsListRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RepositoryTriggerEventsListRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RepositoryTriggerEventsListRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A trigger failed to run.
type RepositoryTriggerExecutionFailure struct {
	_ struct{} `type:"structure"`

	// Message information about the trigger that did not run.
	FailureMessage *string `locationName:"failureMessage" type:"string"`

	// The name of the trigger that did not run.
	Trigger *string `locationName:"trigger" type:"string"`
}

// String returns the string representation
func (s RepositoryTriggerExecutionFailure) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryTriggerExecutionFailure) GoString() string {
	return s.String()
}

// SetFailureMessage sets the FailureMessage field's value.
func (s *RepositoryTriggerExecutionFailure) SetFailureMessage(v string) *RepositoryTriggerExecutionFailure {
	s.FailureMessage = &v
	return s
}

// SetTrigger sets the Trigger field's value.
func (s *RepositoryTriggerExecutionFailure) SetTrigger(v string) *RepositoryTriggerExecutionFailure {
	s.Trigger = &v
	return s
}

// A name for the trigger is required, but was not specified.
type RepositoryTriggerNameRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RepositoryTriggerNameRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryTriggerNameRequiredException) GoString() string {
	return s.String()
}

func newErrorRepositoryTriggerNameRequiredException(v protocol.ResponseMetadata) error {
	return &RepositoryTriggerNameRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RepositoryTriggerNameRequiredException) Code() string {
	return "RepositoryTriggerNameRequiredException"
}

// Message returns the exception's message.
func (s *RepositoryTriggerNameRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RepositoryTriggerNameRequiredException) OrigErr() error {
	return nil
}

func (s *RepositoryTriggerNameRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RepositoryTriggerNameRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RepositoryTriggerNameRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The list of triggers for the repository is required, but was not specified.
type RepositoryTriggersListRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RepositoryTriggersListRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RepositoryTriggersListRequiredException) GoString() string {
	return s.String()
}

func newErrorRepositoryTriggersListRequiredException(v protocol.ResponseMetadata) error {
	return &RepositoryTriggersListRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RepositoryTriggersListRequiredException) Code() string {
	return "RepositoryTriggersListRequiredException"
}

// Message returns the exception's message.
func (s *RepositoryTriggersListRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RepositoryTriggersListRequiredException) OrigErr() error {
	return nil
}

func (s *RepositoryTriggersListRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RepositoryTriggersListRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RepositoryTriggersListRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A valid Amazon Resource Name (ARN) for an AWS CodeCommit resource is required.
// For a list of valid resources in AWS CodeCommit, see CodeCommit Resources
// and Operations (https://docs.aws.amazon.com/codecommit/latest/userguide/auth-and-access-control-iam-access-control-identity-based.html#arn-formats)
// in the AWS CodeCommit User Guide.
type ResourceArnRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s ResourceArnRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s ResourceArnRequiredException) GoString() string {
	return s.String()
}

func newErrorResourceArnRequiredException(v protocol.ResponseMetadata) error {
	return &ResourceArnRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *ResourceArnRequiredException) Code() string {
	return "ResourceArnRequiredException"
}

// Message returns the exception's message.
func (s *ResourceArnRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *ResourceArnRequiredException) OrigErr() error {
	return nil
}

func (s *ResourceArnRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *ResourceArnRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *ResourceArnRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The commit cannot be created because one of the changes specifies copying
// or moving a .gitkeep file.
type RestrictedSourceFileException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RestrictedSourceFileException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RestrictedSourceFileException) GoString() string {
	return s.String()
}

func newErrorRestrictedSourceFileException(v protocol.ResponseMetadata) error {
	return &RestrictedSourceFileException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RestrictedSourceFileException) Code() string {
	return "RestrictedSourceFileException"
}

// Message returns the exception's message.
func (s *RestrictedSourceFileException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RestrictedSourceFileException) OrigErr() error {
	return nil
}

func (s *RestrictedSourceFileException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RestrictedSourceFileException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RestrictedSourceFileException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A revision ID is required, but was not provided.
type RevisionIdRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RevisionIdRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RevisionIdRequiredException) GoString() string {
	return s.String()
}

func newErrorRevisionIdRequiredException(v protocol.ResponseMetadata) error {
	return &RevisionIdRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RevisionIdRequiredException) Code() string {
	return "RevisionIdRequiredException"
}

// Message returns the exception's message.
func (s *RevisionIdRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RevisionIdRequiredException) OrigErr() error {
	return nil
}

func (s *RevisionIdRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RevisionIdRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RevisionIdRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The revision ID provided in the request does not match the current revision
// ID. Use GetPullRequest to retrieve the current revision ID.
type RevisionNotCurrentException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s RevisionNotCurrentException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s RevisionNotCurrentException) GoString() string {
	return s.String()
}

func newErrorRevisionNotCurrentException(v protocol.ResponseMetadata) error {
	return &RevisionNotCurrentException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *RevisionNotCurrentException) Code() string {
	return "RevisionNotCurrentException"
}

// Message returns the exception's message.
func (s *RevisionNotCurrentException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *RevisionNotCurrentException) OrigErr() error {
	return nil
}

func (s *RevisionNotCurrentException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *RevisionNotCurrentException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *RevisionNotCurrentException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The file was not added or updated because the content of the file is exactly
// the same as the content of that file in the repository and branch that you
// specified.
type SameFileContentException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s SameFileContentException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SameFileContentException) GoString() string {
	return s.String()
}

func newErrorSameFileContentException(v protocol.ResponseMetadata) error {
	return &SameFileContentException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *SameFileContentException) Code() string {
	return "SameFileContentException"
}

// Message returns the exception's message.
func (s *SameFileContentException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *SameFileContentException) OrigErr() error {
	return nil
}

func (s *SameFileContentException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *SameFileContentException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *SameFileContentException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The commit cannot be created because one or more changes in this commit duplicate
// actions in the same file path. For example, you cannot make the same delete
// request to the same file in the same file path twice, or make a delete request
// and a move request to the same file as part of the same commit.
type SamePathRequestException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s SamePathRequestException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SamePathRequestException) GoString() string {
	return s.String()
}

func newErrorSamePathRequestException(v protocol.ResponseMetadata) error {
	return &SamePathRequestException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *SamePathRequestException) Code() string {
	return "SamePathRequestException"
}

// Message returns the exception's message.
func (s *SamePathRequestException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *SamePathRequestException) OrigErr() error {
	return nil
}

func (s *SamePathRequestException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *SamePathRequestException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *SamePathRequestException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about the file mode changes.
type SetFileModeEntry struct {
	_ struct{} `type:"structure"`

	// The file mode for the file.
	//
	// FileMode is a required field
	FileMode *string `locationName:"fileMode" type:"string" required:"true" enum:"FileModeTypeEnum"`

	// The full path to the file, including the name of the file.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`
}

// String returns the string representation
func (s SetFileModeEntry) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SetFileModeEntry) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SetFileModeEntry) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "SetFileModeEntry"}
	if s.FileMode == nil {
		invalidParams.Add(request.NewErrParamRequired("FileMode"))
	}
	if s.FilePath == nil {
		invalidParams.Add(request.NewErrParamRequired("FilePath"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetFileMode sets the FileMode field's value.
func (s *SetFileModeEntry) SetFileMode(v string) *SetFileModeEntry {
	s.FileMode = &v
	return s
}

// SetFilePath sets the FilePath field's value.
func (s *SetFileModeEntry) SetFilePath(v string) *SetFileModeEntry {
	s.FilePath = &v
	return s
}

// The source branch and destination branch for the pull request are the same.
// You must specify different branches for the source and destination.
type SourceAndDestinationAreSameException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s SourceAndDestinationAreSameException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SourceAndDestinationAreSameException) GoString() string {
	return s.String()
}

func newErrorSourceAndDestinationAreSameException(v protocol.ResponseMetadata) error {
	return &SourceAndDestinationAreSameException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *SourceAndDestinationAreSameException) Code() string {
	return "SourceAndDestinationAreSameException"
}

// Message returns the exception's message.
func (s *SourceAndDestinationAreSameException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *SourceAndDestinationAreSameException) OrigErr() error {
	return nil
}

func (s *SourceAndDestinationAreSameException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *SourceAndDestinationAreSameException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *SourceAndDestinationAreSameException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The commit cannot be created because no source files or file content have
// been specified for the commit.
type SourceFileOrContentRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s SourceFileOrContentRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SourceFileOrContentRequiredException) GoString() string {
	return s.String()
}

func newErrorSourceFileOrContentRequiredException(v protocol.ResponseMetadata) error {
	return &SourceFileOrContentRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *SourceFileOrContentRequiredException) Code() string {
	return "SourceFileOrContentRequiredException"
}

// Message returns the exception's message.
func (s *SourceFileOrContentRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *SourceFileOrContentRequiredException) OrigErr() error {
	return nil
}

func (s *SourceFileOrContentRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *SourceFileOrContentRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *SourceFileOrContentRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Information about a source file that is part of changes made in a commit.
type SourceFileSpecifier struct {
	_ struct{} `type:"structure"`

	// The full path to the file, including the name of the file.
	//
	// FilePath is a required field
	FilePath *string `locationName:"filePath" type:"string" required:"true"`

	// Whether to remove the source file from the parent commit.
	IsMove *bool `locationName:"isMove" type:"boolean"`
}

// String returns the string representation
func (s SourceFileSpecifier) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SourceFileSpecifier) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *SourceFileSpecifier) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "SourceFileSpecifier"}
	if s.FilePath == nil {
		invalidParams.Add(request.NewErrParamRequired("FilePath"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetFilePath sets the FilePath field's value.
func (s *SourceFileSpecifier) SetFilePath(v string) *SourceFileSpecifier {
	s.FilePath = &v
	return s
}

// SetIsMove sets the IsMove field's value.
func (s *SourceFileSpecifier) SetIsMove(v bool) *SourceFileSpecifier {
	s.IsMove = &v
	return s
}

// Returns information about a submodule reference in a repository folder.
type SubModule struct {
	_ struct{} `type:"structure"`

	// The fully qualified path to the folder that contains the reference to the
	// submodule.
	AbsolutePath *string `locationName:"absolutePath" type:"string"`

	// The commit ID that contains the reference to the submodule.
	CommitId *string `locationName:"commitId" type:"string"`

	// The relative path of the submodule from the folder where the query originated.
	RelativePath *string `locationName:"relativePath" type:"string"`
}

// String returns the string representation
func (s SubModule) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SubModule) GoString() string {
	return s.String()
}

// SetAbsolutePath sets the AbsolutePath field's value.
func (s *SubModule) SetAbsolutePath(v string) *SubModule {
	s.AbsolutePath = &v
	return s
}

// SetCommitId sets the CommitId field's value.
func (s *SubModule) SetCommitId(v string) *SubModule {
	s.CommitId = &v
	return s
}

// SetRelativePath sets the RelativePath field's value.
func (s *SubModule) SetRelativePath(v string) *SubModule {
	s.RelativePath = &v
	return s
}

// Returns information about a symbolic link in a repository folder.
type SymbolicLink struct {
	_ struct{} `type:"structure"`

	// The fully qualified path to the folder that contains the symbolic link.
	AbsolutePath *string `locationName:"absolutePath" type:"string"`

	// The blob ID that contains the information about the symbolic link.
	BlobId *string `locationName:"blobId" type:"string"`

	// The file mode permissions of the blob that cotains information about the
	// symbolic link.
	FileMode *string `locationName:"fileMode" type:"string" enum:"FileModeTypeEnum"`

	// The relative path of the symbolic link from the folder where the query originated.
	RelativePath *string `locationName:"relativePath" type:"string"`
}

// String returns the string representation
func (s SymbolicLink) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s SymbolicLink) GoString() string {
	return s.String()
}

// SetAbsolutePath sets the AbsolutePath field's value.
func (s *SymbolicLink) SetAbsolutePath(v string) *SymbolicLink {
	s.AbsolutePath = &v
	return s
}

// SetBlobId sets the BlobId field's value.
func (s *SymbolicLink) SetBlobId(v string) *SymbolicLink {
	s.BlobId = &v
	return s
}

// SetFileMode sets the FileMode field's value.
func (s *SymbolicLink) SetFileMode(v string) *SymbolicLink {
	s.FileMode = &v
	return s
}

// SetRelativePath sets the RelativePath field's value.
func (s *SymbolicLink) SetRelativePath(v string) *SymbolicLink {
	s.RelativePath = &v
	return s
}

// A list of tag keys is required. The list cannot be empty or null.
type TagKeysListRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s TagKeysListRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagKeysListRequiredException) GoString() string {
	return s.String()
}

func newErrorTagKeysListRequiredException(v protocol.ResponseMetadata) error {
	return &TagKeysListRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *TagKeysListRequiredException) Code() string {
	return "TagKeysListRequiredException"
}

// Message returns the exception's message.
func (s *TagKeysListRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *TagKeysListRequiredException) OrigErr() error {
	return nil
}

func (s *TagKeysListRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *TagKeysListRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *TagKeysListRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The tag policy is not valid.
type TagPolicyException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s TagPolicyException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagPolicyException) GoString() string {
	return s.String()
}

func newErrorTagPolicyException(v protocol.ResponseMetadata) error {
	return &TagPolicyException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *TagPolicyException) Code() string {
	return "TagPolicyException"
}

// Message returns the exception's message.
func (s *TagPolicyException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *TagPolicyException) OrigErr() error {
	return nil
}

func (s *TagPolicyException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *TagPolicyException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *TagPolicyException) RequestID() string {
	return s.RespMetadata.RequestID
}

type TagResourceInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the resource to which you want to add or
	// update tags.
	//
	// ResourceArn is a required field
	ResourceArn *string `locationName:"resourceArn" type:"string" required:"true"`

	// The key-value pair to use when tagging this repository.
	//
	// Tags is a required field
	Tags map[string]*string `locationName:"tags" type:"map" required:"true"`
}

// String returns the string representation
func (s TagResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TagResourceInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "TagResourceInput"}
	if s.ResourceArn == nil {
		invalidParams.Add(request.NewErrParamRequired("ResourceArn"))
	}
	if s.Tags == nil {
		invalidParams.Add(request.NewErrParamRequired("Tags"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetResourceArn sets the ResourceArn field's value.
func (s *TagResourceInput) SetResourceArn(v string) *TagResourceInput {
	s.ResourceArn = &v
	return s
}

// SetTags sets the Tags field's value.
func (s *TagResourceInput) SetTags(v map[string]*string) *TagResourceInput {
	s.Tags = v
	return s
}

type TagResourceOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s TagResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagResourceOutput) GoString() string {
	return s.String()
}

// A map of tags is required.
type TagsMapRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s TagsMapRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TagsMapRequiredException) GoString() string {
	return s.String()
}

func newErrorTagsMapRequiredException(v protocol.ResponseMetadata) error {
	return &TagsMapRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *TagsMapRequiredException) Code() string {
	return "TagsMapRequiredException"
}

// Message returns the exception's message.
func (s *TagsMapRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *TagsMapRequiredException) OrigErr() error {
	return nil
}

func (s *TagsMapRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *TagsMapRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *TagsMapRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Returns information about a target for a pull request.
type Target struct {
	_ struct{} `type:"structure"`

	// The branch of the repository where the pull request changes are merged. Also
	// known as the destination branch.
	DestinationReference *string `locationName:"destinationReference" type:"string"`

	// The name of the repository that contains the pull request.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The branch of the repository that contains the changes for the pull request.
	// Also known as the source branch.
	//
	// SourceReference is a required field
	SourceReference *string `locationName:"sourceReference" type:"string" required:"true"`
}

// String returns the string representation
func (s Target) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s Target) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *Target) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "Target"}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.SourceReference == nil {
		invalidParams.Add(request.NewErrParamRequired("SourceReference"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetDestinationReference sets the DestinationReference field's value.
func (s *Target) SetDestinationReference(v string) *Target {
	s.DestinationReference = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *Target) SetRepositoryName(v string) *Target {
	s.RepositoryName = &v
	return s
}

// SetSourceReference sets the SourceReference field's value.
func (s *Target) SetSourceReference(v string) *Target {
	s.SourceReference = &v
	return s
}

// A pull request target is required. It cannot be empty or null. A pull request
// target must contain the full values for the repository name, source branch,
// and destination branch for the pull request.
type TargetRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s TargetRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TargetRequiredException) GoString() string {
	return s.String()
}

func newErrorTargetRequiredException(v protocol.ResponseMetadata) error {
	return &TargetRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *TargetRequiredException) Code() string {
	return "TargetRequiredException"
}

// Message returns the exception's message.
func (s *TargetRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *TargetRequiredException) OrigErr() error {
	return nil
}

func (s *TargetRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *TargetRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *TargetRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// An array of target objects is required. It cannot be empty or null.
type TargetsRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s TargetsRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TargetsRequiredException) GoString() string {
	return s.String()
}

func newErrorTargetsRequiredException(v protocol.ResponseMetadata) error {
	return &TargetsRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *TargetsRequiredException) Code() string {
	return "TargetsRequiredException"
}

// Message returns the exception's message.
func (s *TargetsRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *TargetsRequiredException) OrigErr() error {
	return nil
}

func (s *TargetsRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *TargetsRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *TargetsRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// Represents the input of a test repository triggers operation.
type TestRepositoryTriggersInput struct {
	_ struct{} `type:"structure"`

	// The name of the repository in which to test the triggers.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`

	// The list of triggers to test.
	//
	// Triggers is a required field
	Triggers []*RepositoryTrigger `locationName:"triggers" type:"list" required:"true"`
}

// String returns the string representation
func (s TestRepositoryTriggersInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestRepositoryTriggersInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *TestRepositoryTriggersInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "TestRepositoryTriggersInput"}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}
	if s.Triggers == nil {
		invalidParams.Add(request.NewErrParamRequired("Triggers"))
	}
	if s.Triggers != nil {
		for i, v := range s.Triggers {
			if v == nil {
				continue
			}
			if err := v.Validate(); err != nil {
				invalidParams.AddNested(fmt.Sprintf("%s[%v]", "Triggers", i), err.(request.ErrInvalidParams))
			}
		}
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *TestRepositoryTriggersInput) SetRepositoryName(v string) *TestRepositoryTriggersInput {
	s.RepositoryName = &v
	return s
}

// SetTriggers sets the Triggers field's value.
func (s *TestRepositoryTriggersInput) SetTriggers(v []*RepositoryTrigger) *TestRepositoryTriggersInput {
	s.Triggers = v
	return s
}

// Represents the output of a test repository triggers operation.
type TestRepositoryTriggersOutput struct {
	_ struct{} `type:"structure"`

	// The list of triggers that were not tested. This list provides the names of
	// the triggers that could not be tested, separated by commas.
	FailedExecutions []*RepositoryTriggerExecutionFailure `locationName:"failedExecutions" type:"list"`

	// The list of triggers that were successfully tested. This list provides the
	// names of the triggers that were successfully tested, separated by commas.
	SuccessfulExecutions []*string `locationName:"successfulExecutions" type:"list"`
}

// String returns the string representation
func (s TestRepositoryTriggersOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TestRepositoryTriggersOutput) GoString() string {
	return s.String()
}

// SetFailedExecutions sets the FailedExecutions field's value.
func (s *TestRepositoryTriggersOutput) SetFailedExecutions(v []*RepositoryTriggerExecutionFailure) *TestRepositoryTriggersOutput {
	s.FailedExecutions = v
	return s
}

// SetSuccessfulExecutions sets the SuccessfulExecutions field's value.
func (s *TestRepositoryTriggersOutput) SetSuccessfulExecutions(v []*string) *TestRepositoryTriggersOutput {
	s.SuccessfulExecutions = v
	return s
}

// The tip of the source branch in the destination repository does not match
// the tip of the source branch specified in your request. The pull request
// might have been updated. Make sure that you have the latest changes.
type TipOfSourceReferenceIsDifferentException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s TipOfSourceReferenceIsDifferentException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TipOfSourceReferenceIsDifferentException) GoString() string {
	return s.String()
}

func newErrorTipOfSourceReferenceIsDifferentException(v protocol.ResponseMetadata) error {
	return &TipOfSourceReferenceIsDifferentException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *TipOfSourceReferenceIsDifferentException) Code() string {
	return "TipOfSourceReferenceIsDifferentException"
}

// Message returns the exception's message.
func (s *TipOfSourceReferenceIsDifferentException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *TipOfSourceReferenceIsDifferentException) OrigErr() error {
	return nil
}

func (s *TipOfSourceReferenceIsDifferentException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *TipOfSourceReferenceIsDifferentException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *TipOfSourceReferenceIsDifferentException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The divergence between the tips of the provided commit specifiers is too
// great to determine whether there might be any merge conflicts. Locally compare
// the specifiers using git diff or a diff tool.
type TipsDivergenceExceededException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s TipsDivergenceExceededException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TipsDivergenceExceededException) GoString() string {
	return s.String()
}

func newErrorTipsDivergenceExceededException(v protocol.ResponseMetadata) error {
	return &TipsDivergenceExceededException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *TipsDivergenceExceededException) Code() string {
	return "TipsDivergenceExceededException"
}

// Message returns the exception's message.
func (s *TipsDivergenceExceededException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *TipsDivergenceExceededException) OrigErr() error {
	return nil
}

func (s *TipsDivergenceExceededException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *TipsDivergenceExceededException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *TipsDivergenceExceededException) RequestID() string {
	return s.RespMetadata.RequestID
}

// A pull request title is required. It cannot be empty or null.
type TitleRequiredException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s TitleRequiredException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TitleRequiredException) GoString() string {
	return s.String()
}

func newErrorTitleRequiredException(v protocol.ResponseMetadata) error {
	return &TitleRequiredException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *TitleRequiredException) Code() string {
	return "TitleRequiredException"
}

// Message returns the exception's message.
func (s *TitleRequiredException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *TitleRequiredException) OrigErr() error {
	return nil
}

func (s *TitleRequiredException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *TitleRequiredException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *TitleRequiredException) RequestID() string {
	return s.RespMetadata.RequestID
}

// The maximum number of tags for an AWS CodeCommit resource has been exceeded.
type TooManyTagsException struct {
	_            struct{}                  `type:"structure"`
	RespMetadata protocol.ResponseMetadata `json:"-" xml:"-"`

	Message_ *string `locationName:"message" type:"string"`
}

// String returns the string representation
func (s TooManyTagsException) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s TooManyTagsException) GoString() string {
	return s.String()
}

func newErrorTooManyTagsException(v protocol.ResponseMetadata) error {
	return &TooManyTagsException{
		RespMetadata: v,
	}
}

// Code returns the exception type name.
func (s *TooManyTagsException) Code() string {
	return "TooManyTagsException"
}

// Message returns the exception's message.
func (s *TooManyTagsException) Message() string {
	if s.Message_ != nil {
		return *s.Message_
	}
	return ""
}

// OrigErr always returns nil, satisfies awserr.Error interface.
func (s *TooManyTagsException) OrigErr() error {
	return nil
}

func (s *TooManyTagsException) Error() string {
	return fmt.Sprintf("%s: %s", s.Code(), s.Message())
}

// Status code returns the HTTP status code for the request's response error.
func (s *TooManyTagsException) StatusCode() int {
	return s.RespMetadata.StatusCode
}

// RequestID returns the service's response RequestID for request.
func (s *TooManyTagsException) RequestID() string {
	return s.RespMetadata.RequestID
}

type UntagResourceInput struct {
	_ struct{} `type:"structure"`

	// The Amazon Resource Name (ARN) of the resource to which you want to remove
	// tags.
	//
	// ResourceArn is a required field
	ResourceArn *string `locationName:"resourceArn" type:"string" required:"true"`

	// The tag key for each tag that you want to remove from the resource.
	//
	// TagKeys is a required field
	TagKeys []*string `locationName:"tagKeys" type:"list" required:"true"`
}

// String returns the string representation
func (s UntagResourceInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UntagResourceInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UntagResourceInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UntagResourceInput"}
	if s.ResourceArn == nil {
		invalidParams.Add(request.NewErrParamRequired("ResourceArn"))
	}
	if s.TagKeys == nil {
		invalidParams.Add(request.NewErrParamRequired("TagKeys"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetResourceArn sets the ResourceArn field's value.
func (s *UntagResourceInput) SetResourceArn(v string) *UntagResourceInput {
	s.ResourceArn = &v
	return s
}

// SetTagKeys sets the TagKeys field's value.
func (s *UntagResourceInput) SetTagKeys(v []*string) *UntagResourceInput {
	s.TagKeys = v
	return s
}

type UntagResourceOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s UntagResourceOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UntagResourceOutput) GoString() string {
	return s.String()
}

type UpdateApprovalRuleTemplateContentInput struct {
	_ struct{} `type:"structure"`

	// The name of the approval rule template where you want to update the content
	// of the rule.
	//
	// ApprovalRuleTemplateName is a required field
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string" required:"true"`

	// The SHA-256 hash signature for the content of the approval rule. You can
	// retrieve this information by using GetPullRequest.
	ExistingRuleContentSha256 *string `locationName:"existingRuleContentSha256" type:"string"`

	// The content that replaces the existing content of the rule. Content statements
	// must be complete. You cannot provide only the changes.
	//
	// NewRuleContent is a required field
	NewRuleContent *string `locationName:"newRuleContent" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateApprovalRuleTemplateContentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateApprovalRuleTemplateContentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateApprovalRuleTemplateContentInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdateApprovalRuleTemplateContentInput"}
	if s.ApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateName"))
	}
	if s.ApprovalRuleTemplateName != nil && len(*s.ApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleTemplateName", 1))
	}
	if s.NewRuleContent == nil {
		invalidParams.Add(request.NewErrParamRequired("NewRuleContent"))
	}
	if s.NewRuleContent != nil && len(*s.NewRuleContent) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("NewRuleContent", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *UpdateApprovalRuleTemplateContentInput) SetApprovalRuleTemplateName(v string) *UpdateApprovalRuleTemplateContentInput {
	s.ApprovalRuleTemplateName = &v
	return s
}

// SetExistingRuleContentSha256 sets the ExistingRuleContentSha256 field's value.
func (s *UpdateApprovalRuleTemplateContentInput) SetExistingRuleContentSha256(v string) *UpdateApprovalRuleTemplateContentInput {
	s.ExistingRuleContentSha256 = &v
	return s
}

// SetNewRuleContent sets the NewRuleContent field's value.
func (s *UpdateApprovalRuleTemplateContentInput) SetNewRuleContent(v string) *UpdateApprovalRuleTemplateContentInput {
	s.NewRuleContent = &v
	return s
}

type UpdateApprovalRuleTemplateContentOutput struct {
	_ struct{} `type:"structure"`

	// Returns information about an approval rule template.
	//
	// ApprovalRuleTemplate is a required field
	ApprovalRuleTemplate *ApprovalRuleTemplate `locationName:"approvalRuleTemplate" type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateApprovalRuleTemplateContentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateApprovalRuleTemplateContentOutput) GoString() string {
	return s.String()
}

// SetApprovalRuleTemplate sets the ApprovalRuleTemplate field's value.
func (s *UpdateApprovalRuleTemplateContentOutput) SetApprovalRuleTemplate(v *ApprovalRuleTemplate) *UpdateApprovalRuleTemplateContentOutput {
	s.ApprovalRuleTemplate = v
	return s
}

type UpdateApprovalRuleTemplateDescriptionInput struct {
	_ struct{} `type:"structure"`

	// The updated description of the approval rule template.
	//
	// ApprovalRuleTemplateDescription is a required field
	ApprovalRuleTemplateDescription *string `locationName:"approvalRuleTemplateDescription" type:"string" required:"true"`

	// The name of the template for which you want to update the description.
	//
	// ApprovalRuleTemplateName is a required field
	ApprovalRuleTemplateName *string `locationName:"approvalRuleTemplateName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateApprovalRuleTemplateDescriptionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateApprovalRuleTemplateDescriptionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateApprovalRuleTemplateDescriptionInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdateApprovalRuleTemplateDescriptionInput"}
	if s.ApprovalRuleTemplateDescription == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateDescription"))
	}
	if s.ApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleTemplateName"))
	}
	if s.ApprovalRuleTemplateName != nil && len(*s.ApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleTemplateName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleTemplateDescription sets the ApprovalRuleTemplateDescription field's value.
func (s *UpdateApprovalRuleTemplateDescriptionInput) SetApprovalRuleTemplateDescription(v string) *UpdateApprovalRuleTemplateDescriptionInput {
	s.ApprovalRuleTemplateDescription = &v
	return s
}

// SetApprovalRuleTemplateName sets the ApprovalRuleTemplateName field's value.
func (s *UpdateApprovalRuleTemplateDescriptionInput) SetApprovalRuleTemplateName(v string) *UpdateApprovalRuleTemplateDescriptionInput {
	s.ApprovalRuleTemplateName = &v
	return s
}

type UpdateApprovalRuleTemplateDescriptionOutput struct {
	_ struct{} `type:"structure"`

	// The structure and content of the updated approval rule template.
	//
	// ApprovalRuleTemplate is a required field
	ApprovalRuleTemplate *ApprovalRuleTemplate `locationName:"approvalRuleTemplate" type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateApprovalRuleTemplateDescriptionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateApprovalRuleTemplateDescriptionOutput) GoString() string {
	return s.String()
}

// SetApprovalRuleTemplate sets the ApprovalRuleTemplate field's value.
func (s *UpdateApprovalRuleTemplateDescriptionOutput) SetApprovalRuleTemplate(v *ApprovalRuleTemplate) *UpdateApprovalRuleTemplateDescriptionOutput {
	s.ApprovalRuleTemplate = v
	return s
}

type UpdateApprovalRuleTemplateNameInput struct {
	_ struct{} `type:"structure"`

	// The new name you want to apply to the approval rule template.
	//
	// NewApprovalRuleTemplateName is a required field
	NewApprovalRuleTemplateName *string `locationName:"newApprovalRuleTemplateName" min:"1" type:"string" required:"true"`

	// The current name of the approval rule template.
	//
	// OldApprovalRuleTemplateName is a required field
	OldApprovalRuleTemplateName *string `locationName:"oldApprovalRuleTemplateName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateApprovalRuleTemplateNameInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateApprovalRuleTemplateNameInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateApprovalRuleTemplateNameInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdateApprovalRuleTemplateNameInput"}
	if s.NewApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("NewApprovalRuleTemplateName"))
	}
	if s.NewApprovalRuleTemplateName != nil && len(*s.NewApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("NewApprovalRuleTemplateName", 1))
	}
	if s.OldApprovalRuleTemplateName == nil {
		invalidParams.Add(request.NewErrParamRequired("OldApprovalRuleTemplateName"))
	}
	if s.OldApprovalRuleTemplateName != nil && len(*s.OldApprovalRuleTemplateName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("OldApprovalRuleTemplateName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetNewApprovalRuleTemplateName sets the NewApprovalRuleTemplateName field's value.
func (s *UpdateApprovalRuleTemplateNameInput) SetNewApprovalRuleTemplateName(v string) *UpdateApprovalRuleTemplateNameInput {
	s.NewApprovalRuleTemplateName = &v
	return s
}

// SetOldApprovalRuleTemplateName sets the OldApprovalRuleTemplateName field's value.
func (s *UpdateApprovalRuleTemplateNameInput) SetOldApprovalRuleTemplateName(v string) *UpdateApprovalRuleTemplateNameInput {
	s.OldApprovalRuleTemplateName = &v
	return s
}

type UpdateApprovalRuleTemplateNameOutput struct {
	_ struct{} `type:"structure"`

	// The structure and content of the updated approval rule template.
	//
	// ApprovalRuleTemplate is a required field
	ApprovalRuleTemplate *ApprovalRuleTemplate `locationName:"approvalRuleTemplate" type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdateApprovalRuleTemplateNameOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateApprovalRuleTemplateNameOutput) GoString() string {
	return s.String()
}

// SetApprovalRuleTemplate sets the ApprovalRuleTemplate field's value.
func (s *UpdateApprovalRuleTemplateNameOutput) SetApprovalRuleTemplate(v *ApprovalRuleTemplate) *UpdateApprovalRuleTemplateNameOutput {
	s.ApprovalRuleTemplate = v
	return s
}

type UpdateCommentInput struct {
	_ struct{} `type:"structure"`

	// The system-generated ID of the comment you want to update. To get this ID,
	// use GetCommentsForComparedCommit or GetCommentsForPullRequest.
	//
	// CommentId is a required field
	CommentId *string `locationName:"commentId" type:"string" required:"true"`

	// The updated content to replace the existing content of the comment.
	//
	// Content is a required field
	Content *string `locationName:"content" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateCommentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateCommentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateCommentInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdateCommentInput"}
	if s.CommentId == nil {
		invalidParams.Add(request.NewErrParamRequired("CommentId"))
	}
	if s.Content == nil {
		invalidParams.Add(request.NewErrParamRequired("Content"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetCommentId sets the CommentId field's value.
func (s *UpdateCommentInput) SetCommentId(v string) *UpdateCommentInput {
	s.CommentId = &v
	return s
}

// SetContent sets the Content field's value.
func (s *UpdateCommentInput) SetContent(v string) *UpdateCommentInput {
	s.Content = &v
	return s
}

type UpdateCommentOutput struct {
	_ struct{} `type:"structure"`

	// Information about the updated comment.
	Comment *Comment `locationName:"comment" type:"structure"`
}

// String returns the string representation
func (s UpdateCommentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateCommentOutput) GoString() string {
	return s.String()
}

// SetComment sets the Comment field's value.
func (s *UpdateCommentOutput) SetComment(v *Comment) *UpdateCommentOutput {
	s.Comment = v
	return s
}

// Represents the input of an update default branch operation.
type UpdateDefaultBranchInput struct {
	_ struct{} `type:"structure"`

	// The name of the branch to set as the default.
	//
	// DefaultBranchName is a required field
	DefaultBranchName *string `locationName:"defaultBranchName" min:"1" type:"string" required:"true"`

	// The name of the repository to set or change the default branch for.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateDefaultBranchInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDefaultBranchInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateDefaultBranchInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdateDefaultBranchInput"}
	if s.DefaultBranchName == nil {
		invalidParams.Add(request.NewErrParamRequired("DefaultBranchName"))
	}
	if s.DefaultBranchName != nil && len(*s.DefaultBranchName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("DefaultBranchName", 1))
	}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetDefaultBranchName sets the DefaultBranchName field's value.
func (s *UpdateDefaultBranchInput) SetDefaultBranchName(v string) *UpdateDefaultBranchInput {
	s.DefaultBranchName = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *UpdateDefaultBranchInput) SetRepositoryName(v string) *UpdateDefaultBranchInput {
	s.RepositoryName = &v
	return s
}

type UpdateDefaultBranchOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s UpdateDefaultBranchOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateDefaultBranchOutput) GoString() string {
	return s.String()
}

type UpdatePullRequestApprovalRuleContentInput struct {
	_ struct{} `type:"structure"`

	// The name of the approval rule you want to update.
	//
	// ApprovalRuleName is a required field
	ApprovalRuleName *string `locationName:"approvalRuleName" min:"1" type:"string" required:"true"`

	// The SHA-256 hash signature for the content of the approval rule. You can
	// retrieve this information by using GetPullRequest.
	ExistingRuleContentSha256 *string `locationName:"existingRuleContentSha256" type:"string"`

	// The updated content for the approval rule.
	//
	// When you update the content of the approval rule, you can specify approvers
	// in an approval pool in one of two ways:
	//
	//    * CodeCommitApprovers: This option only requires an AWS account and a
	//    resource. It can be used for both IAM users and federated access users
	//    whose name matches the provided resource name. This is a very powerful
	//    option that offers a great deal of flexibility. For example, if you specify
	//    the AWS account 123456789012 and Mary_Major, all of the following are
	//    counted as approvals coming from that user: An IAM user in the account
	//    (arn:aws:iam::123456789012:user/Mary_Major) A federated user identified
	//    in IAM as Mary_Major (arn:aws:sts::123456789012:federated-user/Mary_Major)
	//    This option does not recognize an active session of someone assuming the
	//    role of CodeCommitReview with a role session name of Mary_Major (arn:aws:sts::123456789012:assumed-role/CodeCommitReview/Mary_Major)
	//    unless you include a wildcard (*Mary_Major).
	//
	//    * Fully qualified ARN: This option allows you to specify the fully qualified
	//    Amazon Resource Name (ARN) of the IAM user or role.
	//
	// For more information about IAM ARNs, wildcards, and formats, see IAM Identifiers
	// (https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html)
	// in the IAM User Guide.
	//
	// NewRuleContent is a required field
	NewRuleContent *string `locationName:"newRuleContent" min:"1" type:"string" required:"true"`

	// The system-generated ID of the pull request.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdatePullRequestApprovalRuleContentInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdatePullRequestApprovalRuleContentInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdatePullRequestApprovalRuleContentInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdatePullRequestApprovalRuleContentInput"}
	if s.ApprovalRuleName == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalRuleName"))
	}
	if s.ApprovalRuleName != nil && len(*s.ApprovalRuleName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("ApprovalRuleName", 1))
	}
	if s.NewRuleContent == nil {
		invalidParams.Add(request.NewErrParamRequired("NewRuleContent"))
	}
	if s.NewRuleContent != nil && len(*s.NewRuleContent) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("NewRuleContent", 1))
	}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalRuleName sets the ApprovalRuleName field's value.
func (s *UpdatePullRequestApprovalRuleContentInput) SetApprovalRuleName(v string) *UpdatePullRequestApprovalRuleContentInput {
	s.ApprovalRuleName = &v
	return s
}

// SetExistingRuleContentSha256 sets the ExistingRuleContentSha256 field's value.
func (s *UpdatePullRequestApprovalRuleContentInput) SetExistingRuleContentSha256(v string) *UpdatePullRequestApprovalRuleContentInput {
	s.ExistingRuleContentSha256 = &v
	return s
}

// SetNewRuleContent sets the NewRuleContent field's value.
func (s *UpdatePullRequestApprovalRuleContentInput) SetNewRuleContent(v string) *UpdatePullRequestApprovalRuleContentInput {
	s.NewRuleContent = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *UpdatePullRequestApprovalRuleContentInput) SetPullRequestId(v string) *UpdatePullRequestApprovalRuleContentInput {
	s.PullRequestId = &v
	return s
}

type UpdatePullRequestApprovalRuleContentOutput struct {
	_ struct{} `type:"structure"`

	// Information about the updated approval rule.
	//
	// ApprovalRule is a required field
	ApprovalRule *ApprovalRule `locationName:"approvalRule" type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdatePullRequestApprovalRuleContentOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdatePullRequestApprovalRuleContentOutput) GoString() string {
	return s.String()
}

// SetApprovalRule sets the ApprovalRule field's value.
func (s *UpdatePullRequestApprovalRuleContentOutput) SetApprovalRule(v *ApprovalRule) *UpdatePullRequestApprovalRuleContentOutput {
	s.ApprovalRule = v
	return s
}

type UpdatePullRequestApprovalStateInput struct {
	_ struct{} `type:"structure"`

	// The approval state to associate with the user on the pull request.
	//
	// ApprovalState is a required field
	ApprovalState *string `locationName:"approvalState" type:"string" required:"true" enum:"ApprovalState"`

	// The system-generated ID of the pull request.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The system-generated ID of the revision.
	//
	// RevisionId is a required field
	RevisionId *string `locationName:"revisionId" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdatePullRequestApprovalStateInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdatePullRequestApprovalStateInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdatePullRequestApprovalStateInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdatePullRequestApprovalStateInput"}
	if s.ApprovalState == nil {
		invalidParams.Add(request.NewErrParamRequired("ApprovalState"))
	}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.RevisionId == nil {
		invalidParams.Add(request.NewErrParamRequired("RevisionId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetApprovalState sets the ApprovalState field's value.
func (s *UpdatePullRequestApprovalStateInput) SetApprovalState(v string) *UpdatePullRequestApprovalStateInput {
	s.ApprovalState = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *UpdatePullRequestApprovalStateInput) SetPullRequestId(v string) *UpdatePullRequestApprovalStateInput {
	s.PullRequestId = &v
	return s
}

// SetRevisionId sets the RevisionId field's value.
func (s *UpdatePullRequestApprovalStateInput) SetRevisionId(v string) *UpdatePullRequestApprovalStateInput {
	s.RevisionId = &v
	return s
}

type UpdatePullRequestApprovalStateOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s UpdatePullRequestApprovalStateOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdatePullRequestApprovalStateOutput) GoString() string {
	return s.String()
}

type UpdatePullRequestDescriptionInput struct {
	_ struct{} `type:"structure"`

	// The updated content of the description for the pull request. This content
	// replaces the existing description.
	//
	// Description is a required field
	Description *string `locationName:"description" type:"string" required:"true"`

	// The system-generated ID of the pull request. To get this ID, use ListPullRequests.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdatePullRequestDescriptionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdatePullRequestDescriptionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdatePullRequestDescriptionInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdatePullRequestDescriptionInput"}
	if s.Description == nil {
		invalidParams.Add(request.NewErrParamRequired("Description"))
	}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetDescription sets the Description field's value.
func (s *UpdatePullRequestDescriptionInput) SetDescription(v string) *UpdatePullRequestDescriptionInput {
	s.Description = &v
	return s
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *UpdatePullRequestDescriptionInput) SetPullRequestId(v string) *UpdatePullRequestDescriptionInput {
	s.PullRequestId = &v
	return s
}

type UpdatePullRequestDescriptionOutput struct {
	_ struct{} `type:"structure"`

	// Information about the updated pull request.
	//
	// PullRequest is a required field
	PullRequest *PullRequest `locationName:"pullRequest" type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdatePullRequestDescriptionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdatePullRequestDescriptionOutput) GoString() string {
	return s.String()
}

// SetPullRequest sets the PullRequest field's value.
func (s *UpdatePullRequestDescriptionOutput) SetPullRequest(v *PullRequest) *UpdatePullRequestDescriptionOutput {
	s.PullRequest = v
	return s
}

type UpdatePullRequestStatusInput struct {
	_ struct{} `type:"structure"`

	// The system-generated ID of the pull request. To get this ID, use ListPullRequests.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The status of the pull request. The only valid operations are to update the
	// status from OPEN to OPEN, OPEN to CLOSED or from CLOSED to CLOSED.
	//
	// PullRequestStatus is a required field
	PullRequestStatus *string `locationName:"pullRequestStatus" type:"string" required:"true" enum:"PullRequestStatusEnum"`
}

// String returns the string representation
func (s UpdatePullRequestStatusInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdatePullRequestStatusInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdatePullRequestStatusInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdatePullRequestStatusInput"}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.PullRequestStatus == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestStatus"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *UpdatePullRequestStatusInput) SetPullRequestId(v string) *UpdatePullRequestStatusInput {
	s.PullRequestId = &v
	return s
}

// SetPullRequestStatus sets the PullRequestStatus field's value.
func (s *UpdatePullRequestStatusInput) SetPullRequestStatus(v string) *UpdatePullRequestStatusInput {
	s.PullRequestStatus = &v
	return s
}

type UpdatePullRequestStatusOutput struct {
	_ struct{} `type:"structure"`

	// Information about the pull request.
	//
	// PullRequest is a required field
	PullRequest *PullRequest `locationName:"pullRequest" type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdatePullRequestStatusOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdatePullRequestStatusOutput) GoString() string {
	return s.String()
}

// SetPullRequest sets the PullRequest field's value.
func (s *UpdatePullRequestStatusOutput) SetPullRequest(v *PullRequest) *UpdatePullRequestStatusOutput {
	s.PullRequest = v
	return s
}

type UpdatePullRequestTitleInput struct {
	_ struct{} `type:"structure"`

	// The system-generated ID of the pull request. To get this ID, use ListPullRequests.
	//
	// PullRequestId is a required field
	PullRequestId *string `locationName:"pullRequestId" type:"string" required:"true"`

	// The updated title of the pull request. This replaces the existing title.
	//
	// Title is a required field
	Title *string `locationName:"title" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdatePullRequestTitleInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdatePullRequestTitleInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdatePullRequestTitleInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdatePullRequestTitleInput"}
	if s.PullRequestId == nil {
		invalidParams.Add(request.NewErrParamRequired("PullRequestId"))
	}
	if s.Title == nil {
		invalidParams.Add(request.NewErrParamRequired("Title"))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetPullRequestId sets the PullRequestId field's value.
func (s *UpdatePullRequestTitleInput) SetPullRequestId(v string) *UpdatePullRequestTitleInput {
	s.PullRequestId = &v
	return s
}

// SetTitle sets the Title field's value.
func (s *UpdatePullRequestTitleInput) SetTitle(v string) *UpdatePullRequestTitleInput {
	s.Title = &v
	return s
}

type UpdatePullRequestTitleOutput struct {
	_ struct{} `type:"structure"`

	// Information about the updated pull request.
	//
	// PullRequest is a required field
	PullRequest *PullRequest `locationName:"pullRequest" type:"structure" required:"true"`
}

// String returns the string representation
func (s UpdatePullRequestTitleOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdatePullRequestTitleOutput) GoString() string {
	return s.String()
}

// SetPullRequest sets the PullRequest field's value.
func (s *UpdatePullRequestTitleOutput) SetPullRequest(v *PullRequest) *UpdatePullRequestTitleOutput {
	s.PullRequest = v
	return s
}

// Represents the input of an update repository description operation.
type UpdateRepositoryDescriptionInput struct {
	_ struct{} `type:"structure"`

	// The new comment or description for the specified repository. Repository descriptions
	// are limited to 1,000 characters.
	RepositoryDescription *string `locationName:"repositoryDescription" type:"string"`

	// The name of the repository to set or change the comment or description for.
	//
	// RepositoryName is a required field
	RepositoryName *string `locationName:"repositoryName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateRepositoryDescriptionInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRepositoryDescriptionInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateRepositoryDescriptionInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdateRepositoryDescriptionInput"}
	if s.RepositoryName == nil {
		invalidParams.Add(request.NewErrParamRequired("RepositoryName"))
	}
	if s.RepositoryName != nil && len(*s.RepositoryName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("RepositoryName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetRepositoryDescription sets the RepositoryDescription field's value.
func (s *UpdateRepositoryDescriptionInput) SetRepositoryDescription(v string) *UpdateRepositoryDescriptionInput {
	s.RepositoryDescription = &v
	return s
}

// SetRepositoryName sets the RepositoryName field's value.
func (s *UpdateRepositoryDescriptionInput) SetRepositoryName(v string) *UpdateRepositoryDescriptionInput {
	s.RepositoryName = &v
	return s
}

type UpdateRepositoryDescriptionOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s UpdateRepositoryDescriptionOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRepositoryDescriptionOutput) GoString() string {
	return s.String()
}

// Represents the input of an update repository description operation.
type UpdateRepositoryNameInput struct {
	_ struct{} `type:"structure"`

	// The new name for the repository.
	//
	// NewName is a required field
	NewName *string `locationName:"newName" min:"1" type:"string" required:"true"`

	// The current name of the repository.
	//
	// OldName is a required field
	OldName *string `locationName:"oldName" min:"1" type:"string" required:"true"`
}

// String returns the string representation
func (s UpdateRepositoryNameInput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRepositoryNameInput) GoString() string {
	return s.String()
}

// Validate inspects the fields of the type to determine if they are valid.
func (s *UpdateRepositoryNameInput) Validate() error {
	invalidParams := request.ErrInvalidParams{Context: "UpdateRepositoryNameInput"}
	if s.NewName == nil {
		invalidParams.Add(request.NewErrParamRequired("NewName"))
	}
	if s.NewName != nil && len(*s.NewName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("NewName", 1))
	}
	if s.OldName == nil {
		invalidParams.Add(request.NewErrParamRequired("OldName"))
	}
	if s.OldName != nil && len(*s.OldName) < 1 {
		invalidParams.Add(request.NewErrParamMinLen("OldName", 1))
	}

	if invalidParams.Len() > 0 {
		return invalidParams
	}
	return nil
}

// SetNewName sets the NewName field's value.
func (s *UpdateRepositoryNameInput) SetNewName(v string) *UpdateRepositoryNameInput {
	s.NewName = &v
	return s
}

// SetOldName sets the OldName field's value.
func (s *UpdateRepositoryNameInput) SetOldName(v string) *UpdateRepositoryNameInput {
	s.OldName = &v
	return s
}

type UpdateRepositoryNameOutput struct {
	_ struct{} `type:"structure"`
}

// String returns the string representation
func (s UpdateRepositoryNameOutput) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UpdateRepositoryNameOutput) GoString() string {
	return s.String()
}

// Information about the user who made a specified commit.
type UserInfo struct {
	_ struct{} `type:"structure"`

	// The date when the specified commit was commited, in timestamp format with
	// GMT offset.
	Date *string `locationName:"date" type:"string"`

	// The email address associated with the user who made the commit, if any.
	Email *string `locationName:"email" type:"string"`

	// The name of the user who made the specified commit.
	Name *string `locationName:"name" type:"string"`
}

// String returns the string representation
func (s UserInfo) String() string {
	return awsutil.Prettify(s)
}

// GoString returns the string representation
func (s UserInfo) GoString() string {
	return s.String()
}

// SetDate sets the Date field's value.
func (s *UserInfo) SetDate(v string) *UserInfo {
	s.Date = &v
	return s
}

// SetEmail sets the Email field's value.
func (s *UserInfo) SetEmail(v string) *UserInfo {
	s.Email = &v
	return s
}

// SetName sets the Name field's value.
func (s *UserInfo) SetName(v string) *UserInfo {
	s.Name = &v
	return s
}

const (
	// ApprovalStateApprove is a ApprovalState enum value
	ApprovalStateApprove = "APPROVE"

	// ApprovalStateRevoke is a ApprovalState enum value
	ApprovalStateRevoke = "REVOKE"
)

const (
	// ChangeTypeEnumA is a ChangeTypeEnum enum value
	ChangeTypeEnumA = "A"

	// ChangeTypeEnumM is a ChangeTypeEnum enum value
	ChangeTypeEnumM = "M"

	// ChangeTypeEnumD is a ChangeTypeEnum enum value
	ChangeTypeEnumD = "D"
)

const (
	// ConflictDetailLevelTypeEnumFileLevel is a ConflictDetailLevelTypeEnum enum value
	ConflictDetailLevelTypeEnumFileLevel = "FILE_LEVEL"

	// ConflictDetailLevelTypeEnumLineLevel is a ConflictDetailLevelTypeEnum enum value
	ConflictDetailLevelTypeEnumLineLevel = "LINE_LEVEL"
)

const (
	// ConflictResolutionStrategyTypeEnumNone is a ConflictResolutionStrategyTypeEnum enum value
	ConflictResolutionStrategyTypeEnumNone = "NONE"

	// ConflictResolutionStrategyTypeEnumAcceptSource is a ConflictResolutionStrategyTypeEnum enum value
	ConflictResolutionStrategyTypeEnumAcceptSource = "ACCEPT_SOURCE"

	// ConflictResolutionStrategyTypeEnumAcceptDestination is a ConflictResolutionStrategyTypeEnum enum value
	ConflictResolutionStrategyTypeEnumAcceptDestination = "ACCEPT_DESTINATION"

	// ConflictResolutionStrategyTypeEnumAutomerge is a ConflictResolutionStrategyTypeEnum enum value
	ConflictResolutionStrategyTypeEnumAutomerge = "AUTOMERGE"
)

const (
	// FileModeTypeEnumExecutable is a FileModeTypeEnum enum value
	FileModeTypeEnumExecutable = "EXECUTABLE"

	// FileModeTypeEnumNormal is a FileModeTypeEnum enum value
	FileModeTypeEnumNormal = "NORMAL"

	// FileModeTypeEnumSymlink is a FileModeTypeEnum enum value
	FileModeTypeEnumSymlink = "SYMLINK"
)

const (
	// MergeOptionTypeEnumFastForwardMerge is a MergeOptionTypeEnum enum value
	MergeOptionTypeEnumFastForwardMerge = "FAST_FORWARD_MERGE"

	// MergeOptionTypeEnumSquashMerge is a MergeOptionTypeEnum enum value
	MergeOptionTypeEnumSquashMerge = "SQUASH_MERGE"

	// MergeOptionTypeEnumThreeWayMerge is a MergeOptionTypeEnum enum value
	MergeOptionTypeEnumThreeWayMerge = "THREE_WAY_MERGE"
)

const (
	// ObjectTypeEnumFile is a ObjectTypeEnum enum value
	ObjectTypeEnumFile = "FILE"

	// ObjectTypeEnumDirectory is a ObjectTypeEnum enum value
	ObjectTypeEnumDirectory = "DIRECTORY"

	// ObjectTypeEnumGitLink is a ObjectTypeEnum enum value
	ObjectTypeEnumGitLink = "GIT_LINK"

	// ObjectTypeEnumSymbolicLink is a ObjectTypeEnum enum value
	ObjectTypeEnumSymbolicLink = "SYMBOLIC_LINK"
)

const (
	// OrderEnumAscending is a OrderEnum enum value
	OrderEnumAscending = "ascending"

	// OrderEnumDescending is a OrderEnum enum value
	OrderEnumDescending = "descending"
)

const (
	// OverrideStatusOverride is a OverrideStatus enum value
	OverrideStatusOverride = "OVERRIDE"

	// OverrideStatusRevoke is a OverrideStatus enum value
	OverrideStatusRevoke = "REVOKE"
)

const (
	// PullRequestEventTypePullRequestCreated is a PullRequestEventType enum value
	PullRequestEventTypePullRequestCreated = "PULL_REQUEST_CREATED"

	// PullRequestEventTypePullRequestStatusChanged is a PullRequestEventType enum value
	PullRequestEventTypePullRequestStatusChanged = "PULL_REQUEST_STATUS_CHANGED"

	// PullRequestEventTypePullRequestSourceReferenceUpdated is a PullRequestEventType enum value
	PullRequestEventTypePullRequestSourceReferenceUpdated = "PULL_REQUEST_SOURCE_REFERENCE_UPDATED"

	// PullRequestEventTypePullRequestMergeStateChanged is a PullRequestEventType enum value
	PullRequestEventTypePullRequestMergeStateChanged = "PULL_REQUEST_MERGE_STATE_CHANGED"

	// PullRequestEventTypePullRequestApprovalRuleCreated is a PullRequestEventType enum value
	PullRequestEventTypePullRequestApprovalRuleCreated = "PULL_REQUEST_APPROVAL_RULE_CREATED"

	// PullRequestEventTypePullRequestApprovalRuleUpdated is a PullRequestEventType enum value
	PullRequestEventTypePullRequestApprovalRuleUpdated = "PULL_REQUEST_APPROVAL_RULE_UPDATED"

	// PullRequestEventTypePullRequestApprovalRuleDeleted is a PullRequestEventType enum value
	PullRequestEventTypePullRequestApprovalRuleDeleted = "PULL_REQUEST_APPROVAL_RULE_DELETED"

	// PullRequestEventTypePullRequestApprovalRuleOverridden is a PullRequestEventType enum value
	PullRequestEventTypePullRequestApprovalRuleOverridden = "PULL_REQUEST_APPROVAL_RULE_OVERRIDDEN"

	// PullRequestEventTypePullRequestApprovalStateChanged is a PullRequestEventType enum value
	PullRequestEventTypePullRequestApprovalStateChanged = "PULL_REQUEST_APPROVAL_STATE_CHANGED"
)

const (
	// PullRequestStatusEnumOpen is a PullRequestStatusEnum enum value
	PullRequestStatusEnumOpen = "OPEN"

	// PullRequestStatusEnumClosed is a PullRequestStatusEnum enum value
	PullRequestStatusEnumClosed = "CLOSED"
)

const (
	// RelativeFileVersionEnumBefore is a RelativeFileVersionEnum enum value
	RelativeFileVersionEnumBefore = "BEFORE"

	// RelativeFileVersionEnumAfter is a RelativeFileVersionEnum enum value
	RelativeFileVersionEnumAfter = "AFTER"
)

const (
	// ReplacementTypeEnumKeepBase is a ReplacementTypeEnum enum value
	ReplacementTypeEnumKeepBase = "KEEP_BASE"

	// ReplacementTypeEnumKeepSource is a ReplacementTypeEnum enum value
	ReplacementTypeEnumKeepSource = "KEEP_SOURCE"

	// ReplacementTypeEnumKeepDestination is a ReplacementTypeEnum enum value
	ReplacementTypeEnumKeepDestination = "KEEP_DESTINATION"

	// ReplacementTypeEnumUseNewContent is a ReplacementTypeEnum enum value
	ReplacementTypeEnumUseNewContent = "USE_NEW_CONTENT"
)

const (
	// RepositoryTriggerEventEnumAll is a RepositoryTriggerEventEnum enum value
	RepositoryTriggerEventEnumAll = "all"

	// RepositoryTriggerEventEnumUpdateReference is a RepositoryTriggerEventEnum enum value
	RepositoryTriggerEventEnumUpdateReference = "updateReference"

	// RepositoryTriggerEventEnumCreateReference is a RepositoryTriggerEventEnum enum value
	RepositoryTriggerEventEnumCreateReference = "createReference"

	// RepositoryTriggerEventEnumDeleteReference is a RepositoryTriggerEventEnum enum value
	RepositoryTriggerEventEnumDeleteReference = "deleteReference"
)

const (
	// SortByEnumRepositoryName is a SortByEnum enum value
	SortByEnumRepositoryName = "repositoryName"

	// SortByEnumLastModifiedDate is a SortByEnum enum value
	SortByEnumLastModifiedDate = "lastModifiedDate"
)
