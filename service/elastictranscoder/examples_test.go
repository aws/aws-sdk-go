// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

package elastictranscoder_test

import (
	"bytes"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go/aws/awsconv"
	"github.com/aws/aws-sdk-go/aws/awserr"
	"github.com/aws/aws-sdk-go/aws/awsutil"
	"github.com/aws/aws-sdk-go/service/elastictranscoder"
)

var _ time.Duration
var _ bytes.Buffer

func ExampleElasticTranscoder_CancelJob() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.CancelJobInput{
		ID: awsconv.String("Id"), // Required
	}
	resp, err := svc.CancelJob(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_CreateJob() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.CreateJobInput{
		Input: &elastictranscoder.JobInput{ // Required
			AspectRatio: awsconv.String("AspectRatio"),
			Container:   awsconv.String("JobContainer"),
			DetectedProperties: &elastictranscoder.DetectedProperties{
				DurationMillis: awsconv.Int64(1),
				FileSize:       awsconv.Int64(1),
				FrameRate:      awsconv.String("FloatString"),
				Height:         awsconv.Int64(1),
				Width:          awsconv.Int64(1),
			},
			Encryption: &elastictranscoder.Encryption{
				InitializationVector: awsconv.String("ZeroTo255String"),
				Key:                  awsconv.String("Base64EncodedString"),
				KeyMD5:               awsconv.String("Base64EncodedString"),
				Mode:                 awsconv.String("EncryptionMode"),
			},
			FrameRate:  awsconv.String("FrameRate"),
			Interlaced: awsconv.String("Interlaced"),
			Key:        awsconv.String("Key"),
			Resolution: awsconv.String("Resolution"),
		},
		PipelineID: awsconv.String("Id"), // Required
		Output: &elastictranscoder.CreateJobOutput{
			AlbumArt: &elastictranscoder.JobAlbumArt{
				Artwork: []*elastictranscoder.Artwork{
					{ // Required
						AlbumArtFormat: awsconv.String("JpgOrPng"),
						Encryption: &elastictranscoder.Encryption{
							InitializationVector: awsconv.String("ZeroTo255String"),
							Key:                  awsconv.String("Base64EncodedString"),
							KeyMD5:               awsconv.String("Base64EncodedString"),
							Mode:                 awsconv.String("EncryptionMode"),
						},
						InputKey:      awsconv.String("WatermarkKey"),
						MaxHeight:     awsconv.String("DigitsOrAuto"),
						MaxWidth:      awsconv.String("DigitsOrAuto"),
						PaddingPolicy: awsconv.String("PaddingPolicy"),
						SizingPolicy:  awsconv.String("SizingPolicy"),
					},
					// More values...
				},
				MergePolicy: awsconv.String("MergePolicy"),
			},
			Captions: &elastictranscoder.Captions{
				CaptionFormats: []*elastictranscoder.CaptionFormat{
					{ // Required
						Encryption: &elastictranscoder.Encryption{
							InitializationVector: awsconv.String("ZeroTo255String"),
							Key:                  awsconv.String("Base64EncodedString"),
							KeyMD5:               awsconv.String("Base64EncodedString"),
							Mode:                 awsconv.String("EncryptionMode"),
						},
						Format:  awsconv.String("CaptionFormatFormat"),
						Pattern: awsconv.String("CaptionFormatPattern"),
					},
					// More values...
				},
				CaptionSources: []*elastictranscoder.CaptionSource{
					{ // Required
						Encryption: &elastictranscoder.Encryption{
							InitializationVector: awsconv.String("ZeroTo255String"),
							Key:                  awsconv.String("Base64EncodedString"),
							KeyMD5:               awsconv.String("Base64EncodedString"),
							Mode:                 awsconv.String("EncryptionMode"),
						},
						Key:        awsconv.String("Key"),
						Label:      awsconv.String("Name"),
						Language:   awsconv.String("Key"),
						TimeOffset: awsconv.String("TimeOffset"),
					},
					// More values...
				},
				MergePolicy: awsconv.String("CaptionMergePolicy"),
			},
			Composition: []*elastictranscoder.Clip{
				{ // Required
					TimeSpan: &elastictranscoder.TimeSpan{
						Duration:  awsconv.String("Time"),
						StartTime: awsconv.String("Time"),
					},
				},
				// More values...
			},
			Encryption: &elastictranscoder.Encryption{
				InitializationVector: awsconv.String("ZeroTo255String"),
				Key:                  awsconv.String("Base64EncodedString"),
				KeyMD5:               awsconv.String("Base64EncodedString"),
				Mode:                 awsconv.String("EncryptionMode"),
			},
			Key:             awsconv.String("Key"),
			PresetID:        awsconv.String("Id"),
			Rotate:          awsconv.String("Rotate"),
			SegmentDuration: awsconv.String("FloatString"),
			ThumbnailEncryption: &elastictranscoder.Encryption{
				InitializationVector: awsconv.String("ZeroTo255String"),
				Key:                  awsconv.String("Base64EncodedString"),
				KeyMD5:               awsconv.String("Base64EncodedString"),
				Mode:                 awsconv.String("EncryptionMode"),
			},
			ThumbnailPattern: awsconv.String("ThumbnailPattern"),
			Watermarks: []*elastictranscoder.JobWatermark{
				{ // Required
					Encryption: &elastictranscoder.Encryption{
						InitializationVector: awsconv.String("ZeroTo255String"),
						Key:                  awsconv.String("Base64EncodedString"),
						KeyMD5:               awsconv.String("Base64EncodedString"),
						Mode:                 awsconv.String("EncryptionMode"),
					},
					InputKey:          awsconv.String("WatermarkKey"),
					PresetWatermarkID: awsconv.String("PresetWatermarkId"),
				},
				// More values...
			},
		},
		OutputKeyPrefix: awsconv.String("Key"),
		Outputs: []*elastictranscoder.CreateJobOutput{
			{ // Required
				AlbumArt: &elastictranscoder.JobAlbumArt{
					Artwork: []*elastictranscoder.Artwork{
						{ // Required
							AlbumArtFormat: awsconv.String("JpgOrPng"),
							Encryption: &elastictranscoder.Encryption{
								InitializationVector: awsconv.String("ZeroTo255String"),
								Key:                  awsconv.String("Base64EncodedString"),
								KeyMD5:               awsconv.String("Base64EncodedString"),
								Mode:                 awsconv.String("EncryptionMode"),
							},
							InputKey:      awsconv.String("WatermarkKey"),
							MaxHeight:     awsconv.String("DigitsOrAuto"),
							MaxWidth:      awsconv.String("DigitsOrAuto"),
							PaddingPolicy: awsconv.String("PaddingPolicy"),
							SizingPolicy:  awsconv.String("SizingPolicy"),
						},
						// More values...
					},
					MergePolicy: awsconv.String("MergePolicy"),
				},
				Captions: &elastictranscoder.Captions{
					CaptionFormats: []*elastictranscoder.CaptionFormat{
						{ // Required
							Encryption: &elastictranscoder.Encryption{
								InitializationVector: awsconv.String("ZeroTo255String"),
								Key:                  awsconv.String("Base64EncodedString"),
								KeyMD5:               awsconv.String("Base64EncodedString"),
								Mode:                 awsconv.String("EncryptionMode"),
							},
							Format:  awsconv.String("CaptionFormatFormat"),
							Pattern: awsconv.String("CaptionFormatPattern"),
						},
						// More values...
					},
					CaptionSources: []*elastictranscoder.CaptionSource{
						{ // Required
							Encryption: &elastictranscoder.Encryption{
								InitializationVector: awsconv.String("ZeroTo255String"),
								Key:                  awsconv.String("Base64EncodedString"),
								KeyMD5:               awsconv.String("Base64EncodedString"),
								Mode:                 awsconv.String("EncryptionMode"),
							},
							Key:        awsconv.String("Key"),
							Label:      awsconv.String("Name"),
							Language:   awsconv.String("Key"),
							TimeOffset: awsconv.String("TimeOffset"),
						},
						// More values...
					},
					MergePolicy: awsconv.String("CaptionMergePolicy"),
				},
				Composition: []*elastictranscoder.Clip{
					{ // Required
						TimeSpan: &elastictranscoder.TimeSpan{
							Duration:  awsconv.String("Time"),
							StartTime: awsconv.String("Time"),
						},
					},
					// More values...
				},
				Encryption: &elastictranscoder.Encryption{
					InitializationVector: awsconv.String("ZeroTo255String"),
					Key:                  awsconv.String("Base64EncodedString"),
					KeyMD5:               awsconv.String("Base64EncodedString"),
					Mode:                 awsconv.String("EncryptionMode"),
				},
				Key:             awsconv.String("Key"),
				PresetID:        awsconv.String("Id"),
				Rotate:          awsconv.String("Rotate"),
				SegmentDuration: awsconv.String("FloatString"),
				ThumbnailEncryption: &elastictranscoder.Encryption{
					InitializationVector: awsconv.String("ZeroTo255String"),
					Key:                  awsconv.String("Base64EncodedString"),
					KeyMD5:               awsconv.String("Base64EncodedString"),
					Mode:                 awsconv.String("EncryptionMode"),
				},
				ThumbnailPattern: awsconv.String("ThumbnailPattern"),
				Watermarks: []*elastictranscoder.JobWatermark{
					{ // Required
						Encryption: &elastictranscoder.Encryption{
							InitializationVector: awsconv.String("ZeroTo255String"),
							Key:                  awsconv.String("Base64EncodedString"),
							KeyMD5:               awsconv.String("Base64EncodedString"),
							Mode:                 awsconv.String("EncryptionMode"),
						},
						InputKey:          awsconv.String("WatermarkKey"),
						PresetWatermarkID: awsconv.String("PresetWatermarkId"),
					},
					// More values...
				},
			},
			// More values...
		},
		Playlists: []*elastictranscoder.CreateJobPlaylist{
			{ // Required
				Format: awsconv.String("PlaylistFormat"),
				HLSContentProtection: &elastictranscoder.HLSContentProtection{
					InitializationVector:  awsconv.String("ZeroTo255String"),
					Key:                   awsconv.String("Base64EncodedString"),
					KeyMD5:                awsconv.String("Base64EncodedString"),
					KeyStoragePolicy:      awsconv.String("KeyStoragePolicy"),
					LicenseAcquisitionURL: awsconv.String("ZeroTo512String"),
					Method:                awsconv.String("HlsContentProtectionMethod"),
				},
				Name: awsconv.String("Filename"),
				OutputKeys: []*string{
					awsconv.String("Key"), // Required
					// More values...
				},
				PlayReadyDRM: &elastictranscoder.PlayReadyDRM{
					Format:                awsconv.String("PlayReadyDrmFormatString"),
					InitializationVector:  awsconv.String("ZeroTo255String"),
					Key:                   awsconv.String("NonEmptyBase64EncodedString"),
					KeyID:                 awsconv.String("KeyIdGuid"),
					KeyMD5:                awsconv.String("NonEmptyBase64EncodedString"),
					LicenseAcquisitionURL: awsconv.String("OneTo512String"),
				},
			},
			// More values...
		},
		UserMetadata: map[string]*string{
			"Key": awsconv.String("String"), // Required
			// More values...
		},
	}
	resp, err := svc.CreateJob(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_CreatePipeline() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.CreatePipelineInput{
		InputBucket:  awsconv.String("BucketName"), // Required
		Name:         awsconv.String("Name"),       // Required
		Role:         awsconv.String("Role"),       // Required
		AWSKMSKeyARN: awsconv.String("KeyArn"),
		ContentConfig: &elastictranscoder.PipelineOutputConfig{
			Bucket: awsconv.String("BucketName"),
			Permissions: []*elastictranscoder.Permission{
				{ // Required
					Access: []*string{
						awsconv.String("AccessControl"), // Required
						// More values...
					},
					Grantee:     awsconv.String("Grantee"),
					GranteeType: awsconv.String("GranteeType"),
				},
				// More values...
			},
			StorageClass: awsconv.String("StorageClass"),
		},
		Notifications: &elastictranscoder.Notifications{
			Completed:   awsconv.String("SnsTopic"),
			Error:       awsconv.String("SnsTopic"),
			Progressing: awsconv.String("SnsTopic"),
			Warning:     awsconv.String("SnsTopic"),
		},
		OutputBucket: awsconv.String("BucketName"),
		ThumbnailConfig: &elastictranscoder.PipelineOutputConfig{
			Bucket: awsconv.String("BucketName"),
			Permissions: []*elastictranscoder.Permission{
				{ // Required
					Access: []*string{
						awsconv.String("AccessControl"), // Required
						// More values...
					},
					Grantee:     awsconv.String("Grantee"),
					GranteeType: awsconv.String("GranteeType"),
				},
				// More values...
			},
			StorageClass: awsconv.String("StorageClass"),
		},
	}
	resp, err := svc.CreatePipeline(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_CreatePreset() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.CreatePresetInput{
		Container: awsconv.String("PresetContainer"), // Required
		Name:      awsconv.String("Name"),            // Required
		Audio: &elastictranscoder.AudioParameters{
			AudioPackingMode: awsconv.String("AudioPackingMode"),
			BitRate:          awsconv.String("AudioBitRate"),
			Channels:         awsconv.String("AudioChannels"),
			Codec:            awsconv.String("AudioCodec"),
			CodecOptions: &elastictranscoder.AudioCodecOptions{
				BitDepth: awsconv.String("AudioBitDepth"),
				BitOrder: awsconv.String("AudioBitOrder"),
				Profile:  awsconv.String("AudioCodecProfile"),
				Signed:   awsconv.String("AudioSigned"),
			},
			SampleRate: awsconv.String("AudioSampleRate"),
		},
		Description: awsconv.String("Description"),
		Thumbnails: &elastictranscoder.Thumbnails{
			AspectRatio:   awsconv.String("AspectRatio"),
			Format:        awsconv.String("JpgOrPng"),
			Interval:      awsconv.String("Digits"),
			MaxHeight:     awsconv.String("DigitsOrAuto"),
			MaxWidth:      awsconv.String("DigitsOrAuto"),
			PaddingPolicy: awsconv.String("PaddingPolicy"),
			Resolution:    awsconv.String("ThumbnailResolution"),
			SizingPolicy:  awsconv.String("SizingPolicy"),
		},
		Video: &elastictranscoder.VideoParameters{
			AspectRatio: awsconv.String("AspectRatio"),
			BitRate:     awsconv.String("VideoBitRate"),
			Codec:       awsconv.String("VideoCodec"),
			CodecOptions: map[string]*string{
				"Key": awsconv.String("CodecOption"), // Required
				// More values...
			},
			DisplayAspectRatio: awsconv.String("AspectRatio"),
			FixedGOP:           awsconv.String("FixedGOP"),
			FrameRate:          awsconv.String("FrameRate"),
			KeyframesMaxDist:   awsconv.String("KeyframesMaxDist"),
			MaxFrameRate:       awsconv.String("MaxFrameRate"),
			MaxHeight:          awsconv.String("DigitsOrAuto"),
			MaxWidth:           awsconv.String("DigitsOrAuto"),
			PaddingPolicy:      awsconv.String("PaddingPolicy"),
			Resolution:         awsconv.String("Resolution"),
			SizingPolicy:       awsconv.String("SizingPolicy"),
			Watermarks: []*elastictranscoder.PresetWatermark{
				{ // Required
					HorizontalAlign:  awsconv.String("HorizontalAlign"),
					HorizontalOffset: awsconv.String("PixelsOrPercent"),
					ID:               awsconv.String("PresetWatermarkId"),
					MaxHeight:        awsconv.String("PixelsOrPercent"),
					MaxWidth:         awsconv.String("PixelsOrPercent"),
					Opacity:          awsconv.String("Opacity"),
					SizingPolicy:     awsconv.String("WatermarkSizingPolicy"),
					Target:           awsconv.String("Target"),
					VerticalAlign:    awsconv.String("VerticalAlign"),
					VerticalOffset:   awsconv.String("PixelsOrPercent"),
				},
				// More values...
			},
		},
	}
	resp, err := svc.CreatePreset(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_DeletePipeline() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.DeletePipelineInput{
		ID: awsconv.String("Id"), // Required
	}
	resp, err := svc.DeletePipeline(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_DeletePreset() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.DeletePresetInput{
		ID: awsconv.String("Id"), // Required
	}
	resp, err := svc.DeletePreset(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_ListJobsByPipeline() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.ListJobsByPipelineInput{
		PipelineID: awsconv.String("Id"), // Required
		Ascending:  awsconv.String("Ascending"),
		PageToken:  awsconv.String("Id"),
	}
	resp, err := svc.ListJobsByPipeline(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_ListJobsByStatus() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.ListJobsByStatusInput{
		Status:    awsconv.String("JobStatus"), // Required
		Ascending: awsconv.String("Ascending"),
		PageToken: awsconv.String("Id"),
	}
	resp, err := svc.ListJobsByStatus(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_ListPipelines() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.ListPipelinesInput{
		Ascending: awsconv.String("Ascending"),
		PageToken: awsconv.String("Id"),
	}
	resp, err := svc.ListPipelines(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_ListPresets() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.ListPresetsInput{
		Ascending: awsconv.String("Ascending"),
		PageToken: awsconv.String("Id"),
	}
	resp, err := svc.ListPresets(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_ReadJob() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.ReadJobInput{
		ID: awsconv.String("Id"), // Required
	}
	resp, err := svc.ReadJob(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_ReadPipeline() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.ReadPipelineInput{
		ID: awsconv.String("Id"), // Required
	}
	resp, err := svc.ReadPipeline(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_ReadPreset() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.ReadPresetInput{
		ID: awsconv.String("Id"), // Required
	}
	resp, err := svc.ReadPreset(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_TestRole() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.TestRoleInput{
		InputBucket:  awsconv.String("BucketName"), // Required
		OutputBucket: awsconv.String("BucketName"), // Required
		Role:         awsconv.String("Role"),       // Required
		Topics: []*string{ // Required
			awsconv.String("SnsTopic"), // Required
			// More values...
		},
	}
	resp, err := svc.TestRole(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_UpdatePipeline() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.UpdatePipelineInput{
		ID:           awsconv.String("Id"), // Required
		AWSKMSKeyARN: awsconv.String("KeyArn"),
		ContentConfig: &elastictranscoder.PipelineOutputConfig{
			Bucket: awsconv.String("BucketName"),
			Permissions: []*elastictranscoder.Permission{
				{ // Required
					Access: []*string{
						awsconv.String("AccessControl"), // Required
						// More values...
					},
					Grantee:     awsconv.String("Grantee"),
					GranteeType: awsconv.String("GranteeType"),
				},
				// More values...
			},
			StorageClass: awsconv.String("StorageClass"),
		},
		InputBucket: awsconv.String("BucketName"),
		Name:        awsconv.String("Name"),
		Notifications: &elastictranscoder.Notifications{
			Completed:   awsconv.String("SnsTopic"),
			Error:       awsconv.String("SnsTopic"),
			Progressing: awsconv.String("SnsTopic"),
			Warning:     awsconv.String("SnsTopic"),
		},
		Role: awsconv.String("Role"),
		ThumbnailConfig: &elastictranscoder.PipelineOutputConfig{
			Bucket: awsconv.String("BucketName"),
			Permissions: []*elastictranscoder.Permission{
				{ // Required
					Access: []*string{
						awsconv.String("AccessControl"), // Required
						// More values...
					},
					Grantee:     awsconv.String("Grantee"),
					GranteeType: awsconv.String("GranteeType"),
				},
				// More values...
			},
			StorageClass: awsconv.String("StorageClass"),
		},
	}
	resp, err := svc.UpdatePipeline(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_UpdatePipelineNotifications() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.UpdatePipelineNotificationsInput{
		ID: awsconv.String("Id"), // Required
		Notifications: &elastictranscoder.Notifications{ // Required
			Completed:   awsconv.String("SnsTopic"),
			Error:       awsconv.String("SnsTopic"),
			Progressing: awsconv.String("SnsTopic"),
			Warning:     awsconv.String("SnsTopic"),
		},
	}
	resp, err := svc.UpdatePipelineNotifications(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}

func ExampleElasticTranscoder_UpdatePipelineStatus() {
	svc := elastictranscoder.New(nil)

	params := &elastictranscoder.UpdatePipelineStatusInput{
		ID:     awsconv.String("Id"),             // Required
		Status: awsconv.String("PipelineStatus"), // Required
	}
	resp, err := svc.UpdatePipelineStatus(params)

	if err != nil {
		if awsErr, ok := err.(awserr.Error); ok {
			// Generic AWS error with Code, Message, and original error (if any)
			fmt.Println(awsErr.Code(), awsErr.Message(), awsErr.OrigErr())
			if reqErr, ok := err.(awserr.RequestFailure); ok {
				// A service error occurred
				fmt.Println(reqErr.Code(), reqErr.Message(), reqErr.StatusCode(), reqErr.RequestID())
			}
		} else {
			// This case should never be hit, the SDK should always return an
			// error which satisfies the awserr.Error interface.
			fmt.Println(err.Error())
		}
	}

	// Pretty-print the response data.
	fmt.Println(awsutil.Prettify(resp))
}
