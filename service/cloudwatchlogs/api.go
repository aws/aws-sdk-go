// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package cloudwatchlogs provides a client for Amazon CloudWatch Logs.
package cloudwatchlogs

import (
	"sync"

	"github.com/aws/aws-sdk-go/aws"
)

var oprw sync.Mutex

// CreateLogGroupRequest generates a request for the CreateLogGroup operation.
func (c *CloudWatchLogs) CreateLogGroupRequest(input *CreateLogGroupInput) (req *aws.Request, output *CreateLogGroupOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCreateLogGroup == nil {
		opCreateLogGroup = &aws.Operation{
			Name:       "CreateLogGroup",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &CreateLogGroupInput{}
	}

	req = c.newRequest(opCreateLogGroup, input, output)
	output = &CreateLogGroupOutput{}
	req.Data = output
	return
}

// Creates a new log group with the specified name. The name of the log group
// must be unique within a region for an AWS account. You can create up to 500
// log groups per account.
//
//  You must use the following guidelines when naming a log group:  Log group
// names can be between 1 and 512 characters long. Allowed characters are a-z,
// A-Z, 0-9, '_' (underscore), '-' (hyphen), '/' (forward slash), and '.' (period).
func (c *CloudWatchLogs) CreateLogGroup(input *CreateLogGroupInput) (*CreateLogGroupOutput, error) {
	req, out := c.CreateLogGroupRequest(input)
	err := req.Send()
	return out, err
}

var opCreateLogGroup *aws.Operation

// CreateLogStreamRequest generates a request for the CreateLogStream operation.
func (c *CloudWatchLogs) CreateLogStreamRequest(input *CreateLogStreamInput) (req *aws.Request, output *CreateLogStreamOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCreateLogStream == nil {
		opCreateLogStream = &aws.Operation{
			Name:       "CreateLogStream",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &CreateLogStreamInput{}
	}

	req = c.newRequest(opCreateLogStream, input, output)
	output = &CreateLogStreamOutput{}
	req.Data = output
	return
}

// Creates a new log stream in the specified log group. The name of the log
// stream must be unique within the log group. There is no limit on the number
// of log streams that can exist in a log group.
//
//  You must use the following guidelines when naming a log stream:  Log stream
// names can be between 1 and 512 characters long. The ':' colon character is
// not allowed.
func (c *CloudWatchLogs) CreateLogStream(input *CreateLogStreamInput) (*CreateLogStreamOutput, error) {
	req, out := c.CreateLogStreamRequest(input)
	err := req.Send()
	return out, err
}

var opCreateLogStream *aws.Operation

// DeleteLogGroupRequest generates a request for the DeleteLogGroup operation.
func (c *CloudWatchLogs) DeleteLogGroupRequest(input *DeleteLogGroupInput) (req *aws.Request, output *DeleteLogGroupOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteLogGroup == nil {
		opDeleteLogGroup = &aws.Operation{
			Name:       "DeleteLogGroup",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DeleteLogGroupInput{}
	}

	req = c.newRequest(opDeleteLogGroup, input, output)
	output = &DeleteLogGroupOutput{}
	req.Data = output
	return
}

// Deletes the log group with the specified name and permanently deletes all
// the archived log events associated with it.
func (c *CloudWatchLogs) DeleteLogGroup(input *DeleteLogGroupInput) (*DeleteLogGroupOutput, error) {
	req, out := c.DeleteLogGroupRequest(input)
	err := req.Send()
	return out, err
}

var opDeleteLogGroup *aws.Operation

// DeleteLogStreamRequest generates a request for the DeleteLogStream operation.
func (c *CloudWatchLogs) DeleteLogStreamRequest(input *DeleteLogStreamInput) (req *aws.Request, output *DeleteLogStreamOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteLogStream == nil {
		opDeleteLogStream = &aws.Operation{
			Name:       "DeleteLogStream",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DeleteLogStreamInput{}
	}

	req = c.newRequest(opDeleteLogStream, input, output)
	output = &DeleteLogStreamOutput{}
	req.Data = output
	return
}

// Deletes a log stream and permanently deletes all the archived log events
// associated with it.
func (c *CloudWatchLogs) DeleteLogStream(input *DeleteLogStreamInput) (*DeleteLogStreamOutput, error) {
	req, out := c.DeleteLogStreamRequest(input)
	err := req.Send()
	return out, err
}

var opDeleteLogStream *aws.Operation

// DeleteMetricFilterRequest generates a request for the DeleteMetricFilter operation.
func (c *CloudWatchLogs) DeleteMetricFilterRequest(input *DeleteMetricFilterInput) (req *aws.Request, output *DeleteMetricFilterOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteMetricFilter == nil {
		opDeleteMetricFilter = &aws.Operation{
			Name:       "DeleteMetricFilter",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DeleteMetricFilterInput{}
	}

	req = c.newRequest(opDeleteMetricFilter, input, output)
	output = &DeleteMetricFilterOutput{}
	req.Data = output
	return
}

// Deletes a metric filter associated with the specified log group.
func (c *CloudWatchLogs) DeleteMetricFilter(input *DeleteMetricFilterInput) (*DeleteMetricFilterOutput, error) {
	req, out := c.DeleteMetricFilterRequest(input)
	err := req.Send()
	return out, err
}

var opDeleteMetricFilter *aws.Operation

// DeleteRetentionPolicyRequest generates a request for the DeleteRetentionPolicy operation.
func (c *CloudWatchLogs) DeleteRetentionPolicyRequest(input *DeleteRetentionPolicyInput) (req *aws.Request, output *DeleteRetentionPolicyOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteRetentionPolicy == nil {
		opDeleteRetentionPolicy = &aws.Operation{
			Name:       "DeleteRetentionPolicy",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DeleteRetentionPolicyInput{}
	}

	req = c.newRequest(opDeleteRetentionPolicy, input, output)
	output = &DeleteRetentionPolicyOutput{}
	req.Data = output
	return
}

// Deletes the retention policy of the specified log group. Log events would
// not expire if they belong to log groups without a retention policy.
func (c *CloudWatchLogs) DeleteRetentionPolicy(input *DeleteRetentionPolicyInput) (*DeleteRetentionPolicyOutput, error) {
	req, out := c.DeleteRetentionPolicyRequest(input)
	err := req.Send()
	return out, err
}

var opDeleteRetentionPolicy *aws.Operation

// DeleteSubscriptionFilterRequest generates a request for the DeleteSubscriptionFilter operation.
func (c *CloudWatchLogs) DeleteSubscriptionFilterRequest(input *DeleteSubscriptionFilterInput) (req *aws.Request, output *DeleteSubscriptionFilterOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteSubscriptionFilter == nil {
		opDeleteSubscriptionFilter = &aws.Operation{
			Name:       "DeleteSubscriptionFilter",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DeleteSubscriptionFilterInput{}
	}

	req = c.newRequest(opDeleteSubscriptionFilter, input, output)
	output = &DeleteSubscriptionFilterOutput{}
	req.Data = output
	return
}

// Deletes a subscription filter associated with the specified log group.
func (c *CloudWatchLogs) DeleteSubscriptionFilter(input *DeleteSubscriptionFilterInput) (*DeleteSubscriptionFilterOutput, error) {
	req, out := c.DeleteSubscriptionFilterRequest(input)
	err := req.Send()
	return out, err
}

var opDeleteSubscriptionFilter *aws.Operation

// DescribeLogGroupsRequest generates a request for the DescribeLogGroups operation.
func (c *CloudWatchLogs) DescribeLogGroupsRequest(input *DescribeLogGroupsInput) (req *aws.Request, output *DescribeLogGroupsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDescribeLogGroups == nil {
		opDescribeLogGroups = &aws.Operation{
			Name:       "DescribeLogGroups",
			HTTPMethod: "POST",
			HTTPPath:   "/",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"nextToken"},
				OutputTokens:    []string{"nextToken"},
				LimitToken:      "limit",
				TruncationToken: "",
			},
		}
	}

	if input == nil {
		input = &DescribeLogGroupsInput{}
	}

	req = c.newRequest(opDescribeLogGroups, input, output)
	output = &DescribeLogGroupsOutput{}
	req.Data = output
	return
}

// Returns all the log groups that are associated with the AWS account making
// the request. The list returned in the response is ASCII-sorted by log group
// name.
//
//  By default, this operation returns up to 50 log groups. If there are more
// log groups to list, the response would contain a nextToken value in the response
// body. You can also limit the number of log groups returned in the response
// by specifying the limit parameter in the request.
func (c *CloudWatchLogs) DescribeLogGroups(input *DescribeLogGroupsInput) (*DescribeLogGroupsOutput, error) {
	req, out := c.DescribeLogGroupsRequest(input)
	err := req.Send()
	return out, err
}

func (c *CloudWatchLogs) DescribeLogGroupsPages(input *DescribeLogGroupsInput, fn func(p *DescribeLogGroupsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.DescribeLogGroupsRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*DescribeLogGroupsOutput), lastPage)
	})
}

var opDescribeLogGroups *aws.Operation

// DescribeLogStreamsRequest generates a request for the DescribeLogStreams operation.
func (c *CloudWatchLogs) DescribeLogStreamsRequest(input *DescribeLogStreamsInput) (req *aws.Request, output *DescribeLogStreamsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDescribeLogStreams == nil {
		opDescribeLogStreams = &aws.Operation{
			Name:       "DescribeLogStreams",
			HTTPMethod: "POST",
			HTTPPath:   "/",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"nextToken"},
				OutputTokens:    []string{"nextToken"},
				LimitToken:      "limit",
				TruncationToken: "",
			},
		}
	}

	if input == nil {
		input = &DescribeLogStreamsInput{}
	}

	req = c.newRequest(opDescribeLogStreams, input, output)
	output = &DescribeLogStreamsOutput{}
	req.Data = output
	return
}

// Returns all the log streams that are associated with the specified log group.
// The list returned in the response is ASCII-sorted by log stream name.
//
//  By default, this operation returns up to 50 log streams. If there are more
// log streams to list, the response would contain a nextToken value in the
// response body. You can also limit the number of log streams returned in the
// response by specifying the limit parameter in the request. This operation
// has a limit of five transactions per second, after which transactions are
// throttled.
func (c *CloudWatchLogs) DescribeLogStreams(input *DescribeLogStreamsInput) (*DescribeLogStreamsOutput, error) {
	req, out := c.DescribeLogStreamsRequest(input)
	err := req.Send()
	return out, err
}

func (c *CloudWatchLogs) DescribeLogStreamsPages(input *DescribeLogStreamsInput, fn func(p *DescribeLogStreamsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.DescribeLogStreamsRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*DescribeLogStreamsOutput), lastPage)
	})
}

var opDescribeLogStreams *aws.Operation

// DescribeMetricFiltersRequest generates a request for the DescribeMetricFilters operation.
func (c *CloudWatchLogs) DescribeMetricFiltersRequest(input *DescribeMetricFiltersInput) (req *aws.Request, output *DescribeMetricFiltersOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDescribeMetricFilters == nil {
		opDescribeMetricFilters = &aws.Operation{
			Name:       "DescribeMetricFilters",
			HTTPMethod: "POST",
			HTTPPath:   "/",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"nextToken"},
				OutputTokens:    []string{"nextToken"},
				LimitToken:      "limit",
				TruncationToken: "",
			},
		}
	}

	if input == nil {
		input = &DescribeMetricFiltersInput{}
	}

	req = c.newRequest(opDescribeMetricFilters, input, output)
	output = &DescribeMetricFiltersOutput{}
	req.Data = output
	return
}

// Returns all the metrics filters associated with the specified log group.
// The list returned in the response is ASCII-sorted by filter name.
//
//  By default, this operation returns up to 50 metric filters. If there are
// more metric filters to list, the response would contain a nextToken value
// in the response body. You can also limit the number of metric filters returned
// in the response by specifying the limit parameter in the request.
func (c *CloudWatchLogs) DescribeMetricFilters(input *DescribeMetricFiltersInput) (*DescribeMetricFiltersOutput, error) {
	req, out := c.DescribeMetricFiltersRequest(input)
	err := req.Send()
	return out, err
}

func (c *CloudWatchLogs) DescribeMetricFiltersPages(input *DescribeMetricFiltersInput, fn func(p *DescribeMetricFiltersOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.DescribeMetricFiltersRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*DescribeMetricFiltersOutput), lastPage)
	})
}

var opDescribeMetricFilters *aws.Operation

// DescribeSubscriptionFiltersRequest generates a request for the DescribeSubscriptionFilters operation.
func (c *CloudWatchLogs) DescribeSubscriptionFiltersRequest(input *DescribeSubscriptionFiltersInput) (req *aws.Request, output *DescribeSubscriptionFiltersOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDescribeSubscriptionFilters == nil {
		opDescribeSubscriptionFilters = &aws.Operation{
			Name:       "DescribeSubscriptionFilters",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DescribeSubscriptionFiltersInput{}
	}

	req = c.newRequest(opDescribeSubscriptionFilters, input, output)
	output = &DescribeSubscriptionFiltersOutput{}
	req.Data = output
	return
}

// Returns all the subscription filters associated with the specified log group.
// The list returned in the response is ASCII-sorted by filter name.
//
//  By default, this operation returns up to 50 subscription filters. If there
// are more subscription filters to list, the response would contain a nextToken
// value in the response body. You can also limit the number of subscription
// filters returned in the response by specifying the limit parameter in the
// request.
func (c *CloudWatchLogs) DescribeSubscriptionFilters(input *DescribeSubscriptionFiltersInput) (*DescribeSubscriptionFiltersOutput, error) {
	req, out := c.DescribeSubscriptionFiltersRequest(input)
	err := req.Send()
	return out, err
}

var opDescribeSubscriptionFilters *aws.Operation

// FilterLogEventsRequest generates a request for the FilterLogEvents operation.
func (c *CloudWatchLogs) FilterLogEventsRequest(input *FilterLogEventsInput) (req *aws.Request, output *FilterLogEventsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opFilterLogEvents == nil {
		opFilterLogEvents = &aws.Operation{
			Name:       "FilterLogEvents",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &FilterLogEventsInput{}
	}

	req = c.newRequest(opFilterLogEvents, input, output)
	output = &FilterLogEventsOutput{}
	req.Data = output
	return
}

// Retrieves log events, optionally filtered by a filter pattern from the specified
// log group. You can provide an optional time range to filter the results on
// the event timestamp. You can limit the streams searched to an explicit list
// of logStreamNames.
//
//  By default, this operation returns as much matching log events as can fit
// in a response size of 1MB, up to 10,000 log events, or all the events found
// within a time-bounded scan window. If the response includes a nextToken,
// then there is more data to search, and the search can be resumed with a new
// request providing the nextToken. The response will contain a list of searchedLogStreams
// that contains information about which streams were searched in the request
// and whether they have been searched completely or require further pagination.
// The limit parameter in the request. can be used to specify the maximum number
// of events to return in a page.
func (c *CloudWatchLogs) FilterLogEvents(input *FilterLogEventsInput) (*FilterLogEventsOutput, error) {
	req, out := c.FilterLogEventsRequest(input)
	err := req.Send()
	return out, err
}

var opFilterLogEvents *aws.Operation

// GetLogEventsRequest generates a request for the GetLogEvents operation.
func (c *CloudWatchLogs) GetLogEventsRequest(input *GetLogEventsInput) (req *aws.Request, output *GetLogEventsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opGetLogEvents == nil {
		opGetLogEvents = &aws.Operation{
			Name:       "GetLogEvents",
			HTTPMethod: "POST",
			HTTPPath:   "/",
			Paginator: &aws.Paginator{
				InputTokens:     []string{"nextToken"},
				OutputTokens:    []string{"nextForwardToken"},
				LimitToken:      "limit",
				TruncationToken: "",
			},
		}
	}

	if input == nil {
		input = &GetLogEventsInput{}
	}

	req = c.newRequest(opGetLogEvents, input, output)
	output = &GetLogEventsOutput{}
	req.Data = output
	return
}

// Retrieves log events from the specified log stream. You can provide an optional
// time range to filter the results on the event timestamp.
//
//  By default, this operation returns as much log events as can fit in a response
// size of 1MB, up to 10,000 log events. The response will always include a
// nextForwardToken and a nextBackwardToken in the response body. You can use
// any of these tokens in subsequent GetLogEvents requests to paginate through
// events in either forward or backward direction. You can also limit the number
// of log events returned in the response by specifying the limit parameter
// in the request.
func (c *CloudWatchLogs) GetLogEvents(input *GetLogEventsInput) (*GetLogEventsOutput, error) {
	req, out := c.GetLogEventsRequest(input)
	err := req.Send()
	return out, err
}

func (c *CloudWatchLogs) GetLogEventsPages(input *GetLogEventsInput, fn func(p *GetLogEventsOutput, lastPage bool) (shouldContinue bool)) error {
	page, _ := c.GetLogEventsRequest(input)
	return page.EachPage(func(p interface{}, lastPage bool) bool {
		return fn(p.(*GetLogEventsOutput), lastPage)
	})
}

var opGetLogEvents *aws.Operation

// PutLogEventsRequest generates a request for the PutLogEvents operation.
func (c *CloudWatchLogs) PutLogEventsRequest(input *PutLogEventsInput) (req *aws.Request, output *PutLogEventsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutLogEvents == nil {
		opPutLogEvents = &aws.Operation{
			Name:       "PutLogEvents",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &PutLogEventsInput{}
	}

	req = c.newRequest(opPutLogEvents, input, output)
	output = &PutLogEventsOutput{}
	req.Data = output
	return
}

// Uploads a batch of log events to the specified log stream.
//
//  Every PutLogEvents request must include the sequenceToken obtained from
// the response of the previous request. An upload in a newly created log stream
// does not require a sequenceToken.
//
//  The batch of events must satisfy the following constraints:  The maximum
// batch size is 1,048,576 bytes, and this size is calculated as the sum of
// all event messages in UTF-8, plus 26 bytes for each log event. None of the
// log events in the batch can be more than 2 hours in the future. None of the
// log events in the batch can be older than 14 days or the retention period
// of the log group. The log events in the batch must be in chronological ordered
// by their timestamp. The maximum number of log events in a batch is 10,000.
func (c *CloudWatchLogs) PutLogEvents(input *PutLogEventsInput) (*PutLogEventsOutput, error) {
	req, out := c.PutLogEventsRequest(input)
	err := req.Send()
	return out, err
}

var opPutLogEvents *aws.Operation

// PutMetricFilterRequest generates a request for the PutMetricFilter operation.
func (c *CloudWatchLogs) PutMetricFilterRequest(input *PutMetricFilterInput) (req *aws.Request, output *PutMetricFilterOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutMetricFilter == nil {
		opPutMetricFilter = &aws.Operation{
			Name:       "PutMetricFilter",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &PutMetricFilterInput{}
	}

	req = c.newRequest(opPutMetricFilter, input, output)
	output = &PutMetricFilterOutput{}
	req.Data = output
	return
}

// Creates or updates a metric filter and associates it with the specified log
// group. Metric filters allow you to configure rules to extract metric data
// from log events ingested through PutLogEvents requests.
//
//  The maximum number of metric filters that can be associated with a log
// group is 100.
func (c *CloudWatchLogs) PutMetricFilter(input *PutMetricFilterInput) (*PutMetricFilterOutput, error) {
	req, out := c.PutMetricFilterRequest(input)
	err := req.Send()
	return out, err
}

var opPutMetricFilter *aws.Operation

// PutRetentionPolicyRequest generates a request for the PutRetentionPolicy operation.
func (c *CloudWatchLogs) PutRetentionPolicyRequest(input *PutRetentionPolicyInput) (req *aws.Request, output *PutRetentionPolicyOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutRetentionPolicy == nil {
		opPutRetentionPolicy = &aws.Operation{
			Name:       "PutRetentionPolicy",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &PutRetentionPolicyInput{}
	}

	req = c.newRequest(opPutRetentionPolicy, input, output)
	output = &PutRetentionPolicyOutput{}
	req.Data = output
	return
}

// Sets the retention of the specified log group. A retention policy allows
// you to configure the number of days you want to retain log events in the
// specified log group.
func (c *CloudWatchLogs) PutRetentionPolicy(input *PutRetentionPolicyInput) (*PutRetentionPolicyOutput, error) {
	req, out := c.PutRetentionPolicyRequest(input)
	err := req.Send()
	return out, err
}

var opPutRetentionPolicy *aws.Operation

// PutSubscriptionFilterRequest generates a request for the PutSubscriptionFilter operation.
func (c *CloudWatchLogs) PutSubscriptionFilterRequest(input *PutSubscriptionFilterInput) (req *aws.Request, output *PutSubscriptionFilterOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opPutSubscriptionFilter == nil {
		opPutSubscriptionFilter = &aws.Operation{
			Name:       "PutSubscriptionFilter",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &PutSubscriptionFilterInput{}
	}

	req = c.newRequest(opPutSubscriptionFilter, input, output)
	output = &PutSubscriptionFilterOutput{}
	req.Data = output
	return
}

// Creates or updates a subscription filter and associates it with the specified
// log group. Subscription filters allow you to subscribe to a real-time stream
// of log events ingested through PutLogEvents requests and have them delivered
// to a specific destination. Currently the only supported destination is an
// Amazon Kinesis stream belonging to the same account as the subscription filter.
//
//  Currently there can only be one subscription filter associated with a log
// group.
func (c *CloudWatchLogs) PutSubscriptionFilter(input *PutSubscriptionFilterInput) (*PutSubscriptionFilterOutput, error) {
	req, out := c.PutSubscriptionFilterRequest(input)
	err := req.Send()
	return out, err
}

var opPutSubscriptionFilter *aws.Operation

// TestMetricFilterRequest generates a request for the TestMetricFilter operation.
func (c *CloudWatchLogs) TestMetricFilterRequest(input *TestMetricFilterInput) (req *aws.Request, output *TestMetricFilterOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opTestMetricFilter == nil {
		opTestMetricFilter = &aws.Operation{
			Name:       "TestMetricFilter",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &TestMetricFilterInput{}
	}

	req = c.newRequest(opTestMetricFilter, input, output)
	output = &TestMetricFilterOutput{}
	req.Data = output
	return
}

// Tests the filter pattern of a metric filter against a sample of log event
// messages. You can use this operation to validate the correctness of a metric
// filter pattern.
func (c *CloudWatchLogs) TestMetricFilter(input *TestMetricFilterInput) (*TestMetricFilterOutput, error) {
	req, out := c.TestMetricFilterRequest(input)
	err := req.Send()
	return out, err
}

var opTestMetricFilter *aws.Operation

type CreateLogGroupInput struct {
	// The name of the log group to create.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	metadataCreateLogGroupInput `json:"-" xml:"-"`
}

type metadataCreateLogGroupInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateLogGroupOutput struct {
	metadataCreateLogGroupOutput `json:"-" xml:"-"`
}

type metadataCreateLogGroupOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateLogStreamInput struct {
	// The name of the log group under which the log stream is to be created.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	// The name of the log stream to create.
	LogStreamName *string `locationName:"logStreamName" type:"string" required:"true"`

	metadataCreateLogStreamInput `json:"-" xml:"-"`
}

type metadataCreateLogStreamInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateLogStreamOutput struct {
	metadataCreateLogStreamOutput `json:"-" xml:"-"`
}

type metadataCreateLogStreamOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteLogGroupInput struct {
	// The name of the log group to delete.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	metadataDeleteLogGroupInput `json:"-" xml:"-"`
}

type metadataDeleteLogGroupInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteLogGroupOutput struct {
	metadataDeleteLogGroupOutput `json:"-" xml:"-"`
}

type metadataDeleteLogGroupOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteLogStreamInput struct {
	// The name of the log group under which the log stream to delete belongs.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	// The name of the log stream to delete.
	LogStreamName *string `locationName:"logStreamName" type:"string" required:"true"`

	metadataDeleteLogStreamInput `json:"-" xml:"-"`
}

type metadataDeleteLogStreamInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteLogStreamOutput struct {
	metadataDeleteLogStreamOutput `json:"-" xml:"-"`
}

type metadataDeleteLogStreamOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteMetricFilterInput struct {
	// The name of the metric filter to delete.
	FilterName *string `locationName:"filterName" type:"string" required:"true"`

	// The name of the log group that is associated with the metric filter to delete.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	metadataDeleteMetricFilterInput `json:"-" xml:"-"`
}

type metadataDeleteMetricFilterInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteMetricFilterOutput struct {
	metadataDeleteMetricFilterOutput `json:"-" xml:"-"`
}

type metadataDeleteMetricFilterOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteRetentionPolicyInput struct {
	// The name of the log group that is associated with the retention policy to
	// delete.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	metadataDeleteRetentionPolicyInput `json:"-" xml:"-"`
}

type metadataDeleteRetentionPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteRetentionPolicyOutput struct {
	metadataDeleteRetentionPolicyOutput `json:"-" xml:"-"`
}

type metadataDeleteRetentionPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteSubscriptionFilterInput struct {
	// The name of the subscription filter to delete.
	FilterName *string `locationName:"filterName" type:"string" required:"true"`

	// The name of the log group that is associated with the subscription filter
	// to delete.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	metadataDeleteSubscriptionFilterInput `json:"-" xml:"-"`
}

type metadataDeleteSubscriptionFilterInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DeleteSubscriptionFilterOutput struct {
	metadataDeleteSubscriptionFilterOutput `json:"-" xml:"-"`
}

type metadataDeleteSubscriptionFilterOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeLogGroupsInput struct {
	// The maximum number of items returned in the response. If you don't specify
	// a value, the request would return up to 50 items.
	Limit *int64 `locationName:"limit" type:"integer"`

	// Will only return log groups that match the provided logGroupNamePrefix. If
	// you don't specify a value, no prefix filter is applied.
	LogGroupNamePrefix *string `locationName:"logGroupNamePrefix" type:"string"`

	// A string token used for pagination that points to the next page of results.
	// It must be a value obtained from the response of the previous DescribeLogGroups
	// request.
	NextToken *string `locationName:"nextToken" type:"string"`

	metadataDescribeLogGroupsInput `json:"-" xml:"-"`
}

type metadataDescribeLogGroupsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeLogGroupsOutput struct {
	// A list of log groups.
	LogGroups []*LogGroup `locationName:"logGroups" type:"list"`

	// A string token used for pagination that points to the next page of results.
	// It must be a value obtained from the response of the previous request. The
	// token expires after 24 hours.
	NextToken *string `locationName:"nextToken" type:"string"`

	metadataDescribeLogGroupsOutput `json:"-" xml:"-"`
}

type metadataDescribeLogGroupsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeLogStreamsInput struct {
	// If set to true, results are returned in descending order. If you don't specify
	// a value or set it to false, results are returned in ascending order.
	Descending *bool `locationName:"descending" type:"boolean"`

	// The maximum number of items returned in the response. If you don't specify
	// a value, the request would return up to 50 items.
	Limit *int64 `locationName:"limit" type:"integer"`

	// The log group name for which log streams are to be listed.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	// Will only return log streams that match the provided logStreamNamePrefix.
	// If you don't specify a value, no prefix filter is applied.
	LogStreamNamePrefix *string `locationName:"logStreamNamePrefix" type:"string"`

	// A string token used for pagination that points to the next page of results.
	// It must be a value obtained from the response of the previous DescribeLogStreams
	// request.
	NextToken *string `locationName:"nextToken" type:"string"`

	// Specifies what to order the returned log streams by. Valid arguments are
	// 'LogStreamName' or 'LastEventTime'. If you don't specify a value, results
	// are ordered by LogStreamName. If 'LastEventTime' is chosen, the request cannot
	// also contain a logStreamNamePrefix.
	OrderBy *string `locationName:"orderBy" type:"string"`

	metadataDescribeLogStreamsInput `json:"-" xml:"-"`
}

type metadataDescribeLogStreamsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeLogStreamsOutput struct {
	// A list of log streams.
	LogStreams []*LogStream `locationName:"logStreams" type:"list"`

	// A string token used for pagination that points to the next page of results.
	// It must be a value obtained from the response of the previous request. The
	// token expires after 24 hours.
	NextToken *string `locationName:"nextToken" type:"string"`

	metadataDescribeLogStreamsOutput `json:"-" xml:"-"`
}

type metadataDescribeLogStreamsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeMetricFiltersInput struct {
	// Will only return metric filters that match the provided filterNamePrefix.
	// If you don't specify a value, no prefix filter is applied.
	FilterNamePrefix *string `locationName:"filterNamePrefix" type:"string"`

	// The maximum number of items returned in the response. If you don't specify
	// a value, the request would return up to 50 items.
	Limit *int64 `locationName:"limit" type:"integer"`

	// The log group name for which metric filters are to be listed.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	// A string token used for pagination that points to the next page of results.
	// It must be a value obtained from the response of the previous DescribeMetricFilters
	// request.
	NextToken *string `locationName:"nextToken" type:"string"`

	metadataDescribeMetricFiltersInput `json:"-" xml:"-"`
}

type metadataDescribeMetricFiltersInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeMetricFiltersOutput struct {
	MetricFilters []*MetricFilter `locationName:"metricFilters" type:"list"`

	// A string token used for pagination that points to the next page of results.
	// It must be a value obtained from the response of the previous request. The
	// token expires after 24 hours.
	NextToken *string `locationName:"nextToken" type:"string"`

	metadataDescribeMetricFiltersOutput `json:"-" xml:"-"`
}

type metadataDescribeMetricFiltersOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeSubscriptionFiltersInput struct {
	// Will only return subscription filters that match the provided filterNamePrefix.
	// If you don't specify a value, no prefix filter is applied.
	FilterNamePrefix *string `locationName:"filterNamePrefix" type:"string"`

	// The maximum number of results to return.
	Limit *int64 `locationName:"limit" type:"integer"`

	// The log group name for which subscription filters are to be listed.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	// A string token used for pagination that points to the next page of results.
	// It must be a value obtained from the response of the previous request. The
	// token expires after 24 hours.
	NextToken *string `locationName:"nextToken" type:"string"`

	metadataDescribeSubscriptionFiltersInput `json:"-" xml:"-"`
}

type metadataDescribeSubscriptionFiltersInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeSubscriptionFiltersOutput struct {
	// A string token used for pagination that points to the next page of results.
	// It must be a value obtained from the response of the previous request. The
	// token expires after 24 hours.
	NextToken *string `locationName:"nextToken" type:"string"`

	SubscriptionFilters []*SubscriptionFilter `locationName:"subscriptionFilters" type:"list"`

	metadataDescribeSubscriptionFiltersOutput `json:"-" xml:"-"`
}

type metadataDescribeSubscriptionFiltersOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type FilterLogEventsInput struct {
	// A unix timestamp indicating the end time of the range for the request. If
	// provided, events with a timestamp later than this time will not be returned.
	EndTime *int64 `locationName:"endTime" type:"long"`

	// A valid CloudWatch Logs filter pattern to use for filtering the response.
	// If not provided, all the events are matched.
	FilterPattern *string `locationName:"filterPattern" type:"string"`

	// If provided, the API will make a best effort to provide responses that contain
	// events from multiple log streams within the log group interleaved in a single
	// response. If not provided, all the matched log events in the first log stream
	// will be searched first, then those in the next log stream, etc.
	Interleaved *bool `locationName:"interleaved" type:"boolean"`

	// The maximum number of events to return in a page of results. Default is 10,000
	// events.
	Limit *int64 `locationName:"limit" type:"integer"`

	// The name of the log group to query.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	// Optional list of log stream names within the specified log group to search.
	// Defaults to all the log streams in the log group.
	LogStreamNames []*string `locationName:"logStreamNames" type:"list"`

	// A pagination token obtained from a FilterLogEvents response to continue paginating
	// the FilterLogEvents results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// A unix timestamp indicating the start time of the range for the request.
	// If provided, events with a timestamp prior to this time will not be returned.
	StartTime *int64 `locationName:"startTime" type:"long"`

	metadataFilterLogEventsInput `json:"-" xml:"-"`
}

type metadataFilterLogEventsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type FilterLogEventsOutput struct {
	// A list of FilteredLogEvent objects representing the matched events from the
	// request.
	Events []*FilteredLogEvent `locationName:"events" type:"list"`

	// A pagination token obtained from a FilterLogEvents response to continue paginating
	// the FilterLogEvents results.
	NextToken *string `locationName:"nextToken" type:"string"`

	// A list of SearchedLogStream objects indicating which log streams have been
	// searched in this request and whether each has been searched completely or
	// still has more to be paginated.
	SearchedLogStreams []*SearchedLogStream `locationName:"searchedLogStreams" type:"list"`

	metadataFilterLogEventsOutput `json:"-" xml:"-"`
}

type metadataFilterLogEventsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// Represents a matched event from a FilterLogEvents request.
type FilteredLogEvent struct {
	// A unique identifier for this event.
	EventID *string `locationName:"eventId" type:"string"`

	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	IngestionTime *int64 `locationName:"ingestionTime" type:"long"`

	// The name of the log stream this event belongs to.
	LogStreamName *string `locationName:"logStreamName" type:"string"`

	// The data contained in the log event.
	Message *string `locationName:"message" type:"string"`

	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	Timestamp *int64 `locationName:"timestamp" type:"long"`

	metadataFilteredLogEvent `json:"-" xml:"-"`
}

type metadataFilteredLogEvent struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetLogEventsInput struct {
	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	EndTime *int64 `locationName:"endTime" type:"long"`

	// The maximum number of log events returned in the response. If you don't specify
	// a value, the request would return as many log events as can fit in a response
	// size of 1MB, up to 10,000 log events.
	Limit *int64 `locationName:"limit" type:"integer"`

	// The name of the log group to query.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	// The name of the log stream to query.
	LogStreamName *string `locationName:"logStreamName" type:"string" required:"true"`

	// A string token used for pagination that points to the next page of results.
	// It must be a value obtained from the nextForwardToken or nextBackwardToken
	// fields in the response of the previous GetLogEvents request.
	NextToken *string `locationName:"nextToken" type:"string"`

	// If set to true, the earliest log events would be returned first. The default
	// is false (the latest log events are returned first).
	StartFromHead *bool `locationName:"startFromHead" type:"boolean"`

	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	StartTime *int64 `locationName:"startTime" type:"long"`

	metadataGetLogEventsInput `json:"-" xml:"-"`
}

type metadataGetLogEventsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type GetLogEventsOutput struct {
	Events []*OutputLogEvent `locationName:"events" type:"list"`

	// A string token used for pagination that points to the next page of results.
	// It must be a value obtained from the response of the previous request. The
	// token expires after 24 hours.
	NextBackwardToken *string `locationName:"nextBackwardToken" type:"string"`

	// A string token used for pagination that points to the next page of results.
	// It must be a value obtained from the response of the previous request. The
	// token expires after 24 hours.
	NextForwardToken *string `locationName:"nextForwardToken" type:"string"`

	metadataGetLogEventsOutput `json:"-" xml:"-"`
}

type metadataGetLogEventsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// A log event is a record of some activity that was recorded by the application
// or resource being monitored. The log event record that Amazon CloudWatch
// Logs understands contains two properties: the timestamp of when the event
// occurred, and the raw event message.
type InputLogEvent struct {
	Message *string `locationName:"message" type:"string" required:"true"`

	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	Timestamp *int64 `locationName:"timestamp" type:"long" required:"true"`

	metadataInputLogEvent `json:"-" xml:"-"`
}

type metadataInputLogEvent struct {
	SDKShapeTraits bool `type:"structure"`
}

type LogGroup struct {
	ARN *string `locationName:"arn" type:"string"`

	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	CreationTime *int64 `locationName:"creationTime" type:"long"`

	LogGroupName *string `locationName:"logGroupName" type:"string"`

	// The number of metric filters associated with the log group.
	MetricFilterCount *int64 `locationName:"metricFilterCount" type:"integer"`

	// Specifies the number of days you want to retain log events in the specified
	// log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180,
	// 365, 400, 545, 731, 1827, 3653.
	RetentionInDays *int64 `locationName:"retentionInDays" type:"integer"`

	StoredBytes *int64 `locationName:"storedBytes" type:"long"`

	metadataLogGroup `json:"-" xml:"-"`
}

type metadataLogGroup struct {
	SDKShapeTraits bool `type:"structure"`
}

// A log stream is sequence of log events from a single emitter of logs.
type LogStream struct {
	ARN *string `locationName:"arn" type:"string"`

	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	CreationTime *int64 `locationName:"creationTime" type:"long"`

	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	FirstEventTimestamp *int64 `locationName:"firstEventTimestamp" type:"long"`

	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	LastEventTimestamp *int64 `locationName:"lastEventTimestamp" type:"long"`

	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	LastIngestionTime *int64 `locationName:"lastIngestionTime" type:"long"`

	LogStreamName *string `locationName:"logStreamName" type:"string"`

	StoredBytes *int64 `locationName:"storedBytes" type:"long"`

	// A string token used for making PutLogEvents requests. A sequenceToken can
	// only be used once, and PutLogEvents requests must include the sequenceToken
	// obtained from the response of the previous request.
	UploadSequenceToken *string `locationName:"uploadSequenceToken" type:"string"`

	metadataLogStream `json:"-" xml:"-"`
}

type metadataLogStream struct {
	SDKShapeTraits bool `type:"structure"`
}

// Metric filters can be used to express how Amazon CloudWatch Logs would extract
// metric observations from ingested log events and transform them to metric
// data in a CloudWatch metric.
type MetricFilter struct {
	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	CreationTime *int64 `locationName:"creationTime" type:"long"`

	// A name for a metric or subscription filter.
	FilterName *string `locationName:"filterName" type:"string"`

	// A symbolic description of how Amazon CloudWatch Logs should interpret the
	// data in each log event. For example, a log event may contain timestamps,
	// IP addresses, strings, and so on. You use the filter pattern to specify what
	// to look for in the log event message.
	FilterPattern *string `locationName:"filterPattern" type:"string"`

	MetricTransformations []*MetricTransformation `locationName:"metricTransformations" type:"list"`

	metadataMetricFilter `json:"-" xml:"-"`
}

type metadataMetricFilter struct {
	SDKShapeTraits bool `type:"structure"`
}

type MetricFilterMatchRecord struct {
	EventMessage *string `locationName:"eventMessage" type:"string"`

	EventNumber *int64 `locationName:"eventNumber" type:"long"`

	ExtractedValues map[string]*string `locationName:"extractedValues" type:"map"`

	metadataMetricFilterMatchRecord `json:"-" xml:"-"`
}

type metadataMetricFilterMatchRecord struct {
	SDKShapeTraits bool `type:"structure"`
}

type MetricTransformation struct {
	// The name of the CloudWatch metric to which the monitored log information
	// should be published. For example, you may publish to a metric called ErrorCount.
	MetricName *string `locationName:"metricName" type:"string" required:"true"`

	// The destination namespace of the new CloudWatch metric.
	MetricNamespace *string `locationName:"metricNamespace" type:"string" required:"true"`

	// What to publish to the metric. For example, if you're counting the occurrences
	// of a particular term like "Error", the value will be "1" for each occurrence.
	// If you're counting the bytes transferred the published value will be the
	// value in the log event.
	MetricValue *string `locationName:"metricValue" type:"string" required:"true"`

	metadataMetricTransformation `json:"-" xml:"-"`
}

type metadataMetricTransformation struct {
	SDKShapeTraits bool `type:"structure"`
}

type OutputLogEvent struct {
	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	IngestionTime *int64 `locationName:"ingestionTime" type:"long"`

	Message *string `locationName:"message" type:"string"`

	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	Timestamp *int64 `locationName:"timestamp" type:"long"`

	metadataOutputLogEvent `json:"-" xml:"-"`
}

type metadataOutputLogEvent struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutLogEventsInput struct {
	// A list of log events belonging to a log stream.
	LogEvents []*InputLogEvent `locationName:"logEvents" type:"list" required:"true"`

	// The name of the log group to put log events to.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	// The name of the log stream to put log events to.
	LogStreamName *string `locationName:"logStreamName" type:"string" required:"true"`

	// A string token that must be obtained from the response of the previous PutLogEvents
	// request.
	SequenceToken *string `locationName:"sequenceToken" type:"string"`

	metadataPutLogEventsInput `json:"-" xml:"-"`
}

type metadataPutLogEventsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutLogEventsOutput struct {
	// A string token used for making PutLogEvents requests. A sequenceToken can
	// only be used once, and PutLogEvents requests must include the sequenceToken
	// obtained from the response of the previous request.
	NextSequenceToken *string `locationName:"nextSequenceToken" type:"string"`

	RejectedLogEventsInfo *RejectedLogEventsInfo `locationName:"rejectedLogEventsInfo" type:"structure"`

	metadataPutLogEventsOutput `json:"-" xml:"-"`
}

type metadataPutLogEventsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutMetricFilterInput struct {
	// A name for the metric filter.
	FilterName *string `locationName:"filterName" type:"string" required:"true"`

	// A valid CloudWatch Logs filter pattern for extracting metric data out of
	// ingested log events.
	FilterPattern *string `locationName:"filterPattern" type:"string" required:"true"`

	// The name of the log group to associate the metric filter with.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	// A collection of information needed to define how metric data gets emitted.
	MetricTransformations []*MetricTransformation `locationName:"metricTransformations" type:"list" required:"true"`

	metadataPutMetricFilterInput `json:"-" xml:"-"`
}

type metadataPutMetricFilterInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutMetricFilterOutput struct {
	metadataPutMetricFilterOutput `json:"-" xml:"-"`
}

type metadataPutMetricFilterOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutRetentionPolicyInput struct {
	// The name of the log group to associate the retention policy with.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	// Specifies the number of days you want to retain log events in the specified
	// log group. Possible values are: 1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180,
	// 365, 400, 545, 731, 1827, 3653.
	RetentionInDays *int64 `locationName:"retentionInDays" type:"integer" required:"true"`

	metadataPutRetentionPolicyInput `json:"-" xml:"-"`
}

type metadataPutRetentionPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutRetentionPolicyOutput struct {
	metadataPutRetentionPolicyOutput `json:"-" xml:"-"`
}

type metadataPutRetentionPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutSubscriptionFilterInput struct {
	// The ARN of an Amazon Kinesis stream to deliver matching log events to.
	DestinationARN *string `locationName:"destinationArn" type:"string" required:"true"`

	// A name for the subscription filter.
	FilterName *string `locationName:"filterName" type:"string" required:"true"`

	// A valid CloudWatch Logs filter pattern for subscribing to a filtered stream
	// of log events.
	FilterPattern *string `locationName:"filterPattern" type:"string" required:"true"`

	// The name of the log group to associate the subscription filter with.
	LogGroupName *string `locationName:"logGroupName" type:"string" required:"true"`

	// The ARN of an IAM role that grants Amazon CloudWatch Logs permissions to
	// do Amazon Kinesis PutRecord requests on the desitnation stream.
	RoleARN *string `locationName:"roleArn" type:"string" required:"true"`

	metadataPutSubscriptionFilterInput `json:"-" xml:"-"`
}

type metadataPutSubscriptionFilterInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type PutSubscriptionFilterOutput struct {
	metadataPutSubscriptionFilterOutput `json:"-" xml:"-"`
}

type metadataPutSubscriptionFilterOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type RejectedLogEventsInfo struct {
	ExpiredLogEventEndIndex *int64 `locationName:"expiredLogEventEndIndex" type:"integer"`

	TooNewLogEventStartIndex *int64 `locationName:"tooNewLogEventStartIndex" type:"integer"`

	TooOldLogEventEndIndex *int64 `locationName:"tooOldLogEventEndIndex" type:"integer"`

	metadataRejectedLogEventsInfo `json:"-" xml:"-"`
}

type metadataRejectedLogEventsInfo struct {
	SDKShapeTraits bool `type:"structure"`
}

// An object indicating the search status of a log stream in a FilterLogEvents
// request.
type SearchedLogStream struct {
	// The name of the log stream.
	LogStreamName *string `locationName:"logStreamName" type:"string"`

	// Indicates whether all the events in this log stream were searched or more
	// data exists to search by paginating further.
	SearchedCompletely *bool `locationName:"searchedCompletely" type:"boolean"`

	metadataSearchedLogStream `json:"-" xml:"-"`
}

type metadataSearchedLogStream struct {
	SDKShapeTraits bool `type:"structure"`
}

type SubscriptionFilter struct {
	// A point in time expressed as the number of milliseconds since Jan 1, 1970
	// 00:00:00 UTC.
	CreationTime *int64 `locationName:"creationTime" type:"long"`

	DestinationARN *string `locationName:"destinationArn" type:"string"`

	// A name for a metric or subscription filter.
	FilterName *string `locationName:"filterName" type:"string"`

	// A symbolic description of how Amazon CloudWatch Logs should interpret the
	// data in each log event. For example, a log event may contain timestamps,
	// IP addresses, strings, and so on. You use the filter pattern to specify what
	// to look for in the log event message.
	FilterPattern *string `locationName:"filterPattern" type:"string"`

	LogGroupName *string `locationName:"logGroupName" type:"string"`

	RoleARN *string `locationName:"roleArn" type:"string"`

	metadataSubscriptionFilter `json:"-" xml:"-"`
}

type metadataSubscriptionFilter struct {
	SDKShapeTraits bool `type:"structure"`
}

type TestMetricFilterInput struct {
	// A symbolic description of how Amazon CloudWatch Logs should interpret the
	// data in each log event. For example, a log event may contain timestamps,
	// IP addresses, strings, and so on. You use the filter pattern to specify what
	// to look for in the log event message.
	FilterPattern *string `locationName:"filterPattern" type:"string" required:"true"`

	// A list of log event messages to test.
	LogEventMessages []*string `locationName:"logEventMessages" type:"list" required:"true"`

	metadataTestMetricFilterInput `json:"-" xml:"-"`
}

type metadataTestMetricFilterInput struct {
	SDKShapeTraits bool `type:"structure"`
}

type TestMetricFilterOutput struct {
	Matches []*MetricFilterMatchRecord `locationName:"matches" type:"list"`

	metadataTestMetricFilterOutput `json:"-" xml:"-"`
}

type metadataTestMetricFilterOutput struct {
	SDKShapeTraits bool `type:"structure"`
}
