// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package elb provides a client for Elastic Load Balancing.
package elb

import (
	"sync"
	"time"

	"github.com/awslabs/aws-sdk-go/aws"
)

var oprw sync.Mutex

// AddTagsRequest generates a request for the AddTags operation.
func (c *ELB) AddTagsRequest(input *AddTagsInput) (req *aws.Request, output *AddTagsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opAddTags == nil {
		opAddTags = &aws.Operation{
			Name:       "AddTags",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &AddTagsInput{}
	}

	req = c.newRequest(opAddTags, input, output)
	output = &AddTagsOutput{}
	req.Data = output
	return
}

// Adds one or more tags for the specified load balancer. Each load balancer
// can have a maximum of 10 tags. Each tag consists of a key and an optional
// value.
//
// Tag keys must be unique for each load balancer. If a tag with the same key
// is already associated with the load balancer, this action will update the
// value of the key.
//
// For more information, see Tagging (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/TerminologyandKeyConcepts.html#tagging-elb)
// in the Elastic Load Balancing Developer Guide.
func (c *ELB) AddTags(input *AddTagsInput) (output *AddTagsOutput, err error) {
	req, out := c.AddTagsRequest(input)
	output = out
	err = req.Send()
	return
}

var opAddTags *aws.Operation

// ApplySecurityGroupsToLoadBalancerRequest generates a request for the ApplySecurityGroupsToLoadBalancer operation.
func (c *ELB) ApplySecurityGroupsToLoadBalancerRequest(input *ApplySecurityGroupsToLoadBalancerInput) (req *aws.Request, output *ApplySecurityGroupsToLoadBalancerOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opApplySecurityGroupsToLoadBalancer == nil {
		opApplySecurityGroupsToLoadBalancer = &aws.Operation{
			Name:       "ApplySecurityGroupsToLoadBalancer",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &ApplySecurityGroupsToLoadBalancerInput{}
	}

	req = c.newRequest(opApplySecurityGroupsToLoadBalancer, input, output)
	output = &ApplySecurityGroupsToLoadBalancerOutput{}
	req.Data = output
	return
}

// Associates one or more security groups with your load balancer in Amazon
// Virtual Private Cloud (Amazon VPC). The provided security group IDs will
// override any currently applied security groups.
//
// For more information, see Manage Security Groups in Amazon VPC (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/USVPC_ApplySG.html)
// in the Elastic Load Balancing Developer Guide.
func (c *ELB) ApplySecurityGroupsToLoadBalancer(input *ApplySecurityGroupsToLoadBalancerInput) (output *ApplySecurityGroupsToLoadBalancerOutput, err error) {
	req, out := c.ApplySecurityGroupsToLoadBalancerRequest(input)
	output = out
	err = req.Send()
	return
}

var opApplySecurityGroupsToLoadBalancer *aws.Operation

// AttachLoadBalancerToSubnetsRequest generates a request for the AttachLoadBalancerToSubnets operation.
func (c *ELB) AttachLoadBalancerToSubnetsRequest(input *AttachLoadBalancerToSubnetsInput) (req *aws.Request, output *AttachLoadBalancerToSubnetsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opAttachLoadBalancerToSubnets == nil {
		opAttachLoadBalancerToSubnets = &aws.Operation{
			Name:       "AttachLoadBalancerToSubnets",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &AttachLoadBalancerToSubnetsInput{}
	}

	req = c.newRequest(opAttachLoadBalancerToSubnets, input, output)
	output = &AttachLoadBalancerToSubnetsOutput{}
	req.Data = output
	return
}

// Adds one or more subnets to the set of configured subnets in the Amazon Virtual
// Private Cloud (Amazon VPC) for the load balancer.
//
//  The load balancers evenly distribute requests across all of the registered
// subnets. For more information, see Deploy Elastic Load Balancing in Amazon
// VPC (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/UserScenariosForVPC.html)
// in the Elastic Load Balancing Developer Guide.
func (c *ELB) AttachLoadBalancerToSubnets(input *AttachLoadBalancerToSubnetsInput) (output *AttachLoadBalancerToSubnetsOutput, err error) {
	req, out := c.AttachLoadBalancerToSubnetsRequest(input)
	output = out
	err = req.Send()
	return
}

var opAttachLoadBalancerToSubnets *aws.Operation

// ConfigureHealthCheckRequest generates a request for the ConfigureHealthCheck operation.
func (c *ELB) ConfigureHealthCheckRequest(input *ConfigureHealthCheckInput) (req *aws.Request, output *ConfigureHealthCheckOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opConfigureHealthCheck == nil {
		opConfigureHealthCheck = &aws.Operation{
			Name:       "ConfigureHealthCheck",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &ConfigureHealthCheckInput{}
	}

	req = c.newRequest(opConfigureHealthCheck, input, output)
	output = &ConfigureHealthCheckOutput{}
	req.Data = output
	return
}

// Specifies the health check settings to use for evaluating the health state
// of your back-end instances.
//
// For more information, see Health Check (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/TerminologyandKeyConcepts.html#healthcheck)
// in the Elastic Load Balancing Developer Guide.
func (c *ELB) ConfigureHealthCheck(input *ConfigureHealthCheckInput) (output *ConfigureHealthCheckOutput, err error) {
	req, out := c.ConfigureHealthCheckRequest(input)
	output = out
	err = req.Send()
	return
}

var opConfigureHealthCheck *aws.Operation

// CreateAppCookieStickinessPolicyRequest generates a request for the CreateAppCookieStickinessPolicy operation.
func (c *ELB) CreateAppCookieStickinessPolicyRequest(input *CreateAppCookieStickinessPolicyInput) (req *aws.Request, output *CreateAppCookieStickinessPolicyOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCreateAppCookieStickinessPolicy == nil {
		opCreateAppCookieStickinessPolicy = &aws.Operation{
			Name:       "CreateAppCookieStickinessPolicy",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &CreateAppCookieStickinessPolicyInput{}
	}

	req = c.newRequest(opCreateAppCookieStickinessPolicy, input, output)
	output = &CreateAppCookieStickinessPolicyOutput{}
	req.Data = output
	return
}

// Generates a stickiness policy with sticky session lifetimes that follow that
// of an application-generated cookie. This policy can be associated only with
// HTTP/HTTPS listeners.
//
//  This policy is similar to the policy created by CreateLBCookieStickinessPolicy,
// except that the lifetime of the special Elastic Load Balancing cookie follows
// the lifetime of the application-generated cookie specified in the policy
// configuration. The load balancer only inserts a new stickiness cookie when
// the application response includes a new application cookie.
//
//  If the application cookie is explicitly removed or expires, the session
// stops being sticky until a new application cookie is issued.
//
//  An application client must receive and send two cookies: the application-generated
// cookie and the special Elastic Load Balancing cookie named AWSELB. This is
// the default behavior for many common web browsers.  For more information,
// see Enabling Application-Controlled Session Stickiness (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/US_StickySessions.html#US_EnableStickySessionsAppCookies)
// in the Elastic Load Balancing Developer Guide.
func (c *ELB) CreateAppCookieStickinessPolicy(input *CreateAppCookieStickinessPolicyInput) (output *CreateAppCookieStickinessPolicyOutput, err error) {
	req, out := c.CreateAppCookieStickinessPolicyRequest(input)
	output = out
	err = req.Send()
	return
}

var opCreateAppCookieStickinessPolicy *aws.Operation

// CreateLBCookieStickinessPolicyRequest generates a request for the CreateLBCookieStickinessPolicy operation.
func (c *ELB) CreateLBCookieStickinessPolicyRequest(input *CreateLBCookieStickinessPolicyInput) (req *aws.Request, output *CreateLBCookieStickinessPolicyOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCreateLBCookieStickinessPolicy == nil {
		opCreateLBCookieStickinessPolicy = &aws.Operation{
			Name:       "CreateLBCookieStickinessPolicy",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &CreateLBCookieStickinessPolicyInput{}
	}

	req = c.newRequest(opCreateLBCookieStickinessPolicy, input, output)
	output = &CreateLBCookieStickinessPolicyOutput{}
	req.Data = output
	return
}

// Generates a stickiness policy with sticky session lifetimes controlled by
// the lifetime of the browser (user-agent) or a specified expiration period.
// This policy can be associated only with HTTP/HTTPS listeners.
//
//  When a load balancer implements this policy, the load balancer uses a special
// cookie to track the backend server instance for each request. When the load
// balancer receives a request, it first checks to see if this cookie is present
// in the request. If so, the load balancer sends the request to the application
// server specified in the cookie. If not, the load balancer sends the request
// to a server that is chosen based on the existing load balancing algorithm.
//
//  A cookie is inserted into the response for binding subsequent requests
// from the same user to that server. The validity of the cookie is based on
// the cookie expiration time, which is specified in the policy configuration.
//
// For more information, see Enabling Duration-Based Session Stickiness (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/US_StickySessions.html#US_EnableStickySessionsLBCookies)
// in the Elastic Load Balancing Developer Guide.
func (c *ELB) CreateLBCookieStickinessPolicy(input *CreateLBCookieStickinessPolicyInput) (output *CreateLBCookieStickinessPolicyOutput, err error) {
	req, out := c.CreateLBCookieStickinessPolicyRequest(input)
	output = out
	err = req.Send()
	return
}

var opCreateLBCookieStickinessPolicy *aws.Operation

// CreateLoadBalancerRequest generates a request for the CreateLoadBalancer operation.
func (c *ELB) CreateLoadBalancerRequest(input *CreateLoadBalancerInput) (req *aws.Request, output *CreateLoadBalancerOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCreateLoadBalancer == nil {
		opCreateLoadBalancer = &aws.Operation{
			Name:       "CreateLoadBalancer",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &CreateLoadBalancerInput{}
	}

	req = c.newRequest(opCreateLoadBalancer, input, output)
	output = &CreateLoadBalancerOutput{}
	req.Data = output
	return
}

// Creates a new load balancer.
//
//  After the call has completed successfully, a new load balancer is created
// with a unique Domain Name Service (DNS) name. The DNS name includes the name
// of the AWS region in which the load balance was created. For example, if
// your load balancer was created in the United States, the DNS name might end
// with either of the following:
//
//   us-east-1.elb.amazonaws.com (for the Northern Virginia region)   us-west-1.elb.amazonaws.com
// (for the Northern California region)   For information about the AWS regions
// supported by Elastic Load Balancing, see Regions and Endpoints (http://docs.aws.amazon.com/general/latest/gr/rande.html#elb_region).
//
// You can create up to 20 load balancers per region per account.
//
// Elastic Load Balancing supports load balancing your Amazon EC2 instances
// launched within any one of the following platforms:
//
//   EC2-Classic For information on creating and managing your load balancers
// in EC2-Classic, see Deploy Elastic Load Balancing in Amazon EC2-Classic (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/UserScenariosForEC2.html).
//
//   EC2-VPC For information on creating and managing your load balancers in
// EC2-VPC, see Deploy Elastic Load Balancing in Amazon VPC (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/UserScenariosForVPC.html).
func (c *ELB) CreateLoadBalancer(input *CreateLoadBalancerInput) (output *CreateLoadBalancerOutput, err error) {
	req, out := c.CreateLoadBalancerRequest(input)
	output = out
	err = req.Send()
	return
}

var opCreateLoadBalancer *aws.Operation

// CreateLoadBalancerListenersRequest generates a request for the CreateLoadBalancerListeners operation.
func (c *ELB) CreateLoadBalancerListenersRequest(input *CreateLoadBalancerListenersInput) (req *aws.Request, output *CreateLoadBalancerListenersOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCreateLoadBalancerListeners == nil {
		opCreateLoadBalancerListeners = &aws.Operation{
			Name:       "CreateLoadBalancerListeners",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &CreateLoadBalancerListenersInput{}
	}

	req = c.newRequest(opCreateLoadBalancerListeners, input, output)
	output = &CreateLoadBalancerListenersOutput{}
	req.Data = output
	return
}

// Creates one or more listeners on a load balancer for the specified port.
// If a listener with the given port does not already exist, it will be created;
// otherwise, the properties of the new listener must match the properties of
// the existing listener.
//
// For more information, see Add a Listener to Your Load Balancer (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/us-add-listener.html)
// in the Elastic Load Balancing Developer Guide.
func (c *ELB) CreateLoadBalancerListeners(input *CreateLoadBalancerListenersInput) (output *CreateLoadBalancerListenersOutput, err error) {
	req, out := c.CreateLoadBalancerListenersRequest(input)
	output = out
	err = req.Send()
	return
}

var opCreateLoadBalancerListeners *aws.Operation

// CreateLoadBalancerPolicyRequest generates a request for the CreateLoadBalancerPolicy operation.
func (c *ELB) CreateLoadBalancerPolicyRequest(input *CreateLoadBalancerPolicyInput) (req *aws.Request, output *CreateLoadBalancerPolicyOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opCreateLoadBalancerPolicy == nil {
		opCreateLoadBalancerPolicy = &aws.Operation{
			Name:       "CreateLoadBalancerPolicy",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &CreateLoadBalancerPolicyInput{}
	}

	req = c.newRequest(opCreateLoadBalancerPolicy, input, output)
	output = &CreateLoadBalancerPolicyOutput{}
	req.Data = output
	return
}

// Creates a new policy that contains the necessary attributes depending on
// the policy type. Policies are settings that are saved for your load balancer
// and that can be applied to the front-end listener, or the back-end application
// server, depending on your policy type.
func (c *ELB) CreateLoadBalancerPolicy(input *CreateLoadBalancerPolicyInput) (output *CreateLoadBalancerPolicyOutput, err error) {
	req, out := c.CreateLoadBalancerPolicyRequest(input)
	output = out
	err = req.Send()
	return
}

var opCreateLoadBalancerPolicy *aws.Operation

// DeleteLoadBalancerRequest generates a request for the DeleteLoadBalancer operation.
func (c *ELB) DeleteLoadBalancerRequest(input *DeleteLoadBalancerInput) (req *aws.Request, output *DeleteLoadBalancerOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteLoadBalancer == nil {
		opDeleteLoadBalancer = &aws.Operation{
			Name:       "DeleteLoadBalancer",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DeleteLoadBalancerInput{}
	}

	req = c.newRequest(opDeleteLoadBalancer, input, output)
	output = &DeleteLoadBalancerOutput{}
	req.Data = output
	return
}

// Deletes the specified load balancer.
//
//  If attempting to recreate the load balancer, you must reconfigure all the
// settings. The DNS name associated with a deleted load balancer will no longer
// be usable. Once deleted, the name and associated DNS record of the load balancer
// no longer exist and traffic sent to any of its IP addresses will no longer
// be delivered to back-end instances.
//
//  To successfully call this API, you must provide the same account credentials
// as were used to create the load balancer.
//
//  By design, if the load balancer does not exist or has already been deleted,
// a call to DeleteLoadBalancer action still succeeds.
func (c *ELB) DeleteLoadBalancer(input *DeleteLoadBalancerInput) (output *DeleteLoadBalancerOutput, err error) {
	req, out := c.DeleteLoadBalancerRequest(input)
	output = out
	err = req.Send()
	return
}

var opDeleteLoadBalancer *aws.Operation

// DeleteLoadBalancerListenersRequest generates a request for the DeleteLoadBalancerListeners operation.
func (c *ELB) DeleteLoadBalancerListenersRequest(input *DeleteLoadBalancerListenersInput) (req *aws.Request, output *DeleteLoadBalancerListenersOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteLoadBalancerListeners == nil {
		opDeleteLoadBalancerListeners = &aws.Operation{
			Name:       "DeleteLoadBalancerListeners",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DeleteLoadBalancerListenersInput{}
	}

	req = c.newRequest(opDeleteLoadBalancerListeners, input, output)
	output = &DeleteLoadBalancerListenersOutput{}
	req.Data = output
	return
}

// Deletes listeners from the load balancer for the specified port.
func (c *ELB) DeleteLoadBalancerListeners(input *DeleteLoadBalancerListenersInput) (output *DeleteLoadBalancerListenersOutput, err error) {
	req, out := c.DeleteLoadBalancerListenersRequest(input)
	output = out
	err = req.Send()
	return
}

var opDeleteLoadBalancerListeners *aws.Operation

// DeleteLoadBalancerPolicyRequest generates a request for the DeleteLoadBalancerPolicy operation.
func (c *ELB) DeleteLoadBalancerPolicyRequest(input *DeleteLoadBalancerPolicyInput) (req *aws.Request, output *DeleteLoadBalancerPolicyOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeleteLoadBalancerPolicy == nil {
		opDeleteLoadBalancerPolicy = &aws.Operation{
			Name:       "DeleteLoadBalancerPolicy",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DeleteLoadBalancerPolicyInput{}
	}

	req = c.newRequest(opDeleteLoadBalancerPolicy, input, output)
	output = &DeleteLoadBalancerPolicyOutput{}
	req.Data = output
	return
}

// Deletes a policy from the load balancer. The specified policy must not be
// enabled for any listeners.
func (c *ELB) DeleteLoadBalancerPolicy(input *DeleteLoadBalancerPolicyInput) (output *DeleteLoadBalancerPolicyOutput, err error) {
	req, out := c.DeleteLoadBalancerPolicyRequest(input)
	output = out
	err = req.Send()
	return
}

var opDeleteLoadBalancerPolicy *aws.Operation

// DeregisterInstancesFromLoadBalancerRequest generates a request for the DeregisterInstancesFromLoadBalancer operation.
func (c *ELB) DeregisterInstancesFromLoadBalancerRequest(input *DeregisterInstancesFromLoadBalancerInput) (req *aws.Request, output *DeregisterInstancesFromLoadBalancerOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDeregisterInstancesFromLoadBalancer == nil {
		opDeregisterInstancesFromLoadBalancer = &aws.Operation{
			Name:       "DeregisterInstancesFromLoadBalancer",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DeregisterInstancesFromLoadBalancerInput{}
	}

	req = c.newRequest(opDeregisterInstancesFromLoadBalancer, input, output)
	output = &DeregisterInstancesFromLoadBalancerOutput{}
	req.Data = output
	return
}

// Deregisters instances from the load balancer. Once the instance is deregistered,
// it will stop receiving traffic from the load balancer.
//
//  In order to successfully call this API, the same account credentials as
// those used to create the load balancer must be provided.
//
// For more information, see De-register and Register Amazon EC2 Instances
// (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/US_DeReg_Reg_Instances.html)
// in the Elastic Load Balancing Developer Guide.
//
// You can use DescribeLoadBalancers to verify if the instance is deregistered
// from the load balancer.
func (c *ELB) DeregisterInstancesFromLoadBalancer(input *DeregisterInstancesFromLoadBalancerInput) (output *DeregisterInstancesFromLoadBalancerOutput, err error) {
	req, out := c.DeregisterInstancesFromLoadBalancerRequest(input)
	output = out
	err = req.Send()
	return
}

var opDeregisterInstancesFromLoadBalancer *aws.Operation

// DescribeInstanceHealthRequest generates a request for the DescribeInstanceHealth operation.
func (c *ELB) DescribeInstanceHealthRequest(input *DescribeInstanceHealthInput) (req *aws.Request, output *DescribeInstanceHealthOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDescribeInstanceHealth == nil {
		opDescribeInstanceHealth = &aws.Operation{
			Name:       "DescribeInstanceHealth",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DescribeInstanceHealthInput{}
	}

	req = c.newRequest(opDescribeInstanceHealth, input, output)
	output = &DescribeInstanceHealthOutput{}
	req.Data = output
	return
}

// Returns the current state of the specified instances registered with the
// specified load balancer. If no instances are specified, the state of all
// the instances registered with the load balancer is returned.
//
//  You must provide the same account credentials as those that were used to
// create the load balancer.
func (c *ELB) DescribeInstanceHealth(input *DescribeInstanceHealthInput) (output *DescribeInstanceHealthOutput, err error) {
	req, out := c.DescribeInstanceHealthRequest(input)
	output = out
	err = req.Send()
	return
}

var opDescribeInstanceHealth *aws.Operation

// DescribeLoadBalancerAttributesRequest generates a request for the DescribeLoadBalancerAttributes operation.
func (c *ELB) DescribeLoadBalancerAttributesRequest(input *DescribeLoadBalancerAttributesInput) (req *aws.Request, output *DescribeLoadBalancerAttributesOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDescribeLoadBalancerAttributes == nil {
		opDescribeLoadBalancerAttributes = &aws.Operation{
			Name:       "DescribeLoadBalancerAttributes",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DescribeLoadBalancerAttributesInput{}
	}

	req = c.newRequest(opDescribeLoadBalancerAttributes, input, output)
	output = &DescribeLoadBalancerAttributesOutput{}
	req.Data = output
	return
}

// Returns detailed information about all of the attributes associated with
// the specified load balancer.
func (c *ELB) DescribeLoadBalancerAttributes(input *DescribeLoadBalancerAttributesInput) (output *DescribeLoadBalancerAttributesOutput, err error) {
	req, out := c.DescribeLoadBalancerAttributesRequest(input)
	output = out
	err = req.Send()
	return
}

var opDescribeLoadBalancerAttributes *aws.Operation

// DescribeLoadBalancerPoliciesRequest generates a request for the DescribeLoadBalancerPolicies operation.
func (c *ELB) DescribeLoadBalancerPoliciesRequest(input *DescribeLoadBalancerPoliciesInput) (req *aws.Request, output *DescribeLoadBalancerPoliciesOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDescribeLoadBalancerPolicies == nil {
		opDescribeLoadBalancerPolicies = &aws.Operation{
			Name:       "DescribeLoadBalancerPolicies",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DescribeLoadBalancerPoliciesInput{}
	}

	req = c.newRequest(opDescribeLoadBalancerPolicies, input, output)
	output = &DescribeLoadBalancerPoliciesOutput{}
	req.Data = output
	return
}

// Returns detailed descriptions of the policies. If you specify a load balancer
// name, the action returns the descriptions of all the policies created for
// the load balancer. If you specify a policy name associated with your load
// balancer, the action returns the description of that policy. If you don't
// specify a load balancer name, the action returns descriptions of the specified
// sample policies, or descriptions of all the sample policies. The names of
// the sample policies have the ELBSample- prefix.
func (c *ELB) DescribeLoadBalancerPolicies(input *DescribeLoadBalancerPoliciesInput) (output *DescribeLoadBalancerPoliciesOutput, err error) {
	req, out := c.DescribeLoadBalancerPoliciesRequest(input)
	output = out
	err = req.Send()
	return
}

var opDescribeLoadBalancerPolicies *aws.Operation

// DescribeLoadBalancerPolicyTypesRequest generates a request for the DescribeLoadBalancerPolicyTypes operation.
func (c *ELB) DescribeLoadBalancerPolicyTypesRequest(input *DescribeLoadBalancerPolicyTypesInput) (req *aws.Request, output *DescribeLoadBalancerPolicyTypesOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDescribeLoadBalancerPolicyTypes == nil {
		opDescribeLoadBalancerPolicyTypes = &aws.Operation{
			Name:       "DescribeLoadBalancerPolicyTypes",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DescribeLoadBalancerPolicyTypesInput{}
	}

	req = c.newRequest(opDescribeLoadBalancerPolicyTypes, input, output)
	output = &DescribeLoadBalancerPolicyTypesOutput{}
	req.Data = output
	return
}

// Returns meta-information on the specified load balancer policies defined
// by the Elastic Load Balancing service. The policy types that are returned
// from this action can be used in a CreateLoadBalancerPolicy action to instantiate
// specific policy configurations that will be applied to a load balancer.
func (c *ELB) DescribeLoadBalancerPolicyTypes(input *DescribeLoadBalancerPolicyTypesInput) (output *DescribeLoadBalancerPolicyTypesOutput, err error) {
	req, out := c.DescribeLoadBalancerPolicyTypesRequest(input)
	output = out
	err = req.Send()
	return
}

var opDescribeLoadBalancerPolicyTypes *aws.Operation

// DescribeLoadBalancersRequest generates a request for the DescribeLoadBalancers operation.
func (c *ELB) DescribeLoadBalancersRequest(input *DescribeLoadBalancersInput) (req *aws.Request, output *DescribeLoadBalancersOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDescribeLoadBalancers == nil {
		opDescribeLoadBalancers = &aws.Operation{
			Name:       "DescribeLoadBalancers",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DescribeLoadBalancersInput{}
	}

	req = c.newRequest(opDescribeLoadBalancers, input, output)
	output = &DescribeLoadBalancersOutput{}
	req.Data = output
	return
}

// Returns detailed configuration information for all the load balancers created
// for the account. If you specify load balancer names, the action returns configuration
// information of the specified load balancers.
//
//  In order to retrieve this information, you must provide the same account
// credentials that was used to create the load balancer.
func (c *ELB) DescribeLoadBalancers(input *DescribeLoadBalancersInput) (output *DescribeLoadBalancersOutput, err error) {
	req, out := c.DescribeLoadBalancersRequest(input)
	output = out
	err = req.Send()
	return
}

var opDescribeLoadBalancers *aws.Operation

// DescribeTagsRequest generates a request for the DescribeTags operation.
func (c *ELB) DescribeTagsRequest(input *DescribeTagsInput) (req *aws.Request, output *DescribeTagsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDescribeTags == nil {
		opDescribeTags = &aws.Operation{
			Name:       "DescribeTags",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DescribeTagsInput{}
	}

	req = c.newRequest(opDescribeTags, input, output)
	output = &DescribeTagsOutput{}
	req.Data = output
	return
}

// Describes the tags associated with one or more load balancers.
func (c *ELB) DescribeTags(input *DescribeTagsInput) (output *DescribeTagsOutput, err error) {
	req, out := c.DescribeTagsRequest(input)
	output = out
	err = req.Send()
	return
}

var opDescribeTags *aws.Operation

// DetachLoadBalancerFromSubnetsRequest generates a request for the DetachLoadBalancerFromSubnets operation.
func (c *ELB) DetachLoadBalancerFromSubnetsRequest(input *DetachLoadBalancerFromSubnetsInput) (req *aws.Request, output *DetachLoadBalancerFromSubnetsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDetachLoadBalancerFromSubnets == nil {
		opDetachLoadBalancerFromSubnets = &aws.Operation{
			Name:       "DetachLoadBalancerFromSubnets",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DetachLoadBalancerFromSubnetsInput{}
	}

	req = c.newRequest(opDetachLoadBalancerFromSubnets, input, output)
	output = &DetachLoadBalancerFromSubnetsOutput{}
	req.Data = output
	return
}

// Removes subnets from the set of configured subnets in the Amazon Virtual
// Private Cloud (Amazon VPC) for the load balancer.
//
//  After a subnet is removed all of the EC2 instances registered with the
// load balancer that are in the removed subnet will go into the OutOfService
// state. When a subnet is removed, the load balancer will balance the traffic
// among the remaining routable subnets for the load balancer.
func (c *ELB) DetachLoadBalancerFromSubnets(input *DetachLoadBalancerFromSubnetsInput) (output *DetachLoadBalancerFromSubnetsOutput, err error) {
	req, out := c.DetachLoadBalancerFromSubnetsRequest(input)
	output = out
	err = req.Send()
	return
}

var opDetachLoadBalancerFromSubnets *aws.Operation

// DisableAvailabilityZonesForLoadBalancerRequest generates a request for the DisableAvailabilityZonesForLoadBalancer operation.
func (c *ELB) DisableAvailabilityZonesForLoadBalancerRequest(input *DisableAvailabilityZonesForLoadBalancerInput) (req *aws.Request, output *DisableAvailabilityZonesForLoadBalancerOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opDisableAvailabilityZonesForLoadBalancer == nil {
		opDisableAvailabilityZonesForLoadBalancer = &aws.Operation{
			Name:       "DisableAvailabilityZonesForLoadBalancer",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &DisableAvailabilityZonesForLoadBalancerInput{}
	}

	req = c.newRequest(opDisableAvailabilityZonesForLoadBalancer, input, output)
	output = &DisableAvailabilityZonesForLoadBalancerOutput{}
	req.Data = output
	return
}

// Removes the specified EC2 Availability Zones from the set of configured Availability
// Zones for the load balancer.
//
//  There must be at least one Availability Zone registered with a load balancer
// at all times. Once an Availability Zone is removed, all the instances registered
// with the load balancer that are in the removed Availability Zone go into
// the OutOfService state. Upon Availability Zone removal, the load balancer
// attempts to equally balance the traffic among its remaining usable Availability
// Zones. Trying to remove an Availability Zone that was not associated with
// the load balancer does nothing.
//
// For more information, see Disable an Availability Zone from a Load-Balanced
// Application (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/US_ShrinkLBApp04.html)
// in the Elastic Load Balancing Developer Guide.
func (c *ELB) DisableAvailabilityZonesForLoadBalancer(input *DisableAvailabilityZonesForLoadBalancerInput) (output *DisableAvailabilityZonesForLoadBalancerOutput, err error) {
	req, out := c.DisableAvailabilityZonesForLoadBalancerRequest(input)
	output = out
	err = req.Send()
	return
}

var opDisableAvailabilityZonesForLoadBalancer *aws.Operation

// EnableAvailabilityZonesForLoadBalancerRequest generates a request for the EnableAvailabilityZonesForLoadBalancer operation.
func (c *ELB) EnableAvailabilityZonesForLoadBalancerRequest(input *EnableAvailabilityZonesForLoadBalancerInput) (req *aws.Request, output *EnableAvailabilityZonesForLoadBalancerOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opEnableAvailabilityZonesForLoadBalancer == nil {
		opEnableAvailabilityZonesForLoadBalancer = &aws.Operation{
			Name:       "EnableAvailabilityZonesForLoadBalancer",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &EnableAvailabilityZonesForLoadBalancerInput{}
	}

	req = c.newRequest(opEnableAvailabilityZonesForLoadBalancer, input, output)
	output = &EnableAvailabilityZonesForLoadBalancerOutput{}
	req.Data = output
	return
}

// Adds one or more EC2 Availability Zones to the load balancer.
//
//  The load balancer evenly distributes requests across all its registered
// Availability Zones that contain instances.
//
//  The new EC2 Availability Zones to be added must be in the same EC2 Region
// as the Availability Zones for which the load balancer was created.  For more
// information, see Expand a Load Balanced Application to an Additional Availability
// Zone (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/US_AddLBAvailabilityZone.html)
// in the Elastic Load Balancing Developer Guide.
func (c *ELB) EnableAvailabilityZonesForLoadBalancer(input *EnableAvailabilityZonesForLoadBalancerInput) (output *EnableAvailabilityZonesForLoadBalancerOutput, err error) {
	req, out := c.EnableAvailabilityZonesForLoadBalancerRequest(input)
	output = out
	err = req.Send()
	return
}

var opEnableAvailabilityZonesForLoadBalancer *aws.Operation

// ModifyLoadBalancerAttributesRequest generates a request for the ModifyLoadBalancerAttributes operation.
func (c *ELB) ModifyLoadBalancerAttributesRequest(input *ModifyLoadBalancerAttributesInput) (req *aws.Request, output *ModifyLoadBalancerAttributesOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opModifyLoadBalancerAttributes == nil {
		opModifyLoadBalancerAttributes = &aws.Operation{
			Name:       "ModifyLoadBalancerAttributes",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &ModifyLoadBalancerAttributesInput{}
	}

	req = c.newRequest(opModifyLoadBalancerAttributes, input, output)
	output = &ModifyLoadBalancerAttributesOutput{}
	req.Data = output
	return
}

// Modifies the attributes of a specified load balancer.
//
// You can modify the load balancer attributes, such as AccessLogs, ConnectionDraining,
// and CrossZoneLoadBalancing by either enabling or disabling them. Or, you
// can modify the load balancer attribute ConnectionSettings by specifying an
// idle connection timeout value for your load balancer.
//
// For more information, see the following:
//
//  Cross-Zone Load Balancing (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/TerminologyandKeyConcepts.html#request-routing)
// Connection Draining (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/TerminologyandKeyConcepts.html#conn-drain)
// Access Logs (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/access-log-collection.html)
// Idle Connection Timeout (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/TerminologyandKeyConcepts.html#idle-timeout)
func (c *ELB) ModifyLoadBalancerAttributes(input *ModifyLoadBalancerAttributesInput) (output *ModifyLoadBalancerAttributesOutput, err error) {
	req, out := c.ModifyLoadBalancerAttributesRequest(input)
	output = out
	err = req.Send()
	return
}

var opModifyLoadBalancerAttributes *aws.Operation

// RegisterInstancesWithLoadBalancerRequest generates a request for the RegisterInstancesWithLoadBalancer operation.
func (c *ELB) RegisterInstancesWithLoadBalancerRequest(input *RegisterInstancesWithLoadBalancerInput) (req *aws.Request, output *RegisterInstancesWithLoadBalancerOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opRegisterInstancesWithLoadBalancer == nil {
		opRegisterInstancesWithLoadBalancer = &aws.Operation{
			Name:       "RegisterInstancesWithLoadBalancer",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &RegisterInstancesWithLoadBalancerInput{}
	}

	req = c.newRequest(opRegisterInstancesWithLoadBalancer, input, output)
	output = &RegisterInstancesWithLoadBalancerOutput{}
	req.Data = output
	return
}

// Adds new instances to the load balancer.
//
//  Once the instance is registered, it starts receiving traffic and requests
// from the load balancer. Any instance that is not in any of the Availability
// Zones registered for the load balancer will be moved to the OutOfService
// state. It will move to the InService state when the Availability Zone is
// added to the load balancer.
//
// When an instance registered with a load balancer is stopped and then restarted,
// the IP addresses associated with the instance changes. Elastic Load Balancing
// cannot recognize the new IP address, which prevents it from routing traffic
// to the instances. We recommend that you de-register your Amazon EC2 instances
// from your load balancer after you stop your instance, and then register the
// load balancer with your instance after you've restarted. To de-register your
// instances from load balancer, use DeregisterInstancesFromLoadBalancer action.
//
// For more information, see De-register and Register Amazon EC2 Instances
// (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/US_DeReg_Reg_Instances.html)
// in the Elastic Load Balancing Developer Guide.
//
//  In order for this call to be successful, you must provide the same account
// credentials as those that were used to create the load balancer.   Completion
// of this API does not guarantee that operation has completed. Rather, it means
// that the request has been registered and the changes will happen shortly.
//  You can use DescribeLoadBalancers or DescribeInstanceHealth action to check
// the state of the newly registered instances.
func (c *ELB) RegisterInstancesWithLoadBalancer(input *RegisterInstancesWithLoadBalancerInput) (output *RegisterInstancesWithLoadBalancerOutput, err error) {
	req, out := c.RegisterInstancesWithLoadBalancerRequest(input)
	output = out
	err = req.Send()
	return
}

var opRegisterInstancesWithLoadBalancer *aws.Operation

// RemoveTagsRequest generates a request for the RemoveTags operation.
func (c *ELB) RemoveTagsRequest(input *RemoveTagsInput) (req *aws.Request, output *RemoveTagsOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opRemoveTags == nil {
		opRemoveTags = &aws.Operation{
			Name:       "RemoveTags",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &RemoveTagsInput{}
	}

	req = c.newRequest(opRemoveTags, input, output)
	output = &RemoveTagsOutput{}
	req.Data = output
	return
}

// Removes one or more tags from the specified load balancer.
func (c *ELB) RemoveTags(input *RemoveTagsInput) (output *RemoveTagsOutput, err error) {
	req, out := c.RemoveTagsRequest(input)
	output = out
	err = req.Send()
	return
}

var opRemoveTags *aws.Operation

// SetLoadBalancerListenerSSLCertificateRequest generates a request for the SetLoadBalancerListenerSSLCertificate operation.
func (c *ELB) SetLoadBalancerListenerSSLCertificateRequest(input *SetLoadBalancerListenerSSLCertificateInput) (req *aws.Request, output *SetLoadBalancerListenerSSLCertificateOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opSetLoadBalancerListenerSSLCertificate == nil {
		opSetLoadBalancerListenerSSLCertificate = &aws.Operation{
			Name:       "SetLoadBalancerListenerSSLCertificate",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &SetLoadBalancerListenerSSLCertificateInput{}
	}

	req = c.newRequest(opSetLoadBalancerListenerSSLCertificate, input, output)
	output = &SetLoadBalancerListenerSSLCertificateOutput{}
	req.Data = output
	return
}

// Sets the certificate that terminates the specified listener's SSL connections.
// The specified certificate replaces any prior certificate that was used on
// the same load balancer and port.
//
// For more information on updating your SSL certificate, see Updating an SSL
// Certificate for a Load Balancer (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/US_UpdatingLoadBalancerSSL.html)
// in the Elastic Load Balancing Developer Guide.
func (c *ELB) SetLoadBalancerListenerSSLCertificate(input *SetLoadBalancerListenerSSLCertificateInput) (output *SetLoadBalancerListenerSSLCertificateOutput, err error) {
	req, out := c.SetLoadBalancerListenerSSLCertificateRequest(input)
	output = out
	err = req.Send()
	return
}

var opSetLoadBalancerListenerSSLCertificate *aws.Operation

// SetLoadBalancerPoliciesForBackendServerRequest generates a request for the SetLoadBalancerPoliciesForBackendServer operation.
func (c *ELB) SetLoadBalancerPoliciesForBackendServerRequest(input *SetLoadBalancerPoliciesForBackendServerInput) (req *aws.Request, output *SetLoadBalancerPoliciesForBackendServerOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opSetLoadBalancerPoliciesForBackendServer == nil {
		opSetLoadBalancerPoliciesForBackendServer = &aws.Operation{
			Name:       "SetLoadBalancerPoliciesForBackendServer",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &SetLoadBalancerPoliciesForBackendServerInput{}
	}

	req = c.newRequest(opSetLoadBalancerPoliciesForBackendServer, input, output)
	output = &SetLoadBalancerPoliciesForBackendServerOutput{}
	req.Data = output
	return
}

// Replaces the current set of policies associated with a port on which the
// back-end server is listening with a new set of policies. After the policies
// have been created using CreateLoadBalancerPolicy, they can be applied here
// as a list. At this time, only the back-end server authentication policy type
// can be applied to the back-end ports; this policy type is composed of multiple
// public key policies.
//
//  The SetLoadBalancerPoliciesForBackendServer replaces the current set of
// policies associated with the specified instance port. Every time you use
// this action to enable the policies, use the PolicyNames parameter to list
// all the policies you want to enable.
//
//  You can use DescribeLoadBalancers or DescribeLoadBalancerPolicies action
// to verify that the policy has been associated with the back-end server.
func (c *ELB) SetLoadBalancerPoliciesForBackendServer(input *SetLoadBalancerPoliciesForBackendServerInput) (output *SetLoadBalancerPoliciesForBackendServerOutput, err error) {
	req, out := c.SetLoadBalancerPoliciesForBackendServerRequest(input)
	output = out
	err = req.Send()
	return
}

var opSetLoadBalancerPoliciesForBackendServer *aws.Operation

// SetLoadBalancerPoliciesOfListenerRequest generates a request for the SetLoadBalancerPoliciesOfListener operation.
func (c *ELB) SetLoadBalancerPoliciesOfListenerRequest(input *SetLoadBalancerPoliciesOfListenerInput) (req *aws.Request, output *SetLoadBalancerPoliciesOfListenerOutput) {
	oprw.Lock()
	defer oprw.Unlock()

	if opSetLoadBalancerPoliciesOfListener == nil {
		opSetLoadBalancerPoliciesOfListener = &aws.Operation{
			Name:       "SetLoadBalancerPoliciesOfListener",
			HTTPMethod: "POST",
			HTTPPath:   "/",
		}
	}

	if input == nil {
		input = &SetLoadBalancerPoliciesOfListenerInput{}
	}

	req = c.newRequest(opSetLoadBalancerPoliciesOfListener, input, output)
	output = &SetLoadBalancerPoliciesOfListenerOutput{}
	req.Data = output
	return
}

// Associates, updates, or disables a policy with a listener on the load balancer.
// You can associate multiple policies with a listener.
func (c *ELB) SetLoadBalancerPoliciesOfListener(input *SetLoadBalancerPoliciesOfListenerInput) (output *SetLoadBalancerPoliciesOfListenerOutput, err error) {
	req, out := c.SetLoadBalancerPoliciesOfListenerRequest(input)
	output = out
	err = req.Send()
	return
}

var opSetLoadBalancerPoliciesOfListener *aws.Operation

// The AccessLog data type.
type AccessLog struct {
	// The interval for publishing the access logs. You can specify an interval
	// of either 5 minutes or 60 minutes.
	//
	// Default: 60 minutes
	EmitInterval *int64 `type:"integer"`

	// Specifies whether access log is enabled for the load balancer.
	Enabled *bool `type:"boolean" required:"true"`

	// The name of the Amazon S3 bucket where the access logs are stored.
	S3BucketName *string `type:"string"`

	// The logical hierarchy you created for your Amazon S3 bucket, for example
	// my-bucket-prefix/prod. If the prefix is not provided, the log is placed at
	// the root level of the bucket.
	S3BucketPrefix *string `type:"string"`

	metadataAccessLog `json:"-", xml:"-"`
}

type metadataAccessLog struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the AddTags action
type AddTagsInput struct {
	// The name of the load balancer to tag. You can specify a maximum of one load
	// balancer name.
	LoadBalancerNames []*string `type:"list" required:"true"`

	// A list of tags for each load balancer.
	Tags []*Tag `type:"list" required:"true"`

	metadataAddTagsInput `json:"-", xml:"-"`
}

type metadataAddTagsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the AddTags action.
type AddTagsOutput struct {
	metadataAddTagsOutput `json:"-", xml:"-"`
}

type metadataAddTagsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type AdditionalAttribute struct {
	Key *string `type:"string"`

	Value *string `type:"string"`

	metadataAdditionalAttribute `json:"-", xml:"-"`
}

type metadataAdditionalAttribute struct {
	SDKShapeTraits bool `type:"structure"`
}

// The AppCookieStickinessPolicy data type.
type AppCookieStickinessPolicy struct {
	// The name of the application cookie used for stickiness.
	CookieName *string `type:"string"`

	// The mnemonic name for the policy being created. The name must be unique within
	// a set of policies for this load balancer.
	PolicyName *string `type:"string"`

	metadataAppCookieStickinessPolicy `json:"-", xml:"-"`
}

type metadataAppCookieStickinessPolicy struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the ApplySecurityGroupsToLoadBalancer action.
type ApplySecurityGroupsToLoadBalancerInput struct {
	// The name associated with the load balancer. The name must be unique within
	// the set of load balancers associated with your AWS account.
	LoadBalancerName *string `type:"string" required:"true"`

	// A list of security group IDs to associate with your load balancer in VPC.
	// The security group IDs must be provided as the ID and not the security group
	// name (For example, sg-1234).
	SecurityGroups []*string `type:"list" required:"true"`

	metadataApplySecurityGroupsToLoadBalancerInput `json:"-", xml:"-"`
}

type metadataApplySecurityGroupsToLoadBalancerInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The out for the ApplySecurityGroupsToLoadBalancer action.
type ApplySecurityGroupsToLoadBalancerOutput struct {
	// A list of security group IDs associated with your load balancer.
	SecurityGroups []*string `type:"list"`

	metadataApplySecurityGroupsToLoadBalancerOutput `json:"-", xml:"-"`
}

type metadataApplySecurityGroupsToLoadBalancerOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the AttachLoadBalancerToSubnets action.
type AttachLoadBalancerToSubnetsInput struct {
	// The name associated with the load balancer. The name must be unique within
	// the set of load balancers associated with your AWS account.
	LoadBalancerName *string `type:"string" required:"true"`

	// A list of subnet IDs to add for the load balancer. You can add only one subnet
	// per Availability Zone.
	Subnets []*string `type:"list" required:"true"`

	metadataAttachLoadBalancerToSubnetsInput `json:"-", xml:"-"`
}

type metadataAttachLoadBalancerToSubnetsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the AttachLoadBalancerToSubnets action.
type AttachLoadBalancerToSubnetsOutput struct {
	// A list of subnet IDs attached to the load balancer.
	Subnets []*string `type:"list"`

	metadataAttachLoadBalancerToSubnetsOutput `json:"-", xml:"-"`
}

type metadataAttachLoadBalancerToSubnetsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// This data type is used as a response element in the DescribeLoadBalancers
// action to describe the configuration of the back-end server.
type BackendServerDescription struct {
	// Provides the port on which the back-end server is listening.
	InstancePort *int64 `type:"integer"`

	// Provides a list of policy names enabled for the back-end server.
	PolicyNames []*string `type:"list"`

	metadataBackendServerDescription `json:"-", xml:"-"`
}

type metadataBackendServerDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// Input for the ConfigureHealthCheck action.
type ConfigureHealthCheckInput struct {
	// A structure containing the configuration information for the new healthcheck.
	HealthCheck *HealthCheck `type:"structure" required:"true"`

	// The mnemonic name associated with the load balancer. The name must be unique
	// within the set of load balancers associated with your AWS account.
	LoadBalancerName *string `type:"string" required:"true"`

	metadataConfigureHealthCheckInput `json:"-", xml:"-"`
}

type metadataConfigureHealthCheckInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the ConfigureHealthCheck action.
type ConfigureHealthCheckOutput struct {
	// The updated healthcheck for the instances.
	HealthCheck *HealthCheck `type:"structure"`

	metadataConfigureHealthCheckOutput `json:"-", xml:"-"`
}

type metadataConfigureHealthCheckOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The ConnectionDraining data type.
type ConnectionDraining struct {
	// Specifies whether connection draining is enabled for the load balancer.
	Enabled *bool `type:"boolean" required:"true"`

	// Specifies the maximum time (in seconds) to keep the existing connections
	// open before deregistering the instances.
	Timeout *int64 `type:"integer"`

	metadataConnectionDraining `json:"-", xml:"-"`
}

type metadataConnectionDraining struct {
	SDKShapeTraits bool `type:"structure"`
}

// The ConnectionSettings data type.
type ConnectionSettings struct {
	// Specifies the time (in seconds) the connection is allowed to be idle (no
	// data has been sent over the connection) before it is closed by the load balancer.
	IdleTimeout *int64 `type:"integer" required:"true"`

	metadataConnectionSettings `json:"-", xml:"-"`
}

type metadataConnectionSettings struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the CreateAppCookieStickinessPolicy action.
type CreateAppCookieStickinessPolicyInput struct {
	// Name of the application cookie used for stickiness.
	CookieName *string `type:"string" required:"true"`

	// The name of the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	// The name of the policy being created. The name must be unique within the
	// set of policies for this load balancer.
	PolicyName *string `type:"string" required:"true"`

	metadataCreateAppCookieStickinessPolicyInput `json:"-", xml:"-"`
}

type metadataCreateAppCookieStickinessPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the CreateAppCookieStickinessPolicy action.
type CreateAppCookieStickinessPolicyOutput struct {
	metadataCreateAppCookieStickinessPolicyOutput `json:"-", xml:"-"`
}

type metadataCreateAppCookieStickinessPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the CreateLBCookieStickinessPolicy action.
type CreateLBCookieStickinessPolicyInput struct {
	// The time period in seconds after which the cookie should be considered stale.
	// Not specifying this parameter indicates that the sticky session will last
	// for the duration of the browser session.
	CookieExpirationPeriod *int64 `type:"long"`

	// The name associated with the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	// The name of the policy being created. The name must be unique within the
	// set of policies for this load balancer.
	PolicyName *string `type:"string" required:"true"`

	metadataCreateLBCookieStickinessPolicyInput `json:"-", xml:"-"`
}

type metadataCreateLBCookieStickinessPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the CreateLBCookieStickinessPolicy action.
type CreateLBCookieStickinessPolicyOutput struct {
	metadataCreateLBCookieStickinessPolicyOutput `json:"-", xml:"-"`
}

type metadataCreateLBCookieStickinessPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the CreateLoadBalancer action.
type CreateLoadBalancerInput struct {
	// A list of Availability Zones.
	//
	//  At least one Availability Zone must be specified. Specified Availability
	// Zones must be in the same EC2 Region as the load balancer. Traffic will be
	// equally distributed across all zones.
	//
	//  You can later add more Availability Zones after the creation of the load
	// balancer by calling EnableAvailabilityZonesForLoadBalancer action.
	AvailabilityZones []*string `type:"list"`

	// A list of the following tuples: Protocol, LoadBalancerPort, InstanceProtocol,
	// InstancePort, and SSLCertificateId.
	Listeners []*Listener `type:"list" required:"true"`

	// The name associated with the load balancer. The name must be unique within
	// your set of load balancers, must have a maximum of 32 characters, and must
	// only contain alphanumeric characters or hyphens.
	LoadBalancerName *string `type:"string" required:"true"`

	// The type of a load balancer.
	//
	// By default, Elastic Load Balancing creates an Internet-facing load balancer
	// with a publicly resolvable DNS name, which resolves to public IP addresses.
	// For more information about Internet-facing and Internal load balancers, see
	// Internet-facing and Internal Load Balancers (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/vpc-loadbalancer-types.html).
	//
	// Specify the value internal for this option to create an internal load balancer
	// with a DNS name that resolves to private IP addresses.
	//
	//  This option is only available for load balancers created within EC2-VPC.
	Scheme *string `type:"string"`

	// The security groups to assign to your load balancer within your VPC.
	SecurityGroups []*string `type:"list"`

	// A list of subnet IDs in your VPC to attach to your load balancer. Specify
	// one subnet per Availability Zone.
	Subnets []*string `type:"list"`

	// A list of tags to assign to the load balancer.
	//
	// For more information about setting tags for your load balancer, see Tagging
	// (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/TerminologyandKeyConcepts.html#tagging-elb).
	Tags []*Tag `type:"list"`

	metadataCreateLoadBalancerInput `json:"-", xml:"-"`
}

type metadataCreateLoadBalancerInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the CreateLoadBalancerListeners action.
type CreateLoadBalancerListenersInput struct {
	// A list of LoadBalancerPort, InstancePort, Protocol, InstanceProtocol, and
	// SSLCertificateId items.
	Listeners []*Listener `type:"list" required:"true"`

	// The name of the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	metadataCreateLoadBalancerListenersInput `json:"-", xml:"-"`
}

type metadataCreateLoadBalancerListenersInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the CreateLoadBalancerListeners action.
type CreateLoadBalancerListenersOutput struct {
	metadataCreateLoadBalancerListenersOutput `json:"-", xml:"-"`
}

type metadataCreateLoadBalancerListenersOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the CreateLoadBalancer action.
type CreateLoadBalancerOutput struct {
	// The DNS name for the load balancer.
	DNSName *string `type:"string"`

	metadataCreateLoadBalancerOutput `json:"-", xml:"-"`
}

type metadataCreateLoadBalancerOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type CreateLoadBalancerPolicyInput struct {
	// The name associated with the LoadBalancer for which the policy is being created.
	LoadBalancerName *string `type:"string" required:"true"`

	// A list of attributes associated with the policy being created.
	PolicyAttributes []*PolicyAttribute `type:"list"`

	// The name of the load balancer policy being created. The name must be unique
	// within the set of policies for this load balancer.
	PolicyName *string `type:"string" required:"true"`

	// The name of the base policy type being used to create this policy. To get
	// the list of policy types, use the DescribeLoadBalancerPolicyTypes action.
	PolicyTypeName *string `type:"string" required:"true"`

	metadataCreateLoadBalancerPolicyInput `json:"-", xml:"-"`
}

type metadataCreateLoadBalancerPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the CreateLoadBalancerPolicy action.
type CreateLoadBalancerPolicyOutput struct {
	metadataCreateLoadBalancerPolicyOutput `json:"-", xml:"-"`
}

type metadataCreateLoadBalancerPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The CrossZoneLoadBalancing data type.
type CrossZoneLoadBalancing struct {
	// Specifies whether cross-zone load balancing is enabled for the load balancer.
	Enabled *bool `type:"boolean" required:"true"`

	metadataCrossZoneLoadBalancing `json:"-", xml:"-"`
}

type metadataCrossZoneLoadBalancing struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the DeleteLoadBalancer action.
type DeleteLoadBalancerInput struct {
	// The name associated with the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	metadataDeleteLoadBalancerInput `json:"-", xml:"-"`
}

type metadataDeleteLoadBalancerInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the DeleteLoadBalancerListeners action.
type DeleteLoadBalancerListenersInput struct {
	// The mnemonic name associated with the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	// The client port number(s) of the load balancer listener(s) to be removed.
	LoadBalancerPorts []*int64 `type:"list" required:"true"`

	metadataDeleteLoadBalancerListenersInput `json:"-", xml:"-"`
}

type metadataDeleteLoadBalancerListenersInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the DeleteLoadBalancerListeners action.
type DeleteLoadBalancerListenersOutput struct {
	metadataDeleteLoadBalancerListenersOutput `json:"-", xml:"-"`
}

type metadataDeleteLoadBalancerListenersOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the DeleteLoadBalancer action.
type DeleteLoadBalancerOutput struct {
	metadataDeleteLoadBalancerOutput `json:"-", xml:"-"`
}

type metadataDeleteLoadBalancerOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the DeleteLoadBalancerPolicy action.
type DeleteLoadBalancerPolicyInput struct {
	// The mnemonic name associated with the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	// The mnemonic name for the policy being deleted.
	PolicyName *string `type:"string" required:"true"`

	metadataDeleteLoadBalancerPolicyInput `json:"-", xml:"-"`
}

type metadataDeleteLoadBalancerPolicyInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the DeleteLoadBalancerPolicy action.
type DeleteLoadBalancerPolicyOutput struct {
	metadataDeleteLoadBalancerPolicyOutput `json:"-", xml:"-"`
}

type metadataDeleteLoadBalancerPolicyOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the DeregisterInstancesFromLoadBalancer action.
type DeregisterInstancesFromLoadBalancerInput struct {
	// A list of EC2 instance IDs consisting of all instances to be deregistered.
	Instances []*Instance `type:"list" required:"true"`

	// The name associated with the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	metadataDeregisterInstancesFromLoadBalancerInput `json:"-", xml:"-"`
}

type metadataDeregisterInstancesFromLoadBalancerInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the DeregisterInstancesFromLoadBalancer action.
type DeregisterInstancesFromLoadBalancerOutput struct {
	// An updated list of remaining instances registered with the load balancer.
	Instances []*Instance `type:"list"`

	metadataDeregisterInstancesFromLoadBalancerOutput `json:"-", xml:"-"`
}

type metadataDeregisterInstancesFromLoadBalancerOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the DescribeEndPointState action.
type DescribeInstanceHealthInput struct {
	// A list of instance IDs whose states are being queried.
	Instances []*Instance `type:"list"`

	// The name of the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	metadataDescribeInstanceHealthInput `json:"-", xml:"-"`
}

type metadataDescribeInstanceHealthInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the DescribeInstanceHealth action.
type DescribeInstanceHealthOutput struct {
	// A list containing health information for the specified instances.
	InstanceStates []*InstanceState `type:"list"`

	metadataDescribeInstanceHealthOutput `json:"-", xml:"-"`
}

type metadataDescribeInstanceHealthOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the DescribeLoadBalancerAttributes action.
type DescribeLoadBalancerAttributesInput struct {
	// The name of the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	metadataDescribeLoadBalancerAttributesInput `json:"-", xml:"-"`
}

type metadataDescribeLoadBalancerAttributesInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The following element is returned in a structure named DescribeLoadBalancerAttributesResult.
type DescribeLoadBalancerAttributesOutput struct {
	// The load balancer attributes structure.
	LoadBalancerAttributes *LoadBalancerAttributes `type:"structure"`

	metadataDescribeLoadBalancerAttributesOutput `json:"-", xml:"-"`
}

type metadataDescribeLoadBalancerAttributesOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeLoadBalancerPoliciesInput struct {
	// The mnemonic name associated with the load balancer. If no name is specified,
	// the operation returns the attributes of either all the sample policies pre-defined
	// by Elastic Load Balancing or the specified sample polices.
	LoadBalancerName *string `type:"string"`

	// The names of load balancer policies you've created or Elastic Load Balancing
	// sample policy names.
	PolicyNames []*string `type:"list"`

	metadataDescribeLoadBalancerPoliciesInput `json:"-", xml:"-"`
}

type metadataDescribeLoadBalancerPoliciesInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the DescribeLoadBalancerPolicies action.
type DescribeLoadBalancerPoliciesOutput struct {
	// A list of policy description structures.
	PolicyDescriptions []*PolicyDescription `type:"list"`

	metadataDescribeLoadBalancerPoliciesOutput `json:"-", xml:"-"`
}

type metadataDescribeLoadBalancerPoliciesOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

type DescribeLoadBalancerPolicyTypesInput struct {
	// Specifies the name of the policy types. If no names are specified, returns
	// the description of all the policy types defined by Elastic Load Balancing
	// service.
	PolicyTypeNames []*string `type:"list"`

	metadataDescribeLoadBalancerPolicyTypesInput `json:"-", xml:"-"`
}

type metadataDescribeLoadBalancerPolicyTypesInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the DescribeLoadBalancerPolicyTypes action.
type DescribeLoadBalancerPolicyTypesOutput struct {
	// List of policy type description structures of the specified policy type.
	// If no policy type names are specified, returns the description of all the
	// policy types defined by Elastic Load Balancing service.
	PolicyTypeDescriptions []*PolicyTypeDescription `type:"list"`

	metadataDescribeLoadBalancerPolicyTypesOutput `json:"-", xml:"-"`
}

type metadataDescribeLoadBalancerPolicyTypesOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the DescribeLoadBalancers action.
type DescribeLoadBalancersInput struct {
	// A list of load balancer names associated with the account.
	LoadBalancerNames []*string `type:"list"`

	// An optional parameter used for pagination of results from this call. If specified,
	// the response includes only records beyond the marker.
	Marker *string `type:"string"`

	// The number of results returned in each page. The default is 400. You cannot
	// specify a page size greater than 400 or less than 1.
	PageSize *int64 `type:"integer"`

	metadataDescribeLoadBalancersInput `json:"-", xml:"-"`
}

type metadataDescribeLoadBalancersInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the DescribeLoadBalancers action.
type DescribeLoadBalancersOutput struct {
	// A list of load balancer description structures.
	LoadBalancerDescriptions []*LoadBalancerDescription `type:"list"`

	// Specifies the value of next marker if the request returned more than one
	// page of results.
	NextMarker *string `type:"string"`

	metadataDescribeLoadBalancersOutput `json:"-", xml:"-"`
}

type metadataDescribeLoadBalancersOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the DescribeTags action.
type DescribeTagsInput struct {
	// The names of the load balancers.
	LoadBalancerNames []*string `type:"list" required:"true"`

	metadataDescribeTagsInput `json:"-", xml:"-"`
}

type metadataDescribeTagsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the DescribeTags action.
type DescribeTagsOutput struct {
	// A list of tag description structures.
	TagDescriptions []*TagDescription `type:"list"`

	metadataDescribeTagsOutput `json:"-", xml:"-"`
}

type metadataDescribeTagsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the DetachLoadBalancerFromSubnets action.
type DetachLoadBalancerFromSubnetsInput struct {
	// The name associated with the load balancer to be detached.
	LoadBalancerName *string `type:"string" required:"true"`

	// A list of subnet IDs to remove from the set of configured subnets for the
	// load balancer.
	Subnets []*string `type:"list" required:"true"`

	metadataDetachLoadBalancerFromSubnetsInput `json:"-", xml:"-"`
}

type metadataDetachLoadBalancerFromSubnetsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the DetachLoadBalancerFromSubnets action.
type DetachLoadBalancerFromSubnetsOutput struct {
	// A list of subnet IDs the load balancer is now attached to.
	Subnets []*string `type:"list"`

	metadataDetachLoadBalancerFromSubnetsOutput `json:"-", xml:"-"`
}

type metadataDetachLoadBalancerFromSubnetsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the DisableAvailabilityZonesForLoadBalancer action.
type DisableAvailabilityZonesForLoadBalancerInput struct {
	// A list of Availability Zones to be removed from the load balancer.
	//
	//  There must be at least one Availability Zone registered with a load balancer
	// at all times. Specified Availability Zones must be in the same region.
	AvailabilityZones []*string `type:"list" required:"true"`

	// The name associated with the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	metadataDisableAvailabilityZonesForLoadBalancerInput `json:"-", xml:"-"`
}

type metadataDisableAvailabilityZonesForLoadBalancerInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the DisableAvailabilityZonesForLoadBalancer action.
type DisableAvailabilityZonesForLoadBalancerOutput struct {
	// A list of updated Availability Zones for the load balancer.
	AvailabilityZones []*string `type:"list"`

	metadataDisableAvailabilityZonesForLoadBalancerOutput `json:"-", xml:"-"`
}

type metadataDisableAvailabilityZonesForLoadBalancerOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the EnableAvailabilityZonesForLoadBalancer action.
type EnableAvailabilityZonesForLoadBalancerInput struct {
	// A list of new Availability Zones for the load balancer. Each Availability
	// Zone must be in the same region as the load balancer.
	AvailabilityZones []*string `type:"list" required:"true"`

	// The name associated with the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	metadataEnableAvailabilityZonesForLoadBalancerInput `json:"-", xml:"-"`
}

type metadataEnableAvailabilityZonesForLoadBalancerInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the EnableAvailabilityZonesForLoadBalancer action.
type EnableAvailabilityZonesForLoadBalancerOutput struct {
	// An updated list of Availability Zones for the load balancer.
	AvailabilityZones []*string `type:"list"`

	metadataEnableAvailabilityZonesForLoadBalancerOutput `json:"-", xml:"-"`
}

type metadataEnableAvailabilityZonesForLoadBalancerOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The HealthCheck data type.
type HealthCheck struct {
	// Specifies the number of consecutive health probe successes required before
	// moving the instance to the Healthy state.
	HealthyThreshold *int64 `type:"integer" required:"true"`

	// Specifies the approximate interval, in seconds, between health checks of
	// an individual instance.
	Interval *int64 `type:"integer" required:"true"`

	// Specifies the instance being checked. The protocol is either TCP, HTTP, HTTPS,
	// or SSL. The range of valid ports is one (1) through 65535.
	//
	//   TCP is the default, specified as a TCP: port pair, for example "TCP:5000".
	// In this case a healthcheck simply attempts to open a TCP connection to the
	// instance on the specified port. Failure to connect within the configured
	// timeout is considered unhealthy.
	//
	// SSL is also specified as SSL: port pair, for example, SSL:5000.
	//
	//  For HTTP or HTTPS protocol, the situation is different. You have to include
	// a ping path in the string. HTTP is specified as a HTTP:port;/;PathToPing;
	// grouping, for example "HTTP:80/weather/us/wa/seattle". In this case, a HTTP
	// GET request is issued to the instance on the given port and path. Any answer
	// other than "200 OK" within the timeout period is considered unhealthy.
	//
	//  The total length of the HTTP ping target needs to be 1024 16-bit Unicode
	// characters or less.
	Target *string `type:"string" required:"true"`

	// Specifies the amount of time, in seconds, during which no response means
	// a failed health probe.
	//
	//  This value must be less than the Interval value.
	Timeout *int64 `type:"integer" required:"true"`

	// Specifies the number of consecutive health probe failures required before
	// moving the instance to the Unhealthy state.
	UnhealthyThreshold *int64 `type:"integer" required:"true"`

	metadataHealthCheck `json:"-", xml:"-"`
}

type metadataHealthCheck struct {
	SDKShapeTraits bool `type:"structure"`
}

// The Instance data type.
type Instance struct {
	// Provides an EC2 instance ID.
	InstanceID *string `locationName:"InstanceId" type:"string"`

	metadataInstance `json:"-", xml:"-"`
}

type metadataInstance struct {
	SDKShapeTraits bool `type:"structure"`
}

// The InstanceState data type.
type InstanceState struct {
	// Provides a description of the instance state.
	Description *string `type:"string"`

	// Provides an EC2 instance ID.
	InstanceID *string `locationName:"InstanceId" type:"string"`

	// Provides information about the cause of OutOfService instances. Specifically,
	// it indicates whether the cause is Elastic Load Balancing or the instance
	// behind the load balancer.
	//
	// Valid value: ELB|Instance|N/A
	ReasonCode *string `type:"string"`

	// Specifies the current state of the instance.
	//
	// Valid value: InService|OutOfService|Unknown
	State *string `type:"string"`

	metadataInstanceState `json:"-", xml:"-"`
}

type metadataInstanceState struct {
	SDKShapeTraits bool `type:"structure"`
}

// The LBCookieStickinessPolicy data type.
type LBCookieStickinessPolicy struct {
	// The time period in seconds after which the cookie should be considered stale.
	// Not specifying this parameter indicates that the stickiness session will
	// last for the duration of the browser session.
	CookieExpirationPeriod *int64 `type:"long"`

	// The name for the policy being created. The name must be unique within the
	// set of policies for this load balancer.
	PolicyName *string `type:"string"`

	metadataLBCookieStickinessPolicy `json:"-", xml:"-"`
}

type metadataLBCookieStickinessPolicy struct {
	SDKShapeTraits bool `type:"structure"`
}

// The Listener data type.
type Listener struct {
	// Specifies the TCP port on which the instance server is listening. This property
	// cannot be modified for the life of the load balancer.
	InstancePort *int64 `type:"integer" required:"true"`

	// Specifies the protocol to use for routing traffic to back-end instances -
	// HTTP, HTTPS, TCP, or SSL. This property cannot be modified for the life of
	// the load balancer.
	//
	//  If the front-end protocol is HTTP or HTTPS, InstanceProtocol has to be
	// at the same protocol layer, i.e., HTTP or HTTPS. Likewise, if the front-end
	// protocol is TCP or SSL, InstanceProtocol has to be TCP or SSL.   If there
	// is another listener with the same InstancePort whose InstanceProtocol is
	// secure, i.e., HTTPS or SSL, the listener's InstanceProtocol has to be secure,
	// i.e., HTTPS or SSL. If there is another listener with the same InstancePort
	// whose InstanceProtocol is HTTP or TCP, the listener's InstanceProtocol must
	// be either HTTP or TCP.
	InstanceProtocol *string `type:"string"`

	// Specifies the external load balancer port number. This property cannot be
	// modified for the life of the load balancer.
	LoadBalancerPort *int64 `type:"integer" required:"true"`

	// Specifies the load balancer transport protocol to use for routing - HTTP,
	// HTTPS, TCP or SSL. This property cannot be modified for the life of the load
	// balancer.
	Protocol *string `type:"string" required:"true"`

	// The ARN string of the server certificate. To get the ARN of the server certificate,
	// call the AWS Identity and Access Management UploadServerCertificate  (http://docs.aws.amazon.com/IAM/latest/APIReference/index.html?API_UploadServerCertificate.html)
	// API.
	SSLCertificateID *string `locationName:"SSLCertificateId" type:"string"`

	metadataListener `json:"-", xml:"-"`
}

type metadataListener struct {
	SDKShapeTraits bool `type:"structure"`
}

// The ListenerDescription data type.
type ListenerDescription struct {
	// The Listener data type.
	Listener *Listener `type:"structure"`

	// A list of policies enabled for this listener. An empty list indicates that
	// no policies are enabled.
	PolicyNames []*string `type:"list"`

	metadataListenerDescription `json:"-", xml:"-"`
}

type metadataListenerDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// The LoadBalancerAttributes data type.
type LoadBalancerAttributes struct {
	// The name of the load balancer attribute. If enabled, the load balancer captures
	// detailed information of all the requests and delivers the information to
	// the Amazon S3 bucket that you specify.
	//
	// For more information, see Enable Access Logs (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/enable-access-logs.html).
	AccessLog *AccessLog `type:"structure"`

	AdditionalAttributes []*AdditionalAttribute `type:"list"`

	// The name of the load balancer attribute. If enabled, the load balancer allows
	// existing requests to complete before the load balancer shifts traffic away
	// from a deregistered or unhealthy back-end instance.
	//
	// For more information, see Enable Connection Draining (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/config-conn-drain.html).
	ConnectionDraining *ConnectionDraining `type:"structure"`

	// The name of the load balancer attribute.
	//
	// By default, Elastic Load Balancing maintains a 60-second idle connection
	// timeout for both front-end and back-end connections of your load balancer.
	// If the ConnectionSettings attribute is set, Elastic Load Balancing will allow
	// the connections to remain idle (no data is sent over the connection) for
	// the specified duration.
	//
	// For more information, see Configure Idle Connection Timeout (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/config-idle-timeout.html).
	ConnectionSettings *ConnectionSettings `type:"structure"`

	// The name of the load balancer attribute. If enabled, the load balancer routes
	// the request traffic evenly across all back-end instances regardless of the
	// Availability Zones.
	//
	// For more information, see Enable Cross-Zone Load Balancing (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/enable-disable-crosszone-lb.html).
	CrossZoneLoadBalancing *CrossZoneLoadBalancing `type:"structure"`

	metadataLoadBalancerAttributes `json:"-", xml:"-"`
}

type metadataLoadBalancerAttributes struct {
	SDKShapeTraits bool `type:"structure"`
}

// Contains the result of a successful invocation of DescribeLoadBalancers.
type LoadBalancerDescription struct {
	// Specifies a list of Availability Zones.
	AvailabilityZones []*string `type:"list"`

	// Contains a list of back-end server descriptions.
	BackendServerDescriptions []*BackendServerDescription `type:"list"`

	// Provides the name of the Amazon Route 53 hosted zone that is associated with
	// the load balancer. For information on how to associate your load balancer
	// with a hosted zone, go to Using Domain Names With Elastic Load Balancing
	// (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/using-domain-names-with-elb.html)
	// in the Elastic Load Balancing Developer Guide.
	CanonicalHostedZoneName *string `type:"string"`

	// Provides the ID of the Amazon Route 53 hosted zone name that is associated
	// with the load balancer. For information on how to associate or disassociate
	// your load balancer with a hosted zone, go to Using Domain Names With Elastic
	// Load Balancing (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/using-domain-names-with-elb.html)
	// in the Elastic Load Balancing Developer Guide.
	CanonicalHostedZoneNameID *string `type:"string"`

	// Provides the date and time the load balancer was created.
	CreatedTime *time.Time `type:"timestamp" timestampFormat:"iso8601"`

	// Specifies the external DNS name associated with the load balancer.
	DNSName *string `type:"string"`

	// Specifies information regarding the various health probes conducted on the
	// load balancer.
	HealthCheck *HealthCheck `type:"structure"`

	// Provides a list of EC2 instance IDs for the load balancer.
	Instances []*Instance `type:"list"`

	// LoadBalancerPort, InstancePort, Protocol, InstanceProtocol, and PolicyNames
	// are returned in a list of tuples in the ListenerDescriptions element.
	ListenerDescriptions []*ListenerDescription `type:"list"`

	// Specifies the name associated with the load balancer.
	LoadBalancerName *string `type:"string"`

	// Provides a list of policies defined for the load balancer.
	Policies *Policies `type:"structure"`

	// Specifies the type of load balancer.
	//
	// If the Scheme is internet-facing, the load balancer has a publicly resolvable
	// DNS name that resolves to public IP addresses.
	//
	// If the Scheme is internal, the load balancer has a publicly resolvable DNS
	// name that resolves to private IP addresses.
	//
	//  This option is only available for load balancers attached to an Amazon
	// VPC.
	Scheme *string `type:"string"`

	// The security groups the load balancer is a member of (VPC only).
	SecurityGroups []*string `type:"list"`

	// The security group that you can use as part of your inbound rules for your
	// load balancer's back-end Amazon EC2 application instances. To only allow
	// traffic from load balancers, add a security group rule to your back end instance
	// that specifies this source security group as the inbound source.
	SourceSecurityGroup *SourceSecurityGroup `type:"structure"`

	// Provides a list of VPC subnet IDs for the load balancer.
	Subnets []*string `type:"list"`

	// Provides the ID of the VPC attached to the load balancer.
	VPCID *string `locationName:"VPCId" type:"string"`

	metadataLoadBalancerDescription `json:"-", xml:"-"`
}

type metadataLoadBalancerDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the ModifyLoadBalancerAttributes action.
type ModifyLoadBalancerAttributesInput struct {
	// Attributes of the load balancer.
	LoadBalancerAttributes *LoadBalancerAttributes `type:"structure" required:"true"`

	// The name of the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	metadataModifyLoadBalancerAttributesInput `json:"-", xml:"-"`
}

type metadataModifyLoadBalancerAttributesInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the ModifyLoadBalancerAttributes action.
type ModifyLoadBalancerAttributesOutput struct {
	// The LoadBalancerAttributes data type.
	LoadBalancerAttributes *LoadBalancerAttributes `type:"structure"`

	// The name of the load balancer.
	LoadBalancerName *string `type:"string"`

	metadataModifyLoadBalancerAttributesOutput `json:"-", xml:"-"`
}

type metadataModifyLoadBalancerAttributesOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The policies data type.
type Policies struct {
	// A list of the AppCookieStickinessPolicy objects created with CreateAppCookieStickinessPolicy.
	AppCookieStickinessPolicies []*AppCookieStickinessPolicy `type:"list"`

	// A list of LBCookieStickinessPolicy objects created with CreateAppCookieStickinessPolicy.
	LBCookieStickinessPolicies []*LBCookieStickinessPolicy `type:"list"`

	// A list of policy names other than the stickiness policies.
	OtherPolicies []*string `type:"list"`

	metadataPolicies `json:"-", xml:"-"`
}

type metadataPolicies struct {
	SDKShapeTraits bool `type:"structure"`
}

// The PolicyAttribute data type. This data type contains a key/value pair that
// defines properties of a specific policy.
type PolicyAttribute struct {
	// The name of the attribute associated with the policy.
	AttributeName *string `type:"string"`

	// The value of the attribute associated with the policy.
	AttributeValue *string `type:"string"`

	metadataPolicyAttribute `json:"-", xml:"-"`
}

type metadataPolicyAttribute struct {
	SDKShapeTraits bool `type:"structure"`
}

// The PolicyAttributeDescription data type. This data type is used to describe
// the attributes and values associated with a policy.
type PolicyAttributeDescription struct {
	// The name of the attribute associated with the policy.
	AttributeName *string `type:"string"`

	// The value of the attribute associated with the policy.
	AttributeValue *string `type:"string"`

	metadataPolicyAttributeDescription `json:"-", xml:"-"`
}

type metadataPolicyAttributeDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// The PolicyAttributeTypeDescription data type. This data type is used to describe
// values that are acceptable for the policy attribute.
type PolicyAttributeTypeDescription struct {
	// The name of the attribute associated with the policy type.
	AttributeName *string `type:"string"`

	// The type of attribute. For example, Boolean, Integer, etc.
	AttributeType *string `type:"string"`

	// The cardinality of the attribute. Valid Values:  ONE(1) : Single value required
	// ZERO_OR_ONE(0..1) : Up to one value can be supplied ZERO_OR_MORE(0..*) :
	// Optional. Multiple values are allowed ONE_OR_MORE(1..*0) : Required. Multiple
	// values are allowed
	Cardinality *string `type:"string"`

	// The default value of the attribute, if applicable.
	DefaultValue *string `type:"string"`

	// A human-readable description of the attribute.
	Description *string `type:"string"`

	metadataPolicyAttributeTypeDescription `json:"-", xml:"-"`
}

type metadataPolicyAttributeTypeDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// The PolicyDescription data type.
type PolicyDescription struct {
	// A list of policy attribute description structures.
	PolicyAttributeDescriptions []*PolicyAttributeDescription `type:"list"`

	// The name of the policy associated with the load balancer.
	PolicyName *string `type:"string"`

	// The name of the policy type associated with the load balancer.
	PolicyTypeName *string `type:"string"`

	metadataPolicyDescription `json:"-", xml:"-"`
}

type metadataPolicyDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// The PolicyTypeDescription data type.
type PolicyTypeDescription struct {
	// A human-readable description of the policy type.
	Description *string `type:"string"`

	// The description of the policy attributes associated with the load balancer
	// policies defined by the Elastic Load Balancing service.
	PolicyAttributeTypeDescriptions []*PolicyAttributeTypeDescription `type:"list"`

	// The name of the policy type.
	PolicyTypeName *string `type:"string"`

	metadataPolicyTypeDescription `json:"-", xml:"-"`
}

type metadataPolicyTypeDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the RegisterInstancesWithLoadBalancer action.
type RegisterInstancesWithLoadBalancerInput struct {
	// A list of instance IDs that should be registered with the load balancer.
	Instances []*Instance `type:"list" required:"true"`

	// The name associated with the load balancer. The name must be unique within
	// your set of load balancers.
	LoadBalancerName *string `type:"string" required:"true"`

	metadataRegisterInstancesWithLoadBalancerInput `json:"-", xml:"-"`
}

type metadataRegisterInstancesWithLoadBalancerInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the RegisterInstancesWithLoadBalancer action.
type RegisterInstancesWithLoadBalancerOutput struct {
	// An updated list of instances for the load balancer.
	Instances []*Instance `type:"list"`

	metadataRegisterInstancesWithLoadBalancerOutput `json:"-", xml:"-"`
}

type metadataRegisterInstancesWithLoadBalancerOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the RemoveTags action.
type RemoveTagsInput struct {
	// The name of the load balancer. You can specify a maximum of one load balancer
	// name.
	LoadBalancerNames []*string `type:"list" required:"true"`

	// A list of tag keys to remove.
	Tags []*TagKeyOnly `type:"list" required:"true"`

	metadataRemoveTagsInput `json:"-", xml:"-"`
}

type metadataRemoveTagsInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the RemoveTags action.
type RemoveTagsOutput struct {
	metadataRemoveTagsOutput `json:"-", xml:"-"`
}

type metadataRemoveTagsOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the SetLoadBalancerListenerSSLCertificate action.
type SetLoadBalancerListenerSSLCertificateInput struct {
	// The name of the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	// The port that uses the specified SSL certificate.
	LoadBalancerPort *int64 `type:"integer" required:"true"`

	// The Amazon Resource Number (ARN) of the SSL certificate chain to use. For
	// more information on SSL certificates, see  Managing Server Certificates (http://docs.aws.amazon.com/IAM/latest/UserGuide/ManagingServerCerts.html)
	// in the AWS Identity and Access Management User Guide.
	SSLCertificateID *string `locationName:"SSLCertificateId" type:"string" required:"true"`

	metadataSetLoadBalancerListenerSSLCertificateInput `json:"-", xml:"-"`
}

type metadataSetLoadBalancerListenerSSLCertificateInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the SetLoadBalancerListenerSSLCertificate action.
type SetLoadBalancerListenerSSLCertificateOutput struct {
	metadataSetLoadBalancerListenerSSLCertificateOutput `json:"-", xml:"-"`
}

type metadataSetLoadBalancerListenerSSLCertificateOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the SetLoadBalancerPoliciesForBackendServer action.
type SetLoadBalancerPoliciesForBackendServerInput struct {
	// The port number associated with the back-end server.
	InstancePort *int64 `type:"integer" required:"true"`

	// The mnemonic name associated with the load balancer. This name must be unique
	// within the set of your load balancers.
	LoadBalancerName *string `type:"string" required:"true"`

	// List of policy names to be set. If the list is empty, then all current polices
	// are removed from the back-end server.
	PolicyNames []*string `type:"list" required:"true"`

	metadataSetLoadBalancerPoliciesForBackendServerInput `json:"-", xml:"-"`
}

type metadataSetLoadBalancerPoliciesForBackendServerInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the SetLoadBalancerPoliciesForBackendServer action.
type SetLoadBalancerPoliciesForBackendServerOutput struct {
	metadataSetLoadBalancerPoliciesForBackendServerOutput `json:"-", xml:"-"`
}

type metadataSetLoadBalancerPoliciesForBackendServerOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The input for the SetLoadBalancerPoliciesOfListener action.
type SetLoadBalancerPoliciesOfListenerInput struct {
	// The name of the load balancer.
	LoadBalancerName *string `type:"string" required:"true"`

	// The external port of the load balancer to associate the policy.
	LoadBalancerPort *int64 `type:"integer" required:"true"`

	// List of policies to be associated with the listener. If the list is empty,
	// the current policy is removed from the listener.
	PolicyNames []*string `type:"list" required:"true"`

	metadataSetLoadBalancerPoliciesOfListenerInput `json:"-", xml:"-"`
}

type metadataSetLoadBalancerPoliciesOfListenerInput struct {
	SDKShapeTraits bool `type:"structure"`
}

// The output for the SetLoadBalancerPoliciesOfListener action.
type SetLoadBalancerPoliciesOfListenerOutput struct {
	metadataSetLoadBalancerPoliciesOfListenerOutput `json:"-", xml:"-"`
}

type metadataSetLoadBalancerPoliciesOfListenerOutput struct {
	SDKShapeTraits bool `type:"structure"`
}

// This data type is used as a response element in the DescribeLoadBalancers
// action. For information about Elastic Load Balancing security groups, go
// to Using Security Groups With Elastic Load Balancing (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/elb-security-features.html#using-elb-security-groups)
// in the Elastic Load Balancing Developer Guide.
type SourceSecurityGroup struct {
	// Name of the source security group. Use this value for the --source-group
	// parameter of the ec2-authorize command in the Amazon EC2 command line tool.
	GroupName *string `type:"string"`

	// Owner of the source security group. Use this value for the --source-group-user
	// parameter of the ec2-authorize command in the Amazon EC2 command line tool.
	OwnerAlias *string `type:"string"`

	metadataSourceSecurityGroup `json:"-", xml:"-"`
}

type metadataSourceSecurityGroup struct {
	SDKShapeTraits bool `type:"structure"`
}

// Metadata assigned to a load balancer consisting of key-value pair.
//
// For more information, see Tagging (http://docs.aws.amazon.com/ElasticLoadBalancing/latest/DeveloperGuide/TerminologyandKeyConcepts.html#tagging-elb)
// in the Elastic Load Balancing Developer Guide.
type Tag struct {
	// The key of the tag.
	Key *string `type:"string" required:"true"`

	// The value of the tag.
	Value *string `type:"string"`

	metadataTag `json:"-", xml:"-"`
}

type metadataTag struct {
	SDKShapeTraits bool `type:"structure"`
}

// The descriptions of all the tags associated with load balancer.
type TagDescription struct {
	// The name of the load balancer.
	LoadBalancerName *string `type:"string"`

	// List of tags associated with the load balancer.
	Tags []*Tag `type:"list"`

	metadataTagDescription `json:"-", xml:"-"`
}

type metadataTagDescription struct {
	SDKShapeTraits bool `type:"structure"`
}

// The key of a tag to be removed.
type TagKeyOnly struct {
	// The name of the key.
	Key *string `type:"string"`

	metadataTagKeyOnly `json:"-", xml:"-"`
}

type metadataTagKeyOnly struct {
	SDKShapeTraits bool `type:"structure"`
}