// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

package ec2

import (
	"github.com/awslabs/aws-sdk-go/internal/waiter"
)

var waiterInstanceTerminated *waiter.Config

func (c *EC2) WaitUntilInstanceTerminated(input *DescribeInstancesInput) error {
	if waiterInstanceTerminated == nil {
		waiterInstanceTerminated = &waiter.Config{
			Operation:   "DescribeInstances",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "Reservations[].Instances[].State.Name",
					Expected: terminated,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "Reservations[].Instances[].State.Name",
					Expected: pending,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "Reservations[].Instances[].State.Name",
					Expected: stopping,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterInstanceTerminated,
	}
	return w.Wait()
}

var waiterSystemStatusOk *waiter.Config

func (c *EC2) WaitUntilSystemStatusOk(input *DescribeInstanceStatusInput) error {
	if waiterSystemStatusOk == nil {
		waiterSystemStatusOk = &waiter.Config{
			Operation:   "DescribeInstanceStatus",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "InstanceStatuses[].SystemStatus.Status",
					Expected: ok,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterSystemStatusOk,
	}
	return w.Wait()
}

var waiterBundleTaskComplete *waiter.Config

func (c *EC2) WaitUntilBundleTaskComplete(input *DescribeBundleTasksInput) error {
	if waiterBundleTaskComplete == nil {
		waiterBundleTaskComplete = &waiter.Config{
			Operation:   "DescribeBundleTasks",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "BundleTasks[].State",
					Expected: complete,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "BundleTasks[].State",
					Expected: failed,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterBundleTaskComplete,
	}
	return w.Wait()
}

var waiterInstanceStopped *waiter.Config

func (c *EC2) WaitUntilInstanceStopped(input *DescribeInstancesInput) error {
	if waiterInstanceStopped == nil {
		waiterInstanceStopped = &waiter.Config{
			Operation:   "DescribeInstances",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "Reservations[].Instances[].State.Name",
					Expected: stopped,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "Reservations[].Instances[].State.Name",
					Expected: pending,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "Reservations[].Instances[].State.Name",
					Expected: terminated,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterInstanceStopped,
	}
	return w.Wait()
}

var waiterPasswordDataAvailable *waiter.Config

func (c *EC2) WaitUntilPasswordDataAvailable(input *GetPasswordDataInput) error {
	if waiterPasswordDataAvailable == nil {
		waiterPasswordDataAvailable = &waiter.Config{
			Operation:   "GetPasswordData",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "path",
					Argument: "length(PasswordData) > `0`",
					Expected: true,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterPasswordDataAvailable,
	}
	return w.Wait()
}

var waiterSpotInstanceRequestFulfilled *waiter.Config

func (c *EC2) WaitUntilSpotInstanceRequestFulfilled(input *DescribeSpotInstanceRequestsInput) error {
	if waiterSpotInstanceRequestFulfilled == nil {
		waiterSpotInstanceRequestFulfilled = &waiter.Config{
			Operation:   "DescribeSpotInstanceRequests",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "SpotInstanceRequests[].Status.Code",
					Expected: fulfilled,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "SpotInstanceRequests[].Status.Code",
					Expected: schedule - expired,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "SpotInstanceRequests[].Status.Code",
					Expected: canceled - before - fulfillment,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "SpotInstanceRequests[].Status.Code",
					Expected: bad - parameters,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "SpotInstanceRequests[].Status.Code",
					Expected: system - error,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterSpotInstanceRequestFulfilled,
	}
	return w.Wait()
}

var waiterVPNConnectionAvailable *waiter.Config

func (c *EC2) WaitUntilVPNConnectionAvailable(input *DescribeVPNConnectionsInput) error {
	if waiterVPNConnectionAvailable == nil {
		waiterVPNConnectionAvailable = &waiter.Config{
			Operation:   "DescribeVPNConnections",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "VpnConnections[].State",
					Expected: available,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "VpnConnections[].State",
					Expected: deleting,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "VpnConnections[].State",
					Expected: deleted,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterVPNConnectionAvailable,
	}
	return w.Wait()
}

var waiterVPNConnectionDeleted *waiter.Config

func (c *EC2) WaitUntilVPNConnectionDeleted(input *DescribeVPNConnectionsInput) error {
	if waiterVPNConnectionDeleted == nil {
		waiterVPNConnectionDeleted = &waiter.Config{
			Operation:   "DescribeVPNConnections",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "VpnConnections[].State",
					Expected: deleted,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "VpnConnections[].State",
					Expected: pending,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterVPNConnectionDeleted,
	}
	return w.Wait()
}

var waiterConversionTaskCompleted *waiter.Config

func (c *EC2) WaitUntilConversionTaskCompleted(input *DescribeConversionTasksInput) error {
	if waiterConversionTaskCompleted == nil {
		waiterConversionTaskCompleted = &waiter.Config{
			Operation:   "DescribeConversionTasks",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "ConversionTasks[].State",
					Expected: completed,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "ConversionTasks[].State",
					Expected: cancelled,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "ConversionTasks[].State",
					Expected: cancelling,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterConversionTaskCompleted,
	}
	return w.Wait()
}

var waiterExportTaskCompleted *waiter.Config

func (c *EC2) WaitUntilExportTaskCompleted(input *DescribeExportTasksInput) error {
	if waiterExportTaskCompleted == nil {
		waiterExportTaskCompleted = &waiter.Config{
			Operation:   "DescribeExportTasks",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "ExportTasks[].State",
					Expected: completed,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterExportTaskCompleted,
	}
	return w.Wait()
}

var waiterVolumeAvailable *waiter.Config

func (c *EC2) WaitUntilVolumeAvailable(input *DescribeVolumesInput) error {
	if waiterVolumeAvailable == nil {
		waiterVolumeAvailable = &waiter.Config{
			Operation:   "DescribeVolumes",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "Volumes[].State",
					Expected: available,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "Volumes[].State",
					Expected: deleted,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterVolumeAvailable,
	}
	return w.Wait()
}

var waiterVolumeDeleted *waiter.Config

func (c *EC2) WaitUntilVolumeDeleted(input *DescribeVolumesInput) error {
	if waiterVolumeDeleted == nil {
		waiterVolumeDeleted = &waiter.Config{
			Operation:   "DescribeVolumes",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "Volumes[].State",
					Expected: deleted,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterVolumeDeleted,
	}
	return w.Wait()
}

var waiterConversionTaskDeleted *waiter.Config

func (c *EC2) WaitUntilConversionTaskDeleted(input *DescribeConversionTasksInput) error {
	if waiterConversionTaskDeleted == nil {
		waiterConversionTaskDeleted = &waiter.Config{
			Operation:   "DescribeConversionTasks",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "ConversionTasks[].State",
					Expected: deleted,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterConversionTaskDeleted,
	}
	return w.Wait()
}

var waiterSnapshotCompleted *waiter.Config

func (c *EC2) WaitUntilSnapshotCompleted(input *DescribeSnapshotsInput) error {
	if waiterSnapshotCompleted == nil {
		waiterSnapshotCompleted = &waiter.Config{
			Operation:   "DescribeSnapshots",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "Snapshots[].State",
					Expected: completed,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterSnapshotCompleted,
	}
	return w.Wait()
}

var waiterExportTaskCancelled *waiter.Config

func (c *EC2) WaitUntilExportTaskCancelled(input *DescribeExportTasksInput) error {
	if waiterExportTaskCancelled == nil {
		waiterExportTaskCancelled = &waiter.Config{
			Operation:   "DescribeExportTasks",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "ExportTasks[].State",
					Expected: cancelled,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterExportTaskCancelled,
	}
	return w.Wait()
}

var waiterImageAvailable *waiter.Config

func (c *EC2) WaitUntilImageAvailable(input *DescribeImagesInput) error {
	if waiterImageAvailable == nil {
		waiterImageAvailable = &waiter.Config{
			Operation:   "DescribeImages",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "Images[].State",
					Expected: available,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "Images[].State",
					Expected: failed,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterImageAvailable,
	}
	return w.Wait()
}

var waiterInstanceRunning *waiter.Config

func (c *EC2) WaitUntilInstanceRunning(input *DescribeInstancesInput) error {
	if waiterInstanceRunning == nil {
		waiterInstanceRunning = &waiter.Config{
			Operation:   "DescribeInstances",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "Reservations[].Instances[].State.Name",
					Expected: running,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "Reservations[].Instances[].State.Name",
					Expected: shutting - down,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "Reservations[].Instances[].State.Name",
					Expected: terminated,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "Reservations[].Instances[].State.Name",
					Expected: stopping,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterInstanceRunning,
	}
	return w.Wait()
}

var waiterInstanceStatusOk *waiter.Config

func (c *EC2) WaitUntilInstanceStatusOk(input *DescribeInstanceStatusInput) error {
	if waiterInstanceStatusOk == nil {
		waiterInstanceStatusOk = &waiter.Config{
			Operation:   "DescribeInstanceStatus",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "InstanceStatuses[].InstanceStatus.Status",
					Expected: ok,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterInstanceStatusOk,
	}
	return w.Wait()
}

var waiterSubnetAvailable *waiter.Config

func (c *EC2) WaitUntilSubnetAvailable(input *DescribeSubnetsInput) error {
	if waiterSubnetAvailable == nil {
		waiterSubnetAvailable = &waiter.Config{
			Operation:   "DescribeSubnets",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "Subnets[].State",
					Expected: available,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterSubnetAvailable,
	}
	return w.Wait()
}

var waiterVolumeInUse *waiter.Config

func (c *EC2) WaitUntilVolumeInUse(input *DescribeVolumesInput) error {
	if waiterVolumeInUse == nil {
		waiterVolumeInUse = &waiter.Config{
			Operation:   "DescribeVolumes",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "Volumes[].State",
					Expected: in - use,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "Volumes[].State",
					Expected: deleted,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterVolumeInUse,
	}
	return w.Wait()
}

var waiterConversionTaskCancelled *waiter.Config

func (c *EC2) WaitUntilConversionTaskCancelled(input *DescribeConversionTasksInput) error {
	if waiterConversionTaskCancelled == nil {
		waiterConversionTaskCancelled = &waiter.Config{
			Operation:   "DescribeConversionTasks",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "ConversionTasks[].State",
					Expected: cancelled,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterConversionTaskCancelled,
	}
	return w.Wait()
}

var waiterCustomerGatewayAvailable *waiter.Config

func (c *EC2) WaitUntilCustomerGatewayAvailable(input *DescribeCustomerGatewaysInput) error {
	if waiterCustomerGatewayAvailable == nil {
		waiterCustomerGatewayAvailable = &waiter.Config{
			Operation:   "DescribeCustomerGateways",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "CustomerGateways[].State",
					Expected: available,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "CustomerGateways[].State",
					Expected: deleted,
				},
				{
					State:    "failure",
					Matcher:  "pathAny",
					Argument: "CustomerGateways[].State",
					Expected: deleting,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterCustomerGatewayAvailable,
	}
	return w.Wait()
}

var waiterVPCAvailable *waiter.Config

func (c *EC2) WaitUntilVPCAvailable(input *DescribeVPCsInput) error {
	if waiterVPCAvailable == nil {
		waiterVPCAvailable = &waiter.Config{
			Operation:   "DescribeVPCs",
			Delay:       15,
			MaxAttempts: 40,
			Acceptors: []waiter.WaitAcceptor{
				{
					State:    "success",
					Matcher:  "pathAll",
					Argument: "Vpcs[].State",
					Expected: available,
				},
			},
		}
	}

	w := waiter.Waiter{
		Client: c,
		Input:  input,
		Config: waiterVPCAvailable,
	}
	return w.Wait()
}
