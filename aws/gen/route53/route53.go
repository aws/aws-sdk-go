// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package route53 provides a client for Amazon Route 53.
package route53

import (
	"encoding/xml"
	"net/http"
	"time"

	"github.com/stripe/aws-go/aws"
	"github.com/stripe/aws-go/aws/gen/endpoints"
)

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"net/url"
	"strconv"
	"strings"
)

// Route53 is a client for Amazon Route 53.
type Route53 struct {
	client *aws.RestClient
}

// New returns a new Route53 client.
func New(creds aws.Credentials, region string, client *http.Client) *Route53 {
	if client == nil {
		client = http.DefaultClient
	}

	service := "route53"
	endpoint, service, region := endpoints.Lookup("route53", region)

	return &Route53{
		client: &aws.RestClient{
			Context: aws.Context{
				Credentials: creds,
				Service:     service,
				Region:      region,
			},
			Client:     client,
			Endpoint:   endpoint,
			APIVersion: "2013-04-01",
		},
	}
}

// AssociateVPCWithHostedZone this action associates a VPC with an hosted
// zone. To associate a VPC with an hosted zone, send a request to the
// 2013-04-01/hostedzone/ hosted zone /associatevpc resource. The request
// body must include an XML document with a
// AssociateVPCWithHostedZoneRequest element. The response returns the
// AssociateVPCWithHostedZoneResponse element that contains ChangeInfo for
// you to track the progress of the AssociateVPCWithHostedZoneRequest you
// made. See GetChange operation for how to track the progress of your
// change.
func (c *Route53) AssociateVPCWithHostedZone(req *AssociateVPCWithHostedZoneRequest) (resp *AssociateVPCWithHostedZoneResponse, err error) {
	resp = &AssociateVPCWithHostedZoneResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/hostedzone/{Id}/associatevpc"

	if req.HostedZoneID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.HostedZoneID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.HostedZoneID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// ChangeResourceRecordSets use this action to create or change your
// authoritative DNS information. To use this action, send a request to the
// 2013-04-01/hostedzone/ hosted Zone /rrset resource. The request body
// must include an XML document with a ChangeResourceRecordSetsRequest
// element. Changes are a list of change items and are considered
// transactional. For more information on transactional changes, also known
// as change batches, see Creating, Changing, and Deleting Resource Record
// Sets Using the Route 53 in the Amazon Route 53 Developer Guide Due to
// the nature of transactional changes, you cannot delete the same resource
// record set more than once in a single change batch. If you attempt to
// delete the same change batch more than once, Route 53 returns an
// InvalidChangeBatch error. In response to a ChangeResourceRecordSets
// request, your DNS data is changed on all Route 53 DNS servers.
// Initially, the status of a change is . This means the change has not yet
// propagated to all the authoritative Route 53 DNS servers. When the
// change is propagated to all hosts, the change returns a status of Note
// the following limitations on a ChangeResourceRecordSets request: - A
// request cannot contain more than 100 Change elements. - A request cannot
// contain more than 1000 ResourceRecord elements. The sum of the number of
// characters (including spaces) in all Value elements in a request cannot
// exceed 32,000 characters.
func (c *Route53) ChangeResourceRecordSets(req *ChangeResourceRecordSetsRequest) (resp *ChangeResourceRecordSetsResponse, err error) {
	resp = &ChangeResourceRecordSetsResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/hostedzone/{Id}/rrset/"

	if req.HostedZoneID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.HostedZoneID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.HostedZoneID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// ChangeTagsForResource <nil>
func (c *Route53) ChangeTagsForResource(req *ChangeTagsForResourceRequest) (resp *ChangeTagsForResourceResponse, err error) {
	resp = &ChangeTagsForResourceResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/tags/{ResourceType}/{ResourceId}"

	if req.ResourceID != nil {
		uri = strings.Replace(uri, "{"+"ResourceId"+"}", *req.ResourceID, -1)
		uri = strings.Replace(uri, "{"+"ResourceId+"+"}", *req.ResourceID, -1)
	}

	if req.ResourceType != nil {
		uri = strings.Replace(uri, "{"+"ResourceType"+"}", *req.ResourceType, -1)
		uri = strings.Replace(uri, "{"+"ResourceType+"+"}", *req.ResourceType, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// CreateHealthCheck this action creates a new health check. To create a
// new health check, send a request to the 2013-04-01/healthcheck resource.
// The request body must include an XML document with a
// CreateHealthCheckRequest element. The response returns the
// CreateHealthCheckResponse element that contains metadata about the
// health check.
func (c *Route53) CreateHealthCheck(req *CreateHealthCheckRequest) (resp *CreateHealthCheckResponse, err error) {
	resp = &CreateHealthCheckResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/healthcheck"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// CreateHostedZone this action creates a new hosted zone. To create a new
// hosted zone, send a request to the 2013-04-01/hostedzone resource. The
// request body must include an XML document with a CreateHostedZoneRequest
// element. The response returns the CreateHostedZoneResponse element that
// contains metadata about the hosted zone. Route 53 automatically creates
// a default SOA record and four NS records for the zone. The NS records in
// the hosted zone are the name servers you give your registrar to delegate
// your domain to. For more information about SOA and NS records, see NS
// and SOA Records that Route 53 Creates for a Hosted Zone in the Amazon
// Route 53 Developer Guide When you create a zone, its initial status is .
// This means that it is not yet available on all DNS servers. The status
// of the zone changes to when the NS and SOA records are available on all
// Route 53 DNS servers. When trying to create a hosted zone using a
// reusable delegation set, you could specify an optional DelegationSetId,
// and Route53 would assign those 4 NS records for the zone, instead of
// alloting a new one.
func (c *Route53) CreateHostedZone(req *CreateHostedZoneRequest) (resp *CreateHostedZoneResponse, err error) {
	resp = &CreateHostedZoneResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/hostedzone"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// CreateReusableDelegationSet this action creates a reusable
// delegationSet. To create a new reusable delegationSet, send a request to
// the 2013-04-01/delegationset resource. The request body must include an
// XML document with a CreateReusableDelegationSetRequest element. The
// response returns the CreateReusableDelegationSetResponse element that
// contains metadata about the delegationSet. If the optional parameter
// HostedZoneId is specified, it marks the delegationSet associated with
// that particular hosted zone as reusable.
func (c *Route53) CreateReusableDelegationSet(req *CreateReusableDelegationSetRequest) (resp *CreateReusableDelegationSetResponse, err error) {
	resp = &CreateReusableDelegationSetResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/delegationset"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// DeleteHealthCheck this action deletes a health check. To delete a health
// check, send a request to the 2013-04-01/healthcheck/ health check
// resource. You can delete a health check only if there are no resource
// record sets associated with this health check. If resource record sets
// are associated with this health check, you must disassociate them before
// you can delete your health check. If you try to delete a health check
// that is associated with resource record sets, Route 53 will deny your
// request with a HealthCheckInUse error. For information about
// disassociating the records from your health check, see
// ChangeResourceRecordSets
func (c *Route53) DeleteHealthCheck(req *DeleteHealthCheckRequest) (resp *DeleteHealthCheckResponse, err error) {
	resp = &DeleteHealthCheckResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/healthcheck/{HealthCheckId}"

	if req.HealthCheckID != nil {
		uri = strings.Replace(uri, "{"+"HealthCheckId"+"}", *req.HealthCheckID, -1)
		uri = strings.Replace(uri, "{"+"HealthCheckId+"+"}", *req.HealthCheckID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// DeleteHostedZone this action deletes a hosted zone. To delete a hosted
// zone, send a request to the 2013-04-01/hostedzone/ hosted zone resource.
// For more information about deleting a hosted zone, see Deleting a Hosted
// Zone in the Amazon Route 53 Developer Guide You can delete a hosted zone
// only if there are no resource record sets other than the default SOA
// record and NS resource record sets. If your hosted zone contains other
// resource record sets, you must delete them before you can delete your
// hosted zone. If you try to delete a hosted zone that contains other
// resource record sets, Route 53 will deny your request with a
// HostedZoneNotEmpty error. For information about deleting records from
// your hosted zone, see ChangeResourceRecordSets
func (c *Route53) DeleteHostedZone(req *DeleteHostedZoneRequest) (resp *DeleteHostedZoneResponse, err error) {
	resp = &DeleteHostedZoneResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/hostedzone/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// DeleteReusableDelegationSet this action deletes a reusable delegation
// set. To delete a reusable delegation set, send a request to the
// 2013-04-01/delegationset/ delegation set resource. You can delete a
// reusable delegation set only if there are no associated hosted zones. If
// your reusable delegation set contains associated hosted zones, you must
// delete them before you can delete your reusable delegation set. If you
// try to delete a reusable delegation set that contains associated hosted
// zones, Route 53 will deny your request with a DelegationSetInUse error.
func (c *Route53) DeleteReusableDelegationSet(req *DeleteReusableDelegationSetRequest) (resp *DeleteReusableDelegationSetResponse, err error) {
	resp = &DeleteReusableDelegationSetResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/delegationset/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// DisassociateVPCFromHostedZone this action disassociates a VPC from an
// hosted zone. To disassociate a VPC to a hosted zone, send a request to
// the 2013-04-01/hostedzone/ hosted zone /disassociatevpc resource. The
// request body must include an XML document with a
// DisassociateVPCFromHostedZoneRequest element. The response returns the
// DisassociateVPCFromHostedZoneResponse element that contains ChangeInfo
// for you to track the progress of the
// DisassociateVPCFromHostedZoneRequest you made. See GetChange operation
// for how to track the progress of your change.
func (c *Route53) DisassociateVPCFromHostedZone(req *DisassociateVPCFromHostedZoneRequest) (resp *DisassociateVPCFromHostedZoneResponse, err error) {
	resp = &DisassociateVPCFromHostedZoneResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/hostedzone/{Id}/disassociatevpc"

	if req.HostedZoneID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.HostedZoneID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.HostedZoneID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// GetChange this action returns the current status of a change batch
// request. The status is one of the following values: - indicates that the
// changes in this request have not replicated to all Route 53 DNS servers.
// This is the initial status of all change batch requests. - indicates
// that the changes have replicated to all Amazon Route 53 DNS servers.
func (c *Route53) GetChange(req *GetChangeRequest) (resp *GetChangeResponse, err error) {
	resp = &GetChangeResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/change/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// GetCheckerIPRanges to retrieve a list of the IP ranges used by Amazon
// Route 53 health checkers to check the health of your resources, send a
// request to the 2013-04-01/checkeripranges resource. You can use these IP
// addresses to configure router and firewall rules to allow health
// checkers to check the health of your resources.
func (c *Route53) GetCheckerIPRanges(req *GetCheckerIPRangesRequest) (resp *GetCheckerIPRangesResponse, err error) {
	resp = &GetCheckerIPRangesResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/checkeripranges"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// GetGeoLocation to retrieve a single geo location, send a request to the
// 2013-04-01/geolocation resource with one of these options: continentcode
// | countrycode | countrycode and subdivisioncode.
func (c *Route53) GetGeoLocation(req *GetGeoLocationRequest) (resp *GetGeoLocationResponse, err error) {
	resp = &GetGeoLocationResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/geolocation"

	q := url.Values{}

	if req.ContinentCode != nil {
		q.Set("continentcode", *req.ContinentCode)
	}

	if req.CountryCode != nil {
		q.Set("countrycode", *req.CountryCode)
	}

	if req.SubdivisionCode != nil {
		q.Set("subdivisioncode", *req.SubdivisionCode)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// GetHealthCheck to retrieve the health check, send a request to the
// 2013-04-01/healthcheck/ health check resource.
func (c *Route53) GetHealthCheck(req *GetHealthCheckRequest) (resp *GetHealthCheckResponse, err error) {
	resp = &GetHealthCheckResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/healthcheck/{HealthCheckId}"

	if req.HealthCheckID != nil {
		uri = strings.Replace(uri, "{"+"HealthCheckId"+"}", *req.HealthCheckID, -1)
		uri = strings.Replace(uri, "{"+"HealthCheckId+"+"}", *req.HealthCheckID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// GetHealthCheckCount to retrieve a count of all your health checks, send
// a request to the 2013-04-01/healthcheckcount resource.
func (c *Route53) GetHealthCheckCount(req *GetHealthCheckCountRequest) (resp *GetHealthCheckCountResponse, err error) {
	resp = &GetHealthCheckCountResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/healthcheckcount"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// GetHealthCheckLastFailureReason if you want to learn why a health check
// is currently failing or why it failed most recently (if at all), you can
// get the failure reason for the most recent failure. Send a request to
// the 2013-04-01/healthcheck/ health check /lastfailurereason resource.
func (c *Route53) GetHealthCheckLastFailureReason(req *GetHealthCheckLastFailureReasonRequest) (resp *GetHealthCheckLastFailureReasonResponse, err error) {
	resp = &GetHealthCheckLastFailureReasonResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/healthcheck/{HealthCheckId}/lastfailurereason"

	if req.HealthCheckID != nil {
		uri = strings.Replace(uri, "{"+"HealthCheckId"+"}", *req.HealthCheckID, -1)
		uri = strings.Replace(uri, "{"+"HealthCheckId+"+"}", *req.HealthCheckID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// GetHealthCheckStatus to retrieve the health check status, send a request
// to the 2013-04-01/healthcheck/ health check /status resource. You can
// use this call to get a health check's current status.
func (c *Route53) GetHealthCheckStatus(req *GetHealthCheckStatusRequest) (resp *GetHealthCheckStatusResponse, err error) {
	resp = &GetHealthCheckStatusResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/healthcheck/{HealthCheckId}/status"

	if req.HealthCheckID != nil {
		uri = strings.Replace(uri, "{"+"HealthCheckId"+"}", *req.HealthCheckID, -1)
		uri = strings.Replace(uri, "{"+"HealthCheckId+"+"}", *req.HealthCheckID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// GetHostedZone to retrieve the delegation set for a hosted zone, send a
// request to the 2013-04-01/hostedzone/ hosted zone resource. The
// delegation set is the four Route 53 name servers that were assigned to
// the hosted zone when you created it.
func (c *Route53) GetHostedZone(req *GetHostedZoneRequest) (resp *GetHostedZoneResponse, err error) {
	resp = &GetHostedZoneResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/hostedzone/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// GetReusableDelegationSet to retrieve the reusable delegation set, send a
// request to the 2013-04-01/delegationset/ delegation set resource.
func (c *Route53) GetReusableDelegationSet(req *GetReusableDelegationSetRequest) (resp *GetReusableDelegationSetResponse, err error) {
	resp = &GetReusableDelegationSetResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/delegationset/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// ListGeoLocations to retrieve a list of supported geo locations, send a
// request to the 2013-04-01/geolocations resource. The response to this
// request includes a GeoLocationDetailsList element with zero, one, or
// multiple GeoLocationDetails child elements. The list is sorted by
// country code, and then subdivision code, followed by continents at the
// end of the list. By default, the list of geo locations is displayed on a
// single page. You can control the length of the page that is displayed by
// using the MaxItems parameter. If the list is truncated, IsTruncated will
// be set to true and a combination of NextContinentCode, NextCountryCode,
// NextSubdivisionCode will be populated. You can pass these as parameters
// to StartContinentCode, StartCountryCode, StartSubdivisionCode to control
// the geo location that the list begins with.
func (c *Route53) ListGeoLocations(req *ListGeoLocationsRequest) (resp *ListGeoLocationsResponse, err error) {
	resp = &ListGeoLocationsResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/geolocations"

	q := url.Values{}

	if req.MaxItems != nil {
		q.Set("maxitems", *req.MaxItems)
	}

	if req.StartContinentCode != nil {
		q.Set("startcontinentcode", *req.StartContinentCode)
	}

	if req.StartCountryCode != nil {
		q.Set("startcountrycode", *req.StartCountryCode)
	}

	if req.StartSubdivisionCode != nil {
		q.Set("startsubdivisioncode", *req.StartSubdivisionCode)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// ListHealthChecks to retrieve a list of your health checks, send a
// request to the 2013-04-01/healthcheck resource. The response to this
// request includes a HealthChecks element with zero, one, or multiple
// HealthCheck child elements. By default, the list of health checks is
// displayed on a single page. You can control the length of the page that
// is displayed by using the MaxItems parameter. You can use the Marker
// parameter to control the health check that the list begins with. Amazon
// Route 53 returns a maximum of 100 items. If you set MaxItems to a value
// greater than 100, Amazon Route 53 returns only the first 100.
func (c *Route53) ListHealthChecks(req *ListHealthChecksRequest) (resp *ListHealthChecksResponse, err error) {
	resp = &ListHealthChecksResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/healthcheck"

	q := url.Values{}

	if req.Marker != nil {
		q.Set("marker", *req.Marker)
	}

	if req.MaxItems != nil {
		q.Set("maxitems", *req.MaxItems)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// ListHostedZones to retrieve a list of your hosted zones, send a request
// to the 2013-04-01/hostedzone resource. The response to this request
// includes a HostedZones element with zero, one, or multiple HostedZone
// child elements. By default, the list of hosted zones is displayed on a
// single page. You can control the length of the page that is displayed by
// using the MaxItems parameter. You can use the Marker parameter to
// control the hosted zone that the list begins with. Amazon Route 53
// returns a maximum of 100 items. If you set MaxItems to a value greater
// than 100, Amazon Route 53 returns only the first 100.
func (c *Route53) ListHostedZones(req *ListHostedZonesRequest) (resp *ListHostedZonesResponse, err error) {
	resp = &ListHostedZonesResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/hostedzone"

	q := url.Values{}

	if req.DelegationSetID != nil {
		q.Set("delegationsetid", *req.DelegationSetID)
	}

	if req.Marker != nil {
		q.Set("marker", *req.Marker)
	}

	if req.MaxItems != nil {
		q.Set("maxitems", *req.MaxItems)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// ListResourceRecordSets imagine all the resource record sets in a zone
// listed out in front of you. Imagine them sorted lexicographically first
// by DNS name (with the labels reversed, like "com.amazon.www" for
// example), and secondarily, lexicographically by record type. This
// operation retrieves at most MaxItems resource record sets from this
// list, in order, starting at a position specified by the Name and Type
// arguments: If both Name and Type are omitted, this means start the
// results at the first in the HostedZone. If Name is specified but Type is
// omitted, this means start the results at the first in the list whose
// name is greater than or equal to Name. If both Name and Type are
// specified, this means start the results at the first in the list whose
// name is greater than or equal to Name and whose type is greater than or
// equal to Type. It is an error to specify the Type but not the Name. Use
// ListResourceRecordSets to retrieve a single known record set by
// specifying the record set's name and type, and setting MaxItems = 1 To
// retrieve all the records in a HostedZone, first pause any processes
// making calls to ChangeResourceRecordSets. Initially call
// ListResourceRecordSets without a Name and Type to get the first page of
// record sets. For subsequent calls, set Name and Type to the NextName and
// NextType values returned by the previous response. In the presence of
// concurrent ChangeResourceRecordSets calls, there is no consistency of
// results across calls to ListResourceRecordSets. The only way to get a
// consistent multi-page snapshot of all RRSETs in a zone is to stop making
// changes while pagination is in progress. However, the results from
// ListResourceRecordSets are consistent within a page. If MakeChange calls
// are taking place concurrently, the result of each one will either be
// completely visible in your results or not at all. You will not see
// partial changes, or changes that do not ultimately succeed. (This
// follows from the fact that MakeChange is atomic) The results from
// ListResourceRecordSets are strongly consistent with
// ChangeResourceRecordSets. To be precise, if a single process makes a
// call to ChangeResourceRecordSets and receives a successful response, the
// effects of that change will be visible in a subsequent call to
// ListResourceRecordSets by that process.
func (c *Route53) ListResourceRecordSets(req *ListResourceRecordSetsRequest) (resp *ListResourceRecordSetsResponse, err error) {
	resp = &ListResourceRecordSetsResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/hostedzone/{Id}/rrset"

	if req.HostedZoneID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.HostedZoneID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.HostedZoneID, -1)
	}

	q := url.Values{}

	if req.MaxItems != nil {
		q.Set("maxitems", *req.MaxItems)
	}

	if req.StartRecordIdentifier != nil {
		q.Set("identifier", *req.StartRecordIdentifier)
	}

	if req.StartRecordName != nil {
		q.Set("name", *req.StartRecordName)
	}

	if req.StartRecordType != nil {
		q.Set("type", *req.StartRecordType)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// ListReusableDelegationSets to retrieve a list of your reusable
// delegation sets, send a request to the 2013-04-01/delegationset
// resource. The response to this request includes a DelegationSets element
// with zero, one, or multiple DelegationSet child elements. By default,
// the list of delegation sets is displayed on a single page. You can
// control the length of the page that is displayed by using the MaxItems
// parameter. You can use the Marker parameter to control the delegation
// set that the list begins with. Amazon Route 53 returns a maximum of 100
// items. If you set MaxItems to a value greater than 100, Amazon Route 53
// returns only the first 100.
func (c *Route53) ListReusableDelegationSets(req *ListReusableDelegationSetsRequest) (resp *ListReusableDelegationSetsResponse, err error) {
	resp = &ListReusableDelegationSetsResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/delegationset"

	q := url.Values{}

	if req.Marker != nil {
		q.Set("marker", *req.Marker)
	}

	if req.MaxItems != nil {
		q.Set("maxitems", *req.MaxItems)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// ListTagsForResource <nil>
func (c *Route53) ListTagsForResource(req *ListTagsForResourceRequest) (resp *ListTagsForResourceResponse, err error) {
	resp = &ListTagsForResourceResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/tags/{ResourceType}/{ResourceId}"

	if req.ResourceID != nil {
		uri = strings.Replace(uri, "{"+"ResourceId"+"}", *req.ResourceID, -1)
		uri = strings.Replace(uri, "{"+"ResourceId+"+"}", *req.ResourceID, -1)
	}

	if req.ResourceType != nil {
		uri = strings.Replace(uri, "{"+"ResourceType"+"}", *req.ResourceType, -1)
		uri = strings.Replace(uri, "{"+"ResourceType+"+"}", *req.ResourceType, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// ListTagsForResources <nil>
func (c *Route53) ListTagsForResources(req *ListTagsForResourcesRequest) (resp *ListTagsForResourcesResponse, err error) {
	resp = &ListTagsForResourcesResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/tags/{ResourceType}"

	if req.ResourceType != nil {
		uri = strings.Replace(uri, "{"+"ResourceType"+"}", *req.ResourceType, -1)
		uri = strings.Replace(uri, "{"+"ResourceType+"+"}", *req.ResourceType, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// UpdateHealthCheck this action updates an existing health check. To
// update a health check, send a request to the 2013-04-01/healthcheck/
// health check resource. The request body must include an XML document
// with an UpdateHealthCheckRequest element. The response returns an
// UpdateHealthCheckResponse element, which contains metadata about the
// health check.
func (c *Route53) UpdateHealthCheck(req *UpdateHealthCheckRequest) (resp *UpdateHealthCheckResponse, err error) {
	resp = &UpdateHealthCheckResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/healthcheck/{HealthCheckId}"

	if req.HealthCheckID != nil {
		uri = strings.Replace(uri, "{"+"HealthCheckId"+"}", *req.HealthCheckID, -1)
		uri = strings.Replace(uri, "{"+"HealthCheckId+"+"}", *req.HealthCheckID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// UpdateHostedZoneComment to update the hosted zone comment, send a
// request to the 2013-04-01/hostedzone/ hosted zone resource. The request
// body must include an XML document with a UpdateHostedZoneCommentRequest
// element. The response to this request includes the modified HostedZone
// element. The comment can have a maximum length of 256 characters.
func (c *Route53) UpdateHostedZoneComment(req *UpdateHostedZoneCommentRequest) (resp *UpdateHostedZoneCommentResponse, err error) {
	resp = &UpdateHostedZoneCommentResponse{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2013-04-01/hostedzone/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if httpResp.StatusCode != 204 {
		err = xml.NewDecoder(httpResp.Body).Decode(resp)
	}

	return
}

// AliasTarget is undocumented.
type AliasTarget struct {
	DNSName              aws.StringValue  `xml:"DNSName"`
	EvaluateTargetHealth aws.BooleanValue `xml:"EvaluateTargetHealth"`
	HostedZoneID         aws.StringValue  `xml:"HostedZoneId"`
}

// AssociateVPCWithHostedZoneRequest is undocumented.
type AssociateVPCWithHostedZoneRequest struct {
	Comment      aws.StringValue `xml:"Comment"`
	HostedZoneID aws.StringValue `xml:"Id"`
	VPC          *VPC            `xml:"VPC"`
}

// AssociateVPCWithHostedZoneResponse is undocumented.
type AssociateVPCWithHostedZoneResponse struct {
	ChangeInfo *ChangeInfo `xml:"ChangeInfo"`
}

// Change is undocumented.
type Change struct {
	Action            aws.StringValue    `xml:"Action"`
	ResourceRecordSet *ResourceRecordSet `xml:"ResourceRecordSet"`
}

// ChangeBatch is undocumented.
type ChangeBatch struct {
	Changes []Change        `xml:"Changes"`
	Comment aws.StringValue `xml:"Comment"`
}

// ChangeInfo is undocumented.
type ChangeInfo struct {
	Comment     aws.StringValue `xml:"Comment"`
	ID          aws.StringValue `xml:"Id"`
	Status      aws.StringValue `xml:"Status"`
	SubmittedAt time.Time       `xml:"SubmittedAt"`
}

// ChangeResourceRecordSetsRequest is undocumented.
type ChangeResourceRecordSetsRequest struct {
	ChangeBatch  *ChangeBatch    `xml:"ChangeBatch"`
	HostedZoneID aws.StringValue `xml:"Id"`
}

// ChangeResourceRecordSetsResponse is undocumented.
type ChangeResourceRecordSetsResponse struct {
	ChangeInfo *ChangeInfo `xml:"ChangeInfo"`
}

// ChangeTagsForResourceRequest is undocumented.
type ChangeTagsForResourceRequest struct {
	AddTags       []Tag           `xml:"AddTags"`
	RemoveTagKeys []string        `xml:"RemoveTagKeys"`
	ResourceID    aws.StringValue `xml:"ResourceId"`
	ResourceType  aws.StringValue `xml:"ResourceType"`
}

// ChangeTagsForResourceResponse is undocumented.
type ChangeTagsForResourceResponse struct {
}

// CreateHealthCheckRequest is undocumented.
type CreateHealthCheckRequest struct {
	CallerReference   aws.StringValue    `xml:"CallerReference"`
	HealthCheckConfig *HealthCheckConfig `xml:"HealthCheckConfig"`
}

// CreateHealthCheckResponse is undocumented.
type CreateHealthCheckResponse struct {
	HealthCheck *HealthCheck    `xml:"HealthCheck"`
	Location    aws.StringValue `xml:"Location"`
}

// CreateHostedZoneRequest is undocumented.
type CreateHostedZoneRequest struct {
	CallerReference  aws.StringValue   `xml:"CallerReference"`
	DelegationSetID  aws.StringValue   `xml:"DelegationSetId"`
	HostedZoneConfig *HostedZoneConfig `xml:"HostedZoneConfig"`
	Name             aws.StringValue   `xml:"Name"`
	VPC              *VPC              `xml:"VPC"`
}

// CreateHostedZoneResponse is undocumented.
type CreateHostedZoneResponse struct {
	ChangeInfo    *ChangeInfo     `xml:"ChangeInfo"`
	DelegationSet *DelegationSet  `xml:"DelegationSet"`
	HostedZone    *HostedZone     `xml:"HostedZone"`
	Location      aws.StringValue `xml:"Location"`
	VPC           *VPC            `xml:"VPC"`
}

// CreateReusableDelegationSetRequest is undocumented.
type CreateReusableDelegationSetRequest struct {
	CallerReference aws.StringValue `xml:"CallerReference"`
	HostedZoneID    aws.StringValue `xml:"HostedZoneId"`
}

// CreateReusableDelegationSetResponse is undocumented.
type CreateReusableDelegationSetResponse struct {
	DelegationSet *DelegationSet  `xml:"DelegationSet"`
	Location      aws.StringValue `xml:"Location"`
}

// DelegationSet is undocumented.
type DelegationSet struct {
	CallerReference aws.StringValue `xml:"CallerReference"`
	ID              aws.StringValue `xml:"Id"`
	NameServers     []string        `xml:"NameServers"`
}

// DeleteHealthCheckRequest is undocumented.
type DeleteHealthCheckRequest struct {
	HealthCheckID aws.StringValue `xml:"HealthCheckId"`
}

// DeleteHealthCheckResponse is undocumented.
type DeleteHealthCheckResponse struct {
}

// DeleteHostedZoneRequest is undocumented.
type DeleteHostedZoneRequest struct {
	ID aws.StringValue `xml:"Id"`
}

// DeleteHostedZoneResponse is undocumented.
type DeleteHostedZoneResponse struct {
	ChangeInfo *ChangeInfo `xml:"ChangeInfo"`
}

// DeleteReusableDelegationSetRequest is undocumented.
type DeleteReusableDelegationSetRequest struct {
	ID aws.StringValue `xml:"Id"`
}

// DeleteReusableDelegationSetResponse is undocumented.
type DeleteReusableDelegationSetResponse struct {
}

// DisassociateVPCFromHostedZoneRequest is undocumented.
type DisassociateVPCFromHostedZoneRequest struct {
	Comment      aws.StringValue `xml:"Comment"`
	HostedZoneID aws.StringValue `xml:"Id"`
	VPC          *VPC            `xml:"VPC"`
}

// DisassociateVPCFromHostedZoneResponse is undocumented.
type DisassociateVPCFromHostedZoneResponse struct {
	ChangeInfo *ChangeInfo `xml:"ChangeInfo"`
}

// GeoLocation is undocumented.
type GeoLocation struct {
	ContinentCode   aws.StringValue `xml:"ContinentCode"`
	CountryCode     aws.StringValue `xml:"CountryCode"`
	SubdivisionCode aws.StringValue `xml:"SubdivisionCode"`
}

// GeoLocationDetails is undocumented.
type GeoLocationDetails struct {
	ContinentCode   aws.StringValue `xml:"ContinentCode"`
	ContinentName   aws.StringValue `xml:"ContinentName"`
	CountryCode     aws.StringValue `xml:"CountryCode"`
	CountryName     aws.StringValue `xml:"CountryName"`
	SubdivisionCode aws.StringValue `xml:"SubdivisionCode"`
	SubdivisionName aws.StringValue `xml:"SubdivisionName"`
}

// GetChangeRequest is undocumented.
type GetChangeRequest struct {
	ID aws.StringValue `xml:"Id"`
}

// GetChangeResponse is undocumented.
type GetChangeResponse struct {
	ChangeInfo *ChangeInfo `xml:"ChangeInfo"`
}

// GetCheckerIPRangesRequest is undocumented.
type GetCheckerIPRangesRequest struct {
}

// GetCheckerIPRangesResponse is undocumented.
type GetCheckerIPRangesResponse struct {
	CheckerIPRanges []string `xml:"CheckerIpRanges"`
}

// GetGeoLocationRequest is undocumented.
type GetGeoLocationRequest struct {
	ContinentCode   aws.StringValue `xml:"continentcode"`
	CountryCode     aws.StringValue `xml:"countrycode"`
	SubdivisionCode aws.StringValue `xml:"subdivisioncode"`
}

// GetGeoLocationResponse is undocumented.
type GetGeoLocationResponse struct {
	GeoLocationDetails *GeoLocationDetails `xml:"GeoLocationDetails"`
}

// GetHealthCheckCountRequest is undocumented.
type GetHealthCheckCountRequest struct {
}

// GetHealthCheckCountResponse is undocumented.
type GetHealthCheckCountResponse struct {
	HealthCheckCount aws.LongValue `xml:"HealthCheckCount"`
}

// GetHealthCheckLastFailureReasonRequest is undocumented.
type GetHealthCheckLastFailureReasonRequest struct {
	HealthCheckID aws.StringValue `xml:"HealthCheckId"`
}

// GetHealthCheckLastFailureReasonResponse is undocumented.
type GetHealthCheckLastFailureReasonResponse struct {
	HealthCheckObservations []HealthCheckObservation `xml:"HealthCheckObservations"`
}

// GetHealthCheckRequest is undocumented.
type GetHealthCheckRequest struct {
	HealthCheckID aws.StringValue `xml:"HealthCheckId"`
}

// GetHealthCheckResponse is undocumented.
type GetHealthCheckResponse struct {
	HealthCheck *HealthCheck `xml:"HealthCheck"`
}

// GetHealthCheckStatusRequest is undocumented.
type GetHealthCheckStatusRequest struct {
	HealthCheckID aws.StringValue `xml:"HealthCheckId"`
}

// GetHealthCheckStatusResponse is undocumented.
type GetHealthCheckStatusResponse struct {
	HealthCheckObservations []HealthCheckObservation `xml:"HealthCheckObservations"`
}

// GetHostedZoneRequest is undocumented.
type GetHostedZoneRequest struct {
	ID aws.StringValue `xml:"Id"`
}

// GetHostedZoneResponse is undocumented.
type GetHostedZoneResponse struct {
	DelegationSet *DelegationSet `xml:"DelegationSet"`
	HostedZone    *HostedZone    `xml:"HostedZone"`
	VPCs          []VPC          `xml:"VPCs"`
}

// GetReusableDelegationSetRequest is undocumented.
type GetReusableDelegationSetRequest struct {
	ID aws.StringValue `xml:"Id"`
}

// GetReusableDelegationSetResponse is undocumented.
type GetReusableDelegationSetResponse struct {
	DelegationSet *DelegationSet `xml:"DelegationSet"`
}

// HealthCheck is undocumented.
type HealthCheck struct {
	CallerReference    aws.StringValue    `xml:"CallerReference"`
	HealthCheckConfig  *HealthCheckConfig `xml:"HealthCheckConfig"`
	HealthCheckVersion aws.LongValue      `xml:"HealthCheckVersion"`
	ID                 aws.StringValue    `xml:"Id"`
}

// HealthCheckConfig is undocumented.
type HealthCheckConfig struct {
	FailureThreshold         aws.IntegerValue `xml:"FailureThreshold"`
	FullyQualifiedDomainName aws.StringValue  `xml:"FullyQualifiedDomainName"`
	IPAddress                aws.StringValue  `xml:"IPAddress"`
	Port                     aws.IntegerValue `xml:"Port"`
	RequestInterval          aws.IntegerValue `xml:"RequestInterval"`
	ResourcePath             aws.StringValue  `xml:"ResourcePath"`
	SearchString             aws.StringValue  `xml:"SearchString"`
	Type                     aws.StringValue  `xml:"Type"`
}

// HealthCheckObservation is undocumented.
type HealthCheckObservation struct {
	IPAddress    aws.StringValue `xml:"IPAddress"`
	StatusReport *StatusReport   `xml:"StatusReport"`
}

// HostedZone is undocumented.
type HostedZone struct {
	CallerReference        aws.StringValue   `xml:"CallerReference"`
	Config                 *HostedZoneConfig `xml:"Config"`
	ID                     aws.StringValue   `xml:"Id"`
	Name                   aws.StringValue   `xml:"Name"`
	ResourceRecordSetCount aws.LongValue     `xml:"ResourceRecordSetCount"`
}

// HostedZoneConfig is undocumented.
type HostedZoneConfig struct {
	Comment     aws.StringValue  `xml:"Comment"`
	PrivateZone aws.BooleanValue `xml:"PrivateZone"`
}

// ListGeoLocationsRequest is undocumented.
type ListGeoLocationsRequest struct {
	MaxItems             aws.StringValue `xml:"maxitems"`
	StartContinentCode   aws.StringValue `xml:"startcontinentcode"`
	StartCountryCode     aws.StringValue `xml:"startcountrycode"`
	StartSubdivisionCode aws.StringValue `xml:"startsubdivisioncode"`
}

// ListGeoLocationsResponse is undocumented.
type ListGeoLocationsResponse struct {
	GeoLocationDetailsList []GeoLocationDetails `xml:"GeoLocationDetailsList"`
	IsTruncated            aws.BooleanValue     `xml:"IsTruncated"`
	MaxItems               aws.StringValue      `xml:"MaxItems"`
	NextContinentCode      aws.StringValue      `xml:"NextContinentCode"`
	NextCountryCode        aws.StringValue      `xml:"NextCountryCode"`
	NextSubdivisionCode    aws.StringValue      `xml:"NextSubdivisionCode"`
}

// ListHealthChecksRequest is undocumented.
type ListHealthChecksRequest struct {
	Marker   aws.StringValue `xml:"marker"`
	MaxItems aws.StringValue `xml:"maxitems"`
}

// ListHealthChecksResponse is undocumented.
type ListHealthChecksResponse struct {
	HealthChecks []HealthCheck    `xml:"HealthChecks"`
	IsTruncated  aws.BooleanValue `xml:"IsTruncated"`
	Marker       aws.StringValue  `xml:"Marker"`
	MaxItems     aws.StringValue  `xml:"MaxItems"`
	NextMarker   aws.StringValue  `xml:"NextMarker"`
}

// ListHostedZonesRequest is undocumented.
type ListHostedZonesRequest struct {
	DelegationSetID aws.StringValue `xml:"delegationsetid"`
	Marker          aws.StringValue `xml:"marker"`
	MaxItems        aws.StringValue `xml:"maxitems"`
}

// ListHostedZonesResponse is undocumented.
type ListHostedZonesResponse struct {
	HostedZones []HostedZone     `xml:"HostedZones"`
	IsTruncated aws.BooleanValue `xml:"IsTruncated"`
	Marker      aws.StringValue  `xml:"Marker"`
	MaxItems    aws.StringValue  `xml:"MaxItems"`
	NextMarker  aws.StringValue  `xml:"NextMarker"`
}

// ListResourceRecordSetsRequest is undocumented.
type ListResourceRecordSetsRequest struct {
	HostedZoneID          aws.StringValue `xml:"Id"`
	MaxItems              aws.StringValue `xml:"maxitems"`
	StartRecordIdentifier aws.StringValue `xml:"identifier"`
	StartRecordName       aws.StringValue `xml:"name"`
	StartRecordType       aws.StringValue `xml:"type"`
}

// ListResourceRecordSetsResponse is undocumented.
type ListResourceRecordSetsResponse struct {
	IsTruncated          aws.BooleanValue    `xml:"IsTruncated"`
	MaxItems             aws.StringValue     `xml:"MaxItems"`
	NextRecordIdentifier aws.StringValue     `xml:"NextRecordIdentifier"`
	NextRecordName       aws.StringValue     `xml:"NextRecordName"`
	NextRecordType       aws.StringValue     `xml:"NextRecordType"`
	ResourceRecordSets   []ResourceRecordSet `xml:"ResourceRecordSets"`
}

// ListReusableDelegationSetsRequest is undocumented.
type ListReusableDelegationSetsRequest struct {
	Marker   aws.StringValue `xml:"marker"`
	MaxItems aws.StringValue `xml:"maxitems"`
}

// ListReusableDelegationSetsResponse is undocumented.
type ListReusableDelegationSetsResponse struct {
	DelegationSets []DelegationSet  `xml:"DelegationSets"`
	IsTruncated    aws.BooleanValue `xml:"IsTruncated"`
	Marker         aws.StringValue  `xml:"Marker"`
	MaxItems       aws.StringValue  `xml:"MaxItems"`
	NextMarker     aws.StringValue  `xml:"NextMarker"`
}

// ListTagsForResourceRequest is undocumented.
type ListTagsForResourceRequest struct {
	ResourceID   aws.StringValue `xml:"ResourceId"`
	ResourceType aws.StringValue `xml:"ResourceType"`
}

// ListTagsForResourceResponse is undocumented.
type ListTagsForResourceResponse struct {
	ResourceTagSet *ResourceTagSet `xml:"ResourceTagSet"`
}

// ListTagsForResourcesRequest is undocumented.
type ListTagsForResourcesRequest struct {
	ResourceIds  []string        `xml:"ResourceIds"`
	ResourceType aws.StringValue `xml:"ResourceType"`
}

// ListTagsForResourcesResponse is undocumented.
type ListTagsForResourcesResponse struct {
	ResourceTagSets []ResourceTagSet `xml:"ResourceTagSets"`
}

// ResourceRecord is undocumented.
type ResourceRecord struct {
	Value aws.StringValue `xml:"Value"`
}

// ResourceRecordSet is undocumented.
type ResourceRecordSet struct {
	AliasTarget     *AliasTarget     `xml:"AliasTarget"`
	Failover        aws.StringValue  `xml:"Failover"`
	GeoLocation     *GeoLocation     `xml:"GeoLocation"`
	HealthCheckID   aws.StringValue  `xml:"HealthCheckId"`
	Name            aws.StringValue  `xml:"Name"`
	Region          aws.StringValue  `xml:"Region"`
	ResourceRecords []ResourceRecord `xml:"ResourceRecords"`
	SetIdentifier   aws.StringValue  `xml:"SetIdentifier"`
	TTL             aws.LongValue    `xml:"TTL"`
	Type            aws.StringValue  `xml:"Type"`
	Weight          aws.LongValue    `xml:"Weight"`
}

// ResourceTagSet is undocumented.
type ResourceTagSet struct {
	ResourceID   aws.StringValue `xml:"ResourceId"`
	ResourceType aws.StringValue `xml:"ResourceType"`
	Tags         []Tag           `xml:"Tags"`
}

// StatusReport is undocumented.
type StatusReport struct {
	CheckedTime time.Time       `xml:"CheckedTime"`
	Status      aws.StringValue `xml:"Status"`
}

// Tag is undocumented.
type Tag struct {
	Key   aws.StringValue `xml:"Key"`
	Value aws.StringValue `xml:"Value"`
}

// UpdateHealthCheckRequest is undocumented.
type UpdateHealthCheckRequest struct {
	FailureThreshold         aws.IntegerValue `xml:"FailureThreshold"`
	FullyQualifiedDomainName aws.StringValue  `xml:"FullyQualifiedDomainName"`
	HealthCheckID            aws.StringValue  `xml:"HealthCheckId"`
	HealthCheckVersion       aws.LongValue    `xml:"HealthCheckVersion"`
	IPAddress                aws.StringValue  `xml:"IPAddress"`
	Port                     aws.IntegerValue `xml:"Port"`
	ResourcePath             aws.StringValue  `xml:"ResourcePath"`
	SearchString             aws.StringValue  `xml:"SearchString"`
}

// UpdateHealthCheckResponse is undocumented.
type UpdateHealthCheckResponse struct {
	HealthCheck *HealthCheck `xml:"HealthCheck"`
}

// UpdateHostedZoneCommentRequest is undocumented.
type UpdateHostedZoneCommentRequest struct {
	Comment aws.StringValue `xml:"Comment"`
	ID      aws.StringValue `xml:"Id"`
}

// UpdateHostedZoneCommentResponse is undocumented.
type UpdateHostedZoneCommentResponse struct {
	HostedZone *HostedZone `xml:"HostedZone"`
}

// VPC is undocumented.
type VPC struct {
	VPCID     aws.StringValue `xml:"VPCId"`
	VPCRegion aws.StringValue `xml:"VPCRegion"`
}

// avoid errors if the packages aren't referenced
var _ time.Time
var _ xml.Name

var _ bytes.Reader
var _ url.URL
var _ fmt.Stringer
var _ strings.Reader
var _ strconv.NumError
var _ = ioutil.Discard
