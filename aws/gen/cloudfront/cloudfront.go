// THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT.

// Package cloudfront provides a client for Amazon CloudFront.
package cloudfront

import (
	"encoding/xml"
	"net/http"
	"time"

	"github.com/stripe/aws-go/aws"
	"github.com/stripe/aws-go/aws/gen/endpoints"
)

import (
	"bytes"
	"fmt"
	"io"
	"io/ioutil"
	"net/url"
	"strconv"
	"strings"
)

// CloudFront is a client for Amazon CloudFront.
type CloudFront struct {
	client *aws.RestClient
}

// New returns a new CloudFront client.
func New(creds aws.Credentials, region string, client *http.Client) *CloudFront {
	if client == nil {
		client = http.DefaultClient
	}

	service := "cloudfront"
	endpoint, service, region := endpoints.Lookup("cloudfront", region)

	return &CloudFront{
		client: &aws.RestClient{
			Context: aws.Context{
				Credentials: creds,
				Service:     service,
				Region:      region,
			},
			Client:     client,
			Endpoint:   endpoint,
			APIVersion: "2014-10-21",
		},
	}
}

// CreateCloudFrontOriginAccessIdentity is undocumented.
func (c *CloudFront) CreateCloudFrontOriginAccessIdentity(req *CreateCloudFrontOriginAccessIdentityRequest) (resp *CreateCloudFrontOriginAccessIdentityResult, err error) {
	resp = &CreateCloudFrontOriginAccessIdentityResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.CloudFrontOriginAccessIdentityConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// CreateDistribution is undocumented.
func (c *CloudFront) CreateDistribution(req *CreateDistributionRequest) (resp *CreateDistributionResult, err error) {
	resp = &CreateDistributionResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.DistributionConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/distribution"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// CreateInvalidation is undocumented.
func (c *CloudFront) CreateInvalidation(req *CreateInvalidationRequest) (resp *CreateInvalidationResult, err error) {
	resp = &CreateInvalidationResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.InvalidationBatch)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/distribution/{DistributionId}/invalidation"

	if req.DistributionID != nil {
		uri = strings.Replace(uri, "{"+"DistributionId"+"}", *req.DistributionID, -1)
		uri = strings.Replace(uri, "{"+"DistributionId+"+"}", *req.DistributionID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// CreateStreamingDistribution is undocumented.
func (c *CloudFront) CreateStreamingDistribution(req *CreateStreamingDistributionRequest) (resp *CreateStreamingDistributionResult, err error) {
	resp = &CreateStreamingDistributionResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.StreamingDistributionConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution"

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("POST", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	if s := httpResp.Header.Get("Location"); s != "" {

		resp.Location = &s

	}

	return
}

// DeleteCloudFrontOriginAccessIdentity is undocumented.
func (c *CloudFront) DeleteCloudFrontOriginAccessIdentity(req *DeleteCloudFrontOriginAccessIdentityRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// DeleteDistribution is undocumented.
func (c *CloudFront) DeleteDistribution(req *DeleteDistributionRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// DeleteStreamingDistribution is undocumented.
func (c *CloudFront) DeleteStreamingDistribution(req *DeleteStreamingDistributionRequest) (err error) {
	// NRE

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("DELETE", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()

	return
}

// GetCloudFrontOriginAccessIdentity get the information about an origin
// access identity.
func (c *CloudFront) GetCloudFrontOriginAccessIdentity(req *GetCloudFrontOriginAccessIdentityRequest) (resp *GetCloudFrontOriginAccessIdentityResult, err error) {
	resp = &GetCloudFrontOriginAccessIdentityResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// GetCloudFrontOriginAccessIdentityConfig get the configuration
// information about an origin access identity.
func (c *CloudFront) GetCloudFrontOriginAccessIdentityConfig(req *GetCloudFrontOriginAccessIdentityConfigRequest) (resp *GetCloudFrontOriginAccessIdentityConfigResult, err error) {
	resp = &GetCloudFrontOriginAccessIdentityConfigResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// GetDistribution is undocumented.
func (c *CloudFront) GetDistribution(req *GetDistributionRequest) (resp *GetDistributionResult, err error) {
	resp = &GetDistributionResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// GetDistributionConfig get the configuration information about a
// distribution.
func (c *CloudFront) GetDistributionConfig(req *GetDistributionConfigRequest) (resp *GetDistributionConfigResult, err error) {
	resp = &GetDistributionConfigResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// GetInvalidation is undocumented.
func (c *CloudFront) GetInvalidation(req *GetInvalidationRequest) (resp *GetInvalidationResult, err error) {
	resp = &GetInvalidationResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution/{DistributionId}/invalidation/{Id}"

	if req.DistributionID != nil {
		uri = strings.Replace(uri, "{"+"DistributionId"+"}", *req.DistributionID, -1)
		uri = strings.Replace(uri, "{"+"DistributionId+"+"}", *req.DistributionID, -1)
	}

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// GetStreamingDistribution get the information about a streaming
// distribution.
func (c *CloudFront) GetStreamingDistribution(req *GetStreamingDistributionRequest) (resp *GetStreamingDistributionResult, err error) {
	resp = &GetStreamingDistributionResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution/{Id}"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// GetStreamingDistributionConfig get the configuration information about a
// streaming distribution.
func (c *CloudFront) GetStreamingDistributionConfig(req *GetStreamingDistributionConfigRequest) (resp *GetStreamingDistributionConfigResult, err error) {
	resp = &GetStreamingDistributionConfigResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// ListCloudFrontOriginAccessIdentities is undocumented.
func (c *CloudFront) ListCloudFrontOriginAccessIdentities(req *ListCloudFrontOriginAccessIdentitiesRequest) (resp *ListCloudFrontOriginAccessIdentitiesResult, err error) {
	resp = &ListCloudFrontOriginAccessIdentitiesResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront"

	q := url.Values{}

	if req.Marker != nil {
		q.Set("Marker", *req.Marker)
	}

	if req.MaxItems != nil {
		q.Set("MaxItems", *req.MaxItems)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// ListDistributions is undocumented.
func (c *CloudFront) ListDistributions(req *ListDistributionsRequest) (resp *ListDistributionsResult, err error) {
	resp = &ListDistributionsResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution"

	q := url.Values{}

	if req.Marker != nil {
		q.Set("Marker", *req.Marker)
	}

	if req.MaxItems != nil {
		q.Set("MaxItems", *req.MaxItems)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// ListInvalidations is undocumented.
func (c *CloudFront) ListInvalidations(req *ListInvalidationsRequest) (resp *ListInvalidationsResult, err error) {
	resp = &ListInvalidationsResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/distribution/{DistributionId}/invalidation"

	if req.DistributionID != nil {
		uri = strings.Replace(uri, "{"+"DistributionId"+"}", *req.DistributionID, -1)
		uri = strings.Replace(uri, "{"+"DistributionId+"+"}", *req.DistributionID, -1)
	}

	q := url.Values{}

	if req.Marker != nil {
		q.Set("Marker", *req.Marker)
	}

	if req.MaxItems != nil {
		q.Set("MaxItems", *req.MaxItems)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// ListStreamingDistributions is undocumented.
func (c *CloudFront) ListStreamingDistributions(req *ListStreamingDistributionsRequest) (resp *ListStreamingDistributionsResult, err error) {
	resp = &ListStreamingDistributionsResult{}

	var body io.Reader
	var contentType string

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution"

	q := url.Values{}

	if req.Marker != nil {
		q.Set("Marker", *req.Marker)
	}

	if req.MaxItems != nil {
		q.Set("MaxItems", *req.MaxItems)
	}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("GET", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	return
}

// UpdateCloudFrontOriginAccessIdentity is undocumented.
func (c *CloudFront) UpdateCloudFrontOriginAccessIdentity(req *UpdateCloudFrontOriginAccessIdentityRequest) (resp *UpdateCloudFrontOriginAccessIdentityResult, err error) {
	resp = &UpdateCloudFrontOriginAccessIdentityResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.CloudFrontOriginAccessIdentityConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/origin-access-identity/cloudfront/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// UpdateDistribution is undocumented.
func (c *CloudFront) UpdateDistribution(req *UpdateDistributionRequest) (resp *UpdateDistributionResult, err error) {
	resp = &UpdateDistributionResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.DistributionConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/distribution/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// UpdateStreamingDistribution is undocumented.
func (c *CloudFront) UpdateStreamingDistribution(req *UpdateStreamingDistributionRequest) (resp *UpdateStreamingDistributionResult, err error) {
	resp = &UpdateStreamingDistributionResult{}

	var body io.Reader
	var contentType string

	contentType = "application/xml"
	b, err := xml.Marshal(req.StreamingDistributionConfig)
	if err != nil {
		return
	}
	body = bytes.NewReader(b)

	uri := c.client.Endpoint + "/2014-10-21/streaming-distribution/{Id}/config"

	if req.ID != nil {
		uri = strings.Replace(uri, "{"+"Id"+"}", *req.ID, -1)
		uri = strings.Replace(uri, "{"+"Id+"+"}", *req.ID, -1)
	}

	q := url.Values{}

	if len(q) > 0 {
		uri += "?" + q.Encode()
	}

	httpReq, err := http.NewRequest("PUT", uri, body)
	if err != nil {
		return
	}

	if contentType != "" {
		httpReq.Header.Set("Content-Type", contentType)
	}

	if req.IfMatch != nil {
		httpReq.Header.Set("If-Match", *req.IfMatch)
	}

	httpResp, err := c.client.Do(httpReq)
	if err != nil {
		return
	}

	defer httpResp.Body.Close()
	if e := xml.NewDecoder(httpResp.Body).Decode(resp); e != nil && e != io.EOF {
		err = e
		return
	}

	if s := httpResp.Header.Get("ETag"); s != "" {

		resp.ETag = &s

	}

	return
}

// ActiveTrustedSigners is undocumented.
type ActiveTrustedSigners struct {
	Enabled  aws.BooleanValue `xml:"Enabled"`
	Items    []Signer         `xml:"Items"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

// Aliases is undocumented.
type Aliases struct {
	Items    []string         `xml:"Items"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

// AllowedMethods is undocumented.
type AllowedMethods struct {
	CachedMethods *CachedMethods   `xml:"CachedMethods"`
	Items         []string         `xml:"Items"`
	Quantity      aws.IntegerValue `xml:"Quantity"`
}

// CacheBehavior is undocumented.
type CacheBehavior struct {
	AllowedMethods       *AllowedMethods  `xml:"AllowedMethods"`
	ForwardedValues      *ForwardedValues `xml:"ForwardedValues"`
	MinTTL               aws.LongValue    `xml:"MinTTL"`
	PathPattern          aws.StringValue  `xml:"PathPattern"`
	SmoothStreaming      aws.BooleanValue `xml:"SmoothStreaming"`
	TargetOriginID       aws.StringValue  `xml:"TargetOriginId"`
	TrustedSigners       *TrustedSigners  `xml:"TrustedSigners"`
	ViewerProtocolPolicy aws.StringValue  `xml:"ViewerProtocolPolicy"`
}

// CacheBehaviors is undocumented.
type CacheBehaviors struct {
	Items    []CacheBehavior  `xml:"Items"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

// CachedMethods is undocumented.
type CachedMethods struct {
	Items    []string         `xml:"Items"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

// CloudFrontOriginAccessIdentity is undocumented.
type CloudFrontOriginAccessIdentity struct {
	CloudFrontOriginAccessIdentityConfig *CloudFrontOriginAccessIdentityConfig `xml:"CloudFrontOriginAccessIdentityConfig"`
	ID                                   aws.StringValue                       `xml:"Id"`
	S3CanonicalUserID                    aws.StringValue                       `xml:"S3CanonicalUserId"`
}

// CloudFrontOriginAccessIdentityConfig is undocumented.
type CloudFrontOriginAccessIdentityConfig struct {
	CallerReference aws.StringValue `xml:"CallerReference"`
	Comment         aws.StringValue `xml:"Comment"`
}

// CloudFrontOriginAccessIdentityList is undocumented.
type CloudFrontOriginAccessIdentityList struct {
	IsTruncated aws.BooleanValue                        `xml:"IsTruncated"`
	Items       []CloudFrontOriginAccessIdentitySummary `xml:"Items"`
	Marker      aws.StringValue                         `xml:"Marker"`
	MaxItems    aws.IntegerValue                        `xml:"MaxItems"`
	NextMarker  aws.StringValue                         `xml:"NextMarker"`
	Quantity    aws.IntegerValue                        `xml:"Quantity"`
}

// CloudFrontOriginAccessIdentitySummary is undocumented.
type CloudFrontOriginAccessIdentitySummary struct {
	Comment           aws.StringValue `xml:"Comment"`
	ID                aws.StringValue `xml:"Id"`
	S3CanonicalUserID aws.StringValue `xml:"S3CanonicalUserId"`
}

// CookieNames is undocumented.
type CookieNames struct {
	Items    []string         `xml:"Items"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

// CookiePreference is undocumented.
type CookiePreference struct {
	Forward          aws.StringValue `xml:"Forward"`
	WhitelistedNames *CookieNames    `xml:"WhitelistedNames"`
}

// CreateCloudFrontOriginAccessIdentityRequest is undocumented.
type CreateCloudFrontOriginAccessIdentityRequest struct {
	CloudFrontOriginAccessIdentityConfig *CloudFrontOriginAccessIdentityConfig `xml:"CloudFrontOriginAccessIdentityConfig"`
}

// CreateCloudFrontOriginAccessIdentityResult is undocumented.
type CreateCloudFrontOriginAccessIdentityResult struct {
	CloudFrontOriginAccessIdentity *CloudFrontOriginAccessIdentity `xml:"CloudFrontOriginAccessIdentity"`
	ETag                           aws.StringValue                 `xml:"ETag"`
	Location                       aws.StringValue                 `xml:"Location"`
}

// CreateDistributionRequest is undocumented.
type CreateDistributionRequest struct {
	DistributionConfig *DistributionConfig `xml:"DistributionConfig"`
}

// CreateDistributionResult is undocumented.
type CreateDistributionResult struct {
	Distribution *Distribution   `xml:"Distribution"`
	ETag         aws.StringValue `xml:"ETag"`
	Location     aws.StringValue `xml:"Location"`
}

// CreateInvalidationRequest is undocumented.
type CreateInvalidationRequest struct {
	DistributionID    aws.StringValue    `xml:"DistributionId"`
	InvalidationBatch *InvalidationBatch `xml:"InvalidationBatch"`
}

// CreateInvalidationResult is undocumented.
type CreateInvalidationResult struct {
	Invalidation *Invalidation   `xml:"Invalidation"`
	Location     aws.StringValue `xml:"Location"`
}

// CreateStreamingDistributionRequest is undocumented.
type CreateStreamingDistributionRequest struct {
	StreamingDistributionConfig *StreamingDistributionConfig `xml:"StreamingDistributionConfig"`
}

// CreateStreamingDistributionResult is undocumented.
type CreateStreamingDistributionResult struct {
	ETag                  aws.StringValue        `xml:"ETag"`
	Location              aws.StringValue        `xml:"Location"`
	StreamingDistribution *StreamingDistribution `xml:"StreamingDistribution"`
}

// CustomErrorResponse is undocumented.
type CustomErrorResponse struct {
	ErrorCachingMinTTL aws.LongValue    `xml:"ErrorCachingMinTTL"`
	ErrorCode          aws.IntegerValue `xml:"ErrorCode"`
	ResponseCode       aws.StringValue  `xml:"ResponseCode"`
	ResponsePagePath   aws.StringValue  `xml:"ResponsePagePath"`
}

// CustomErrorResponses is undocumented.
type CustomErrorResponses struct {
	Items    []CustomErrorResponse `xml:"Items"`
	Quantity aws.IntegerValue      `xml:"Quantity"`
}

// CustomOriginConfig is undocumented.
type CustomOriginConfig struct {
	HTTPPort             aws.IntegerValue `xml:"HTTPPort"`
	HTTPSPort            aws.IntegerValue `xml:"HTTPSPort"`
	OriginProtocolPolicy aws.StringValue  `xml:"OriginProtocolPolicy"`
}

// DefaultCacheBehavior is undocumented.
type DefaultCacheBehavior struct {
	AllowedMethods       *AllowedMethods  `xml:"AllowedMethods"`
	ForwardedValues      *ForwardedValues `xml:"ForwardedValues"`
	MinTTL               aws.LongValue    `xml:"MinTTL"`
	SmoothStreaming      aws.BooleanValue `xml:"SmoothStreaming"`
	TargetOriginID       aws.StringValue  `xml:"TargetOriginId"`
	TrustedSigners       *TrustedSigners  `xml:"TrustedSigners"`
	ViewerProtocolPolicy aws.StringValue  `xml:"ViewerProtocolPolicy"`
}

// DeleteCloudFrontOriginAccessIdentityRequest is undocumented.
type DeleteCloudFrontOriginAccessIdentityRequest struct {
	ID      aws.StringValue `xml:"Id"`
	IfMatch aws.StringValue `xml:"If-Match"`
}

// DeleteDistributionRequest is undocumented.
type DeleteDistributionRequest struct {
	ID      aws.StringValue `xml:"Id"`
	IfMatch aws.StringValue `xml:"If-Match"`
}

// DeleteStreamingDistributionRequest is undocumented.
type DeleteStreamingDistributionRequest struct {
	ID      aws.StringValue `xml:"Id"`
	IfMatch aws.StringValue `xml:"If-Match"`
}

// Distribution is undocumented.
type Distribution struct {
	ActiveTrustedSigners          *ActiveTrustedSigners `xml:"ActiveTrustedSigners"`
	DistributionConfig            *DistributionConfig   `xml:"DistributionConfig"`
	DomainName                    aws.StringValue       `xml:"DomainName"`
	ID                            aws.StringValue       `xml:"Id"`
	InProgressInvalidationBatches aws.IntegerValue      `xml:"InProgressInvalidationBatches"`
	LastModifiedTime              time.Time             `xml:"LastModifiedTime"`
	Status                        aws.StringValue       `xml:"Status"`
}

// DistributionConfig is undocumented.
type DistributionConfig struct {
	Aliases              *Aliases              `xml:"Aliases"`
	CacheBehaviors       *CacheBehaviors       `xml:"CacheBehaviors"`
	CallerReference      aws.StringValue       `xml:"CallerReference"`
	Comment              aws.StringValue       `xml:"Comment"`
	CustomErrorResponses *CustomErrorResponses `xml:"CustomErrorResponses"`
	DefaultCacheBehavior *DefaultCacheBehavior `xml:"DefaultCacheBehavior"`
	DefaultRootObject    aws.StringValue       `xml:"DefaultRootObject"`
	Enabled              aws.BooleanValue      `xml:"Enabled"`
	Logging              *LoggingConfig        `xml:"Logging"`
	Origins              *Origins              `xml:"Origins"`
	PriceClass           aws.StringValue       `xml:"PriceClass"`
	Restrictions         *Restrictions         `xml:"Restrictions"`
	ViewerCertificate    *ViewerCertificate    `xml:"ViewerCertificate"`
}

// DistributionList is undocumented.
type DistributionList struct {
	IsTruncated aws.BooleanValue      `xml:"IsTruncated"`
	Items       []DistributionSummary `xml:"Items"`
	Marker      aws.StringValue       `xml:"Marker"`
	MaxItems    aws.IntegerValue      `xml:"MaxItems"`
	NextMarker  aws.StringValue       `xml:"NextMarker"`
	Quantity    aws.IntegerValue      `xml:"Quantity"`
}

// DistributionSummary is undocumented.
type DistributionSummary struct {
	Aliases              *Aliases              `xml:"Aliases"`
	CacheBehaviors       *CacheBehaviors       `xml:"CacheBehaviors"`
	Comment              aws.StringValue       `xml:"Comment"`
	CustomErrorResponses *CustomErrorResponses `xml:"CustomErrorResponses"`
	DefaultCacheBehavior *DefaultCacheBehavior `xml:"DefaultCacheBehavior"`
	DomainName           aws.StringValue       `xml:"DomainName"`
	Enabled              aws.BooleanValue      `xml:"Enabled"`
	ID                   aws.StringValue       `xml:"Id"`
	LastModifiedTime     time.Time             `xml:"LastModifiedTime"`
	Origins              *Origins              `xml:"Origins"`
	PriceClass           aws.StringValue       `xml:"PriceClass"`
	Restrictions         *Restrictions         `xml:"Restrictions"`
	Status               aws.StringValue       `xml:"Status"`
	ViewerCertificate    *ViewerCertificate    `xml:"ViewerCertificate"`
}

// ForwardedValues is undocumented.
type ForwardedValues struct {
	Cookies     *CookiePreference `xml:"Cookies"`
	Headers     *Headers          `xml:"Headers"`
	QueryString aws.BooleanValue  `xml:"QueryString"`
}

// GeoRestriction is undocumented.
type GeoRestriction struct {
	Items           []string         `xml:"Items"`
	Quantity        aws.IntegerValue `xml:"Quantity"`
	RestrictionType aws.StringValue  `xml:"RestrictionType"`
}

// GetCloudFrontOriginAccessIdentityConfigRequest is undocumented.
type GetCloudFrontOriginAccessIdentityConfigRequest struct {
	ID aws.StringValue `xml:"Id"`
}

// GetCloudFrontOriginAccessIdentityConfigResult is undocumented.
type GetCloudFrontOriginAccessIdentityConfigResult struct {
	CloudFrontOriginAccessIdentityConfig *CloudFrontOriginAccessIdentityConfig `xml:"CloudFrontOriginAccessIdentityConfig"`
	ETag                                 aws.StringValue                       `xml:"ETag"`
}

// GetCloudFrontOriginAccessIdentityRequest is undocumented.
type GetCloudFrontOriginAccessIdentityRequest struct {
	ID aws.StringValue `xml:"Id"`
}

// GetCloudFrontOriginAccessIdentityResult is undocumented.
type GetCloudFrontOriginAccessIdentityResult struct {
	CloudFrontOriginAccessIdentity *CloudFrontOriginAccessIdentity `xml:"CloudFrontOriginAccessIdentity"`
	ETag                           aws.StringValue                 `xml:"ETag"`
}

// GetDistributionConfigRequest is undocumented.
type GetDistributionConfigRequest struct {
	ID aws.StringValue `xml:"Id"`
}

// GetDistributionConfigResult is undocumented.
type GetDistributionConfigResult struct {
	DistributionConfig *DistributionConfig `xml:"DistributionConfig"`
	ETag               aws.StringValue     `xml:"ETag"`
}

// GetDistributionRequest is undocumented.
type GetDistributionRequest struct {
	ID aws.StringValue `xml:"Id"`
}

// GetDistributionResult is undocumented.
type GetDistributionResult struct {
	Distribution *Distribution   `xml:"Distribution"`
	ETag         aws.StringValue `xml:"ETag"`
}

// GetInvalidationRequest is undocumented.
type GetInvalidationRequest struct {
	DistributionID aws.StringValue `xml:"DistributionId"`
	ID             aws.StringValue `xml:"Id"`
}

// GetInvalidationResult is undocumented.
type GetInvalidationResult struct {
	Invalidation *Invalidation `xml:"Invalidation"`
}

// GetStreamingDistributionConfigRequest is undocumented.
type GetStreamingDistributionConfigRequest struct {
	ID aws.StringValue `xml:"Id"`
}

// GetStreamingDistributionConfigResult is undocumented.
type GetStreamingDistributionConfigResult struct {
	ETag                        aws.StringValue              `xml:"ETag"`
	StreamingDistributionConfig *StreamingDistributionConfig `xml:"StreamingDistributionConfig"`
}

// GetStreamingDistributionRequest is undocumented.
type GetStreamingDistributionRequest struct {
	ID aws.StringValue `xml:"Id"`
}

// GetStreamingDistributionResult is undocumented.
type GetStreamingDistributionResult struct {
	ETag                  aws.StringValue        `xml:"ETag"`
	StreamingDistribution *StreamingDistribution `xml:"StreamingDistribution"`
}

// Headers is undocumented.
type Headers struct {
	Items    []string         `xml:"Items"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

// Invalidation is undocumented.
type Invalidation struct {
	CreateTime        time.Time          `xml:"CreateTime"`
	ID                aws.StringValue    `xml:"Id"`
	InvalidationBatch *InvalidationBatch `xml:"InvalidationBatch"`
	Status            aws.StringValue    `xml:"Status"`
}

// InvalidationBatch is undocumented.
type InvalidationBatch struct {
	CallerReference aws.StringValue `xml:"CallerReference"`
	Paths           *Paths          `xml:"Paths"`
}

// InvalidationList is undocumented.
type InvalidationList struct {
	IsTruncated aws.BooleanValue      `xml:"IsTruncated"`
	Items       []InvalidationSummary `xml:"Items"`
	Marker      aws.StringValue       `xml:"Marker"`
	MaxItems    aws.IntegerValue      `xml:"MaxItems"`
	NextMarker  aws.StringValue       `xml:"NextMarker"`
	Quantity    aws.IntegerValue      `xml:"Quantity"`
}

// InvalidationSummary is undocumented.
type InvalidationSummary struct {
	CreateTime time.Time       `xml:"CreateTime"`
	ID         aws.StringValue `xml:"Id"`
	Status     aws.StringValue `xml:"Status"`
}

// KeyPairIds is undocumented.
type KeyPairIds struct {
	Items    []string         `xml:"Items"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

// ListCloudFrontOriginAccessIdentitiesRequest is undocumented.
type ListCloudFrontOriginAccessIdentitiesRequest struct {
	Marker   aws.StringValue `xml:"Marker"`
	MaxItems aws.StringValue `xml:"MaxItems"`
}

// ListCloudFrontOriginAccessIdentitiesResult is undocumented.
type ListCloudFrontOriginAccessIdentitiesResult struct {
	CloudFrontOriginAccessIdentityList *CloudFrontOriginAccessIdentityList `xml:"CloudFrontOriginAccessIdentityList"`
}

// ListDistributionsRequest is undocumented.
type ListDistributionsRequest struct {
	Marker   aws.StringValue `xml:"Marker"`
	MaxItems aws.StringValue `xml:"MaxItems"`
}

// ListDistributionsResult is undocumented.
type ListDistributionsResult struct {
	DistributionList *DistributionList `xml:"DistributionList"`
}

// ListInvalidationsRequest is undocumented.
type ListInvalidationsRequest struct {
	DistributionID aws.StringValue `xml:"DistributionId"`
	Marker         aws.StringValue `xml:"Marker"`
	MaxItems       aws.StringValue `xml:"MaxItems"`
}

// ListInvalidationsResult is undocumented.
type ListInvalidationsResult struct {
	InvalidationList *InvalidationList `xml:"InvalidationList"`
}

// ListStreamingDistributionsRequest is undocumented.
type ListStreamingDistributionsRequest struct {
	Marker   aws.StringValue `xml:"Marker"`
	MaxItems aws.StringValue `xml:"MaxItems"`
}

// ListStreamingDistributionsResult is undocumented.
type ListStreamingDistributionsResult struct {
	StreamingDistributionList *StreamingDistributionList `xml:"StreamingDistributionList"`
}

// LoggingConfig is undocumented.
type LoggingConfig struct {
	Bucket         aws.StringValue  `xml:"Bucket"`
	Enabled        aws.BooleanValue `xml:"Enabled"`
	IncludeCookies aws.BooleanValue `xml:"IncludeCookies"`
	Prefix         aws.StringValue  `xml:"Prefix"`
}

// Origin is undocumented.
type Origin struct {
	CustomOriginConfig *CustomOriginConfig `xml:"CustomOriginConfig"`
	DomainName         aws.StringValue     `xml:"DomainName"`
	ID                 aws.StringValue     `xml:"Id"`
	S3OriginConfig     *S3OriginConfig     `xml:"S3OriginConfig"`
}

// Origins is undocumented.
type Origins struct {
	Items    []Origin         `xml:"Items"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

// Paths is undocumented.
type Paths struct {
	Items    []string         `xml:"Items"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

// Restrictions is undocumented.
type Restrictions struct {
	GeoRestriction *GeoRestriction `xml:"GeoRestriction"`
}

// S3Origin is undocumented.
type S3Origin struct {
	DomainName           aws.StringValue `xml:"DomainName"`
	OriginAccessIdentity aws.StringValue `xml:"OriginAccessIdentity"`
}

// S3OriginConfig is undocumented.
type S3OriginConfig struct {
	OriginAccessIdentity aws.StringValue `xml:"OriginAccessIdentity"`
}

// Signer is undocumented.
type Signer struct {
	AwsAccountNumber aws.StringValue `xml:"AwsAccountNumber"`
	KeyPairIds       *KeyPairIds     `xml:"KeyPairIds"`
}

// StreamingDistribution is undocumented.
type StreamingDistribution struct {
	ActiveTrustedSigners        *ActiveTrustedSigners        `xml:"ActiveTrustedSigners"`
	DomainName                  aws.StringValue              `xml:"DomainName"`
	ID                          aws.StringValue              `xml:"Id"`
	LastModifiedTime            time.Time                    `xml:"LastModifiedTime"`
	Status                      aws.StringValue              `xml:"Status"`
	StreamingDistributionConfig *StreamingDistributionConfig `xml:"StreamingDistributionConfig"`
}

// StreamingDistributionConfig is undocumented.
type StreamingDistributionConfig struct {
	Aliases         *Aliases                `xml:"Aliases"`
	CallerReference aws.StringValue         `xml:"CallerReference"`
	Comment         aws.StringValue         `xml:"Comment"`
	Enabled         aws.BooleanValue        `xml:"Enabled"`
	Logging         *StreamingLoggingConfig `xml:"Logging"`
	PriceClass      aws.StringValue         `xml:"PriceClass"`
	S3Origin        *S3Origin               `xml:"S3Origin"`
	TrustedSigners  *TrustedSigners         `xml:"TrustedSigners"`
}

// StreamingDistributionList is undocumented.
type StreamingDistributionList struct {
	IsTruncated aws.BooleanValue               `xml:"IsTruncated"`
	Items       []StreamingDistributionSummary `xml:"Items"`
	Marker      aws.StringValue                `xml:"Marker"`
	MaxItems    aws.IntegerValue               `xml:"MaxItems"`
	NextMarker  aws.StringValue                `xml:"NextMarker"`
	Quantity    aws.IntegerValue               `xml:"Quantity"`
}

// StreamingDistributionSummary is undocumented.
type StreamingDistributionSummary struct {
	Aliases          *Aliases         `xml:"Aliases"`
	Comment          aws.StringValue  `xml:"Comment"`
	DomainName       aws.StringValue  `xml:"DomainName"`
	Enabled          aws.BooleanValue `xml:"Enabled"`
	ID               aws.StringValue  `xml:"Id"`
	LastModifiedTime time.Time        `xml:"LastModifiedTime"`
	PriceClass       aws.StringValue  `xml:"PriceClass"`
	S3Origin         *S3Origin        `xml:"S3Origin"`
	Status           aws.StringValue  `xml:"Status"`
	TrustedSigners   *TrustedSigners  `xml:"TrustedSigners"`
}

// StreamingLoggingConfig is undocumented.
type StreamingLoggingConfig struct {
	Bucket  aws.StringValue  `xml:"Bucket"`
	Enabled aws.BooleanValue `xml:"Enabled"`
	Prefix  aws.StringValue  `xml:"Prefix"`
}

// TrustedSigners is undocumented.
type TrustedSigners struct {
	Enabled  aws.BooleanValue `xml:"Enabled"`
	Items    []string         `xml:"Items"`
	Quantity aws.IntegerValue `xml:"Quantity"`
}

// UpdateCloudFrontOriginAccessIdentityRequest is undocumented.
type UpdateCloudFrontOriginAccessIdentityRequest struct {
	CloudFrontOriginAccessIdentityConfig *CloudFrontOriginAccessIdentityConfig `xml:"CloudFrontOriginAccessIdentityConfig"`
	ID                                   aws.StringValue                       `xml:"Id"`
	IfMatch                              aws.StringValue                       `xml:"If-Match"`
}

// UpdateCloudFrontOriginAccessIdentityResult is undocumented.
type UpdateCloudFrontOriginAccessIdentityResult struct {
	CloudFrontOriginAccessIdentity *CloudFrontOriginAccessIdentity `xml:"CloudFrontOriginAccessIdentity"`
	ETag                           aws.StringValue                 `xml:"ETag"`
}

// UpdateDistributionRequest is undocumented.
type UpdateDistributionRequest struct {
	DistributionConfig *DistributionConfig `xml:"DistributionConfig"`
	ID                 aws.StringValue     `xml:"Id"`
	IfMatch            aws.StringValue     `xml:"If-Match"`
}

// UpdateDistributionResult is undocumented.
type UpdateDistributionResult struct {
	Distribution *Distribution   `xml:"Distribution"`
	ETag         aws.StringValue `xml:"ETag"`
}

// UpdateStreamingDistributionRequest is undocumented.
type UpdateStreamingDistributionRequest struct {
	ID                          aws.StringValue              `xml:"Id"`
	IfMatch                     aws.StringValue              `xml:"If-Match"`
	StreamingDistributionConfig *StreamingDistributionConfig `xml:"StreamingDistributionConfig"`
}

// UpdateStreamingDistributionResult is undocumented.
type UpdateStreamingDistributionResult struct {
	ETag                  aws.StringValue        `xml:"ETag"`
	StreamingDistribution *StreamingDistribution `xml:"StreamingDistribution"`
}

// ViewerCertificate is undocumented.
type ViewerCertificate struct {
	CloudFrontDefaultCertificate aws.BooleanValue `xml:"CloudFrontDefaultCertificate"`
	IAMCertificateID             aws.StringValue  `xml:"IAMCertificateId"`
	MinimumProtocolVersion       aws.StringValue  `xml:"MinimumProtocolVersion"`
	SSLSupportMethod             aws.StringValue  `xml:"SSLSupportMethod"`
}

// avoid errors if the packages aren't referenced
var _ time.Time
var _ xml.Name

var _ bytes.Reader
var _ url.URL
var _ fmt.Stringer
var _ strings.Reader
var _ strconv.NumError
var _ = ioutil.Discard
